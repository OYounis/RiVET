<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RiVET: Modules */</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="RISC-V_ Stacked_Black.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RiVET
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">A scalable environment for RISC processor verification and performance evaluation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__SVmodule.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Modules */</div>  </div>
</div><!--header-->
<div class="contents">


<h3><a id="md_docs_style_guides_DVCodingStyle"></a>lowRISC SystemVerilog Coding Style Guide for Design Verification</h3><div class="textblock">This document is a supplemental Style Guide to the <a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md">lowRISC Verilog style guide</a>, with emphasis on writing code for Design Verification (DV) in SystemVerilog, following the <a href="https://www.accellera.org/images//downloads/standards/uvm/uvm_users_guide_1.2.pdf">UVM methodology</a>.<h1><a class="anchor" id="autotoc_md1"></a>
Table of Contents</h1>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#naming-and-style">Naming and Style</a></li>
<li><a href="#directory-structure-and-packages">Directory Structure and Packages</a><ul>
<li><a href="#uvm_agent-directory-structure">UVM Agent Directory Structure</a></li>
<li><a href="#uvm_env-directory-structure">UVM Env Directory Structure</a></li>
</ul>
</li>
<li><a href="#uvm-guidelines">UVM Guidelines</a><ul>
<li><a href="#class-definitions">Class Definitions</a></li>
<li><a href="#uvm-new-functions">UVM new functions</a></li>
<li><a href="#uvm_scoreboard-usage">uvm_scoreboard usage</a></li>
<li><a href="#uvm_agent-usage">uvm_agent usage</a></li>
<li><a href="#uvm_driver-usage">uvm_driver usage</a></li>
<li><a href="#macro-usage">Macro Usage</a><ul>
<li><a href="#guidelines-for-uvm-library-macros">Guidelines for UVM library macros</a></li>
<li><a href="#guidelines-for-macros-within-dv_macrossvh">Guidelines for macros within dv_macros.svh</a></li>
<li><a href="#general-macro-use-guidelines">General macro use guidelines</a></li>
<li><a href="#typical-gotchas-with-macro-usage">Typical gotchas with macro usage</a></li>
</ul>
</li>
<li><a href="#factory">Factory</a></li>
<li><a href="#configuration-mechanism">Configuration Mechanism</a></li>
<li><a href="#sequences">Sequences</a></li>
<li><a href="#sequence-items">Sequence Items</a></li>
<li><a href="#ral-usage">RAL Usage</a></li>
<li><a href="#objections-and-coordinating-}-of-test">Objections and Coordinating End of Test</a></li>
<li><a href="#logging-and-print-messages">Logging and Print Messages</a></li>
<li><a href="#dpi-and-c-connections">DPI and C Connections</a></li>
</ul>
</li>
<li><a href="#systemverilog-language-features">SystemVerilog Language Features</a><ul>
<li><a href="#-declarations">Function Declarations</a></li>
<li><a href="#randomization">Randomization</a></li>
<li><a href="#enums">Enums</a></li>
<li><a href="#interfaces,-clocking-blocks,-modports">Interfaces, Clocking Blocks, Modports</a></li>
<li><a href="#loop-operators">Loop Operators</a></li>
<li><a href="#code-within-asserts">Code Within Asserts</a></li>
<li><a href="#wait-and-fork">Wait and Fork</a></li>
<li><a href="#wait-and-non-forever-loop">Wait And Non-Forever Loop</a></li>
<li><a href="#void-casts">Void Casts</a></li>
<li><a href="#associative-arrays">Associative Arrays</a></li>
<li><a href="#bind-statements">Bind Statements</a></li>
<li><a href="#simulator-specific-code">Simulator Specific Code</a></li>
<li><a href="#forbidden-system-tasks-and-functions">Forbidden System Tasks and Functions</a></li>
<li><a href="#Backdoor Force and Probe in Chip-level">Backdoor Force and Probe in Chip-level</a></li>
</ul>
</li>
<li><a href="#systemverilog-assertions">SystemVerilog Assertions</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Introduction</h1>
<p>This guide defines the Comportable style for DV-specific SystemVerilog code. The goal is to use this common set of guidelines when implementing testbenches using the UVM methodology to allow all developed Comportable DV code to be uniform, reusable, and portable. This document assumes previous experience and working knowledge of UVM, and as such all included code snippets will be fairly concise.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Naming and Style</h1>
<p>Refer to <a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#naming">lowRISC Verilog naming conventions</a> for any general naming style guidelines. In general, common UVM testbench components must be declared and assigned handles as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Testbench component   </th><th class="markdownTableHeadNone">Style    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Virtual interfaces   </td><td class="markdownTableBodyNone">virtual &lt;if_name&gt;_if &lt;if_name&gt;_vif() {    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Environment   </td><td class="markdownTableBodyNone">&lt;dut&gt;_env env;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Env level config object   </td><td class="markdownTableBodyNone">rand &lt;dut&gt;_env_cfg cfg;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Env coverage collection object   </td><td class="markdownTableBodyNone">&lt;dut&gt;_env_cov cov;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Agent   </td><td class="markdownTableBodyNone">&lt;dut&gt;<em>agent m</em> &lt;dut&gt;_agent;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Agent level config object   </td><td class="markdownTableBodyNone">rand &lt;dut&gt;<em>agent_cfg m</em> &lt;dut&gt;_agent_cfg;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Agent coverage collection object   </td><td class="markdownTableBodyNone">&lt;dut&gt;_agent_cov cov;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Driver   </td><td class="markdownTableBodyNone">&lt;dut&gt;_driver driver;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Monitor   </td><td class="markdownTableBodyNone">&lt;dut&gt;_monitor monitor;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Scoreboard   </td><td class="markdownTableBodyNone">&lt;dut&gt;_scoreboard scoreboard;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Virtual sequencer   </td><td class="markdownTableBodyNone">&lt;dut&gt;_virtual_sequencer virtual_sequencer;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Sequencer   </td><td class="markdownTableBodyNone">&lt;dut&gt;_sequencer &lt;dut&gt;_sequencer;   </td></tr>
</table>
<p>Additional naming guidelines:</p>
<ol type="1">
<li>The top level testbench file that instantiates the DUT must be named tb.sv. The testbench /** */ , tb.sv must be dut. Using this standardized naming allows universal usage of any supporting DV sources (coverage cfg files, and so on).</li>
<li>When instantiating any objects, the name argument to type_id::create() must match the name of the variable being assigned to. This ensures that any reporting messages refer to the right objects.</li>
<li>To avoid name collisions, it is recommended that global types and types defined within a package have unique prefixes. This includes typedefs, enumerated types/values, package parameters, package localparams, any functions/tasks, and macros. This prefixing is not necessary for any types defined within a class, module, or interface, as they will be scoped by the parent entity.</li>
<li>Note that all package variables (parameters, etc.) must have a specified type.</li>
<li>When instantiating a user-defined class member variable that is a class object, it is recommended (but not necessary) to follow this prefixing scheme:<ul>
<li>Prefix the instance name of the class object with m_, as such:</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md4"></a>
systemverilog</h1>
<p>my_animal m_my_animal() { </p>
<h1><a class="anchor" id="autotoc_md5"></a>
autotoc_md5</h1>
<p>This scheme does not apply to any class member variables that are not themselves class objects.</p>
<ul>
<li>If multiple instantiations of the class are desired without an array to store them, use &lt;class_name&gt; m_ &lt;instance_name&gt; to declare a variable, and use an informative instance name.</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
systemverilog</h1>
<p>my_animal m_my_cat { public: my_animal m_my_dog; my_animal m_my_fish; </p>
<h1><a class="anchor" id="autotoc_md7"></a>
autotoc_md7</h1>
<ul>
<li>If an array of class handles or logic is desired, choose a name such that it follows one of the following schemes:</li>
</ul>
<h1><a class="anchor" id="autotoc_md8"></a>
systemverilog</h1>
<p>int NUM_ANIMALS = 10 { public: // This plural convention is recommended, but both are equally acceptable my_animal m_my_animals[NUM_ANIMALS]; my_animal m_my_animal_array[NUM_ANIMALS]; </p>
<h1><a class="anchor" id="autotoc_md9"></a>
autotoc_md9</h1>
<h1><a class="anchor" id="autotoc_md10"></a>
Directory Structure and Packages</h1>
<p>Define one class per file, and the filename should match the name of the class. The class files must be include-ed into the package file. Directory structure of the UVM agent and UVM environment testbench components along with their related files are shown below, with some additional guidance on declaring functions from a package context.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
uvm_agent directory structure</h2>
<ul>
<li>All DV code for a particular agent will be placed under a single directory &lt;block&gt;_agent/ separate from the DV code for the corresponding environment.</li>
<li>It is highly recommended that all agent directories be placed in a common area to create a repository of UVM agents that allows for more vertical reuse.</li>
</ul>
<h1><a class="anchor" id="autotoc_md12"></a>
systemverilog</h1>
<p>&lt;block&gt; class files _agent/ &lt;block&gt;_if.sv &lt;block&gt;_item.sv &lt;block&gt;_agent.sv &lt;block&gt;_agent_pkg.sv &lt;block&gt;_agent_cfg.sv &lt;block&gt;_agent_cov.sv &lt;block&gt;_driver.sv &lt;block&gt;_host_driver.sv (Only if block requires a separate driver for host mode) &lt;block&gt;_device_driver.sv (Only if block requires a separate driver for device mode) &lt;block&gt;_monitor.sv &lt;block&gt;_sequencer.sv seq_lib/ &lt;block&gt;_base_seq.sv </p>
<h1><a class="anchor" id="autotoc_md13"></a>
autotoc_md13</h1>
<h2><a class="anchor" id="autotoc_md14"></a>
uvm_env directory structure</h2>
<ul>
<li>All DV code for the UVM environment, UVM tests, and top level block testbench will be placed in a directory &lt;dut&gt;/dv/ in three corresponding subdirectories &lt;dut&gt;/dv/env/, &lt;dut&gt;/dv/tests/, &lt;dut&gt;/dv/tb/.</li>
<li>The &lt;dut&gt;_env_pkg should import the &lt;dut&gt;_agent_pkg.</li>
<li>All UVM virtual sequences for a given DUT will be placed under env/seq_lib/, along with a &lt;dut&gt;_vseq_list.sv file that include-es all of the virtual sequence files. This virtual sequence list file must be include-ed by env/&lt;dut&gt;_env_pkg.sv.</li>
<li>If applicable, env/&lt;dut&gt;_env_pkg.sv must import the &lt;dut&gt;_agent_pkg.</li>
<li>tests/&lt;dut&gt;_test_pkg.sv must import the &lt;dut&gt;_env_pkg package.</li>
<li>All files include-ed into a single package must be in the same single directory.</li>
</ul>
<h1><a class="anchor" id="autotoc_md15"></a>
systemverilog</h1>
<p>&lt;dut&gt;/dv/ env/ &lt;dut&gt;_env.sv &lt;dut&gt;_env_pkg.sv &lt;dut&gt;_env_cfg.sv &lt;dut&gt;_env_cov.sv &lt;dut&gt;_scoreboard.sv &lt;dut&gt;_virtual_sequencer.sv seq_lib/ // These allow basic functionality to be added to the environment &lt;dut&gt;_base_vseq.sv &lt;dut&gt;_sanity_vseq.sv tb/ tb.sv tests/ &lt;dut&gt;_base_test.sv &lt;dut&gt;_test_pkg.sv </p>
<h1><a class="anchor" id="autotoc_md16"></a>
autotoc_md16</h1>
<p>&lt;block&gt;_agent_pkg.sv, &lt;dut&gt;_env_pkg.sv, &lt;dut&gt;_test_pkg.sv, and tb/tb.sv must include these include-es and imports:</p>
<h1><a class="anchor" id="autotoc_md17"></a>
systemverilog</h1>
<p>#include "dv_macros.svh" #include "uvm_macros.svh"</p>
<h1><a class="anchor" id="autotoc_md18"></a>
autotoc_md18</h1>
<p>An example environment level package file for an arbitrary block newblock should look similar to this:</p>
<h1><a class="anchor" id="autotoc_md19"></a>
systemverilog</h1>
<p>// dep packages</p>
<p>// macro includes #include "uvm_macros.svh" #include "dv_macros.svh"</p>
<p>// define any parameters parameter int NEW_BLOCK_PARAMETER = 10 { public:</p>
<p>// define any local types/functions/tasks typedef enum { NewblockBooleanZero, NewblockBooleanTrue } newblock_boolean_e;</p>
<p>// Functions declared within packages must be automatic automatic bit newblock_test_function(newblock_boolean_e test_boolean) { //function definition }</p>
<h1><a class="anchor" id="autotoc_md20"></a>
autotoc_md20</h1>
<h1><a class="anchor" id="autotoc_md21"></a>
UVM Guidelines</h1>
<p>Always call run_test() without the test name argument. This allows command line test overrides to be performed using +UVM_TESTNAME=&lt;testname&gt; without having to recompile and allows testlists to be created for regression runs.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Class Definitions</h2>
<ol type="1">
<li>After variable declarations, register any objects and components with the factory using the uvm_component_utils and uvm_object_utils macros.<ul>
<li>Declare any member variables to be registered with the UVM factory field automation macros uvm_field_int, uvm_field_enum, uvm_field_object, uvm_field_array_int, etc. within uvm_object/component_utils_begin and uvm_object/component_utils_end.</li>
</ul>
</li>
<li>For all field automation macros, use UVM_DEFAULT as the flag argument. For example, if it is desired that everything except comparing and printing be enabled for some rx_delay field, the macro would look like this:</li>
</ol>
<h1><a class="anchor" id="autotoc_md23"></a>
systemverilog</h1>
<p>uvm_field_int(rx_delay, UVM_DEFAULT | UVM_NOCOMPARE | UVM_NOPRINT) </p>
<h1><a class="anchor" id="autotoc_md24"></a>
autotoc_md24</h1>
<ol type="1">
<li>After factory registration, a constructor must be defined. Use the uvm_object_new macro for UVM objects and the uvm_component_new macro for UVM components. Both of these macros are defined in <a class="el" href="dv__macros_8svh.html">dv_macros.svh</a>.</li>
<li>Any constructors written manually should contain a call to super.new(name [,parent]) as the first line. Any other lines in the constructor are optional.</li>
<li>Do not add any extra arguments to the constructor other than name and parent.</li>
<li>All objects should generally be instantiated in the build_phase() for components, or in the beginning of the body() task for sequences, unless there is a good reason not to. This is to enable proper usage of uvm_factory overrides.</li>
<li>When extending any user-defined component class, super.&lt;phase_name&gt;_phase must be called for every phase method that is being overridden.</li>
<li>Transaction classes are usually logical representations of the data communicated over one or more interfaces executing a particular protocol. These classes:<ul>
<li>Should extend uvm_sequence_item.</li>
<li>Should contain only information that is relevant to the data being transmitted over an interface, and not to the means of transmit.</li>
<li>Should result in a legal transaction when randomized.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md25"></a>
UVM new() functions</h2>
<p>The new() of any class derived from uvm_object must have the default value of its name argument set to "", since the default name argument will be set by type_id::create(). The new() of any class not derived from uvm_object must not have default values set for its arguments. Examples:</p>
<p>:+1: </p>
<h1><a class="anchor" id="autotoc_md26"></a>
systemverilog</h1>
<p>// class derived from uvm_object with correct default value new (string name = "") { public: super.new(name) { }</p>
<p>// class derived from uvm_component with no default values new(string name, uvm_component parent) { super.new(name, parent); } </p>
<h1><a class="anchor" id="autotoc_md27"></a>
autotoc_md27</h1>
<p>:-1: </p>
<h1><a class="anchor" id="autotoc_md28"></a>
systemverilog</h1>
<p>// Incorrect default value used for class derived from uvm_object new(string name = "my_rand_seq") { super.new(name); }</p>
<p>// Incorrect because default values for class derived from uvm_component are provided new(string name = "", uvm_component parent) { super.new(name, parent); } </p>
<h1><a class="anchor" id="autotoc_md29"></a>
autotoc_md29</h1>
<h2><a class="anchor" id="autotoc_md30"></a>
uvm_scoreboard usage</h2>
<p>Use uvm_tlm_analysis_fifo - can be directly connected to analysis ports, and has an unbounded size so that writes will always succeed without blocking, in situations where transactions need to be stored for some time before being consumed by the scoreboard for processing.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
uvm_agent usage</h2>
<ol type="1">
<li>Interface agents should contain only a sequencer, driver, monitor, and config object.</li>
<li>Use one agent for every /** */ , driver whose instantiation is determined by the value of &lt;agent_cfg&gt;.is_active. This is placed in the agent config object to allow for better access throughout the testbench.</li>
<li>For any DUT interfaces that have multiple operation modes (such as host and device modes), two drivers should be created, one for each mode, and arbitration done in the uvm_agent::build_phase to determine which driver to instantiate. Each driver should have different sequences that correspond to it.</li>
</ol>
<h2><a class="anchor" id="autotoc_md32"></a>
uvm_driver usage</h2>
<ol type="1">
<li>A driver must only communicate with one sequencer on one SystemVerilog interface, and should not have any analysis ports.</li>
<li>A driver should not randomize any data received from transaction items sent through analysis ports.</li>
<li>A driver must assign X to any buses it controls during "don't-care" clock cycles in which no valid transaction is present.</li>
</ol>
<h2><a class="anchor" id="autotoc_md33"></a>
Macro Usage</h2>
<p>The UVM library provides several macros as shortcuts for commonly used sequences of code. In addition to this, the provided <a class="el" href="dv__macros_8svh.html">dv_macros.svh</a> file defines other utility macros for even more common code sequences.</p>
<h3><a class="anchor" id="autotoc_md34"></a>
Guidelines for UVM library macros</h3>
<ol type="1">
<li>All lowercase uvm_... expressions denote library macros, and do not require trailing semicolons.</li>
<li>uvm_object_* and uvm_component_* macros<ul>
<li>Use these macros to register classes with the uvm_factory.</li>
</ul>
</li>
<li>uvm_field_* macros<ul>
<li>Use these macros for members of sequence items. While these macros implement expensive versions of common functions required for sequence items, the overhead is generally not worth implementing custom versions for every sequence item. Additionally, these macros add a great deal of readability and help avoid coding mistakes with custom implementations. Only implement custom versions of these macros if performance becomes a very noticeable issue. Do not use these macros with classes derived from uvm_component.</li>
</ul>
</li>
<li>Do not use uvm_do macros. Instead, start sequence items on a sequencer using the following high level steps:<ul>
<li>start_item(&lt;sequence_item&gt;, &lt;priority&gt;).</li>
<li>Randomize the sequence item.</li>
<li>finish_item(&lt;sequence_item&gt;, &lt;priority&gt;).</li>
<li>get_response(&lt;response&gt;).</li>
</ul>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md35"></a>
Guidelines for macros within dv_macros.svh</h3>
<ol type="1">
<li>UVM print macros - gfn, gtn, gn, gmv<ul>
<li>These macros provide a concise wrapper for get_full_name(), get_type_name(), get_name(), and uvm_reg.get_mirrored_value(), respectively. By using these it is possible to drastically reduce line length and improve readability.</li>
</ul>
</li>
<li><a class="el" href="dv__macros_8svh.html#a45c58ac39ea4e044893b8f611f335723">downcast(&lt;extended_class_handle&gt;, &lt;base_class_handle&gt;)</a><ul>
<li>Use this macro to cast a handle for any base class object that contains a handle to an extended class to the extended class type, useful for situations that require polymorphism.</li>
</ul>
</li>
<li>uvm_object_new and uvm_component_new<ul>
<li>Use these macros to include the new() constructor for classes derived from uvm_object and uvm_component, respectively. If any additional logic must be included in the constructor, these macros must not be used, and a constructor must be written manually.</li>
</ul>
</li>
<li>uvm_create_obj and uvm_create_comp<ul>
<li>Use these macros to call create(&lt;instance_name&gt;) and create(&lt;instance_name&gt;, this), respectively.</li>
</ul>
</li>
<li>DV_CHECK_* comparison checking macros<ul>
<li>These macros must be used to perform checks on the input arguments and invoke one of the uvm_info, uvm_error, or uvm_fatal reporting macros if the check fails. These are much more concise than hand-writing the comparison checks and the corresponding UVM report macro and provide efficient readability.</li>
<li>The severity of the invoked report macro can be specified with the &lt;uvm_severity&gt; argument, the default reporting macro is uvm_error.</li>
<li>Append <em>FATAL to the } of these macro names to invoke variants of these macros that will automatically throw fatal errors upon check failure (e.g. DV_CHECK_EQ_FATAL, DV_CHECK_LE_FATAL, etc..).</em></li>
</ul>
</li>
<li><em> Randomization macros<ul>
<li><a class="el" href="dv__macros_8svh.html">dv_macros.svh</a> provides three sets of macros which must be used for all randomization functionality:<ul>
<li>DV_CHECK_RANDOMIZE_FATAL - Shorthand for foo.randomize() with a uvm_fatal check.</li>
<li>DV_CHECK_STD_RANDOMIZE_FATAL - Shorthand for std::randomize(foo) with a uvm_fatal check.</li>
<li>DV_CHECK_MEMBER_RANDOMIZE_FATAL - Shorthand for this.randomize(foo) with a uvm_fatal check.</li>
</ul>
</li>
<li>Variants of all three macros that allow constraints to be specified also exist, these macros are invoked by inserting WITH into the macro name: DV..._RANDOMIZE_WITH_FATAL.</li>
</ul>
</em></li>
<li><em> DV_EOT_PRINT_..._CONTENTS TLM fifo display macros<ul>
<li>It is recommended to use these macros to display the status of the various TLM fifos and queues in the scoreboard at the } of the test to ensure that those data structures have been emptied. There should be no pending transactions that have not yet been compared before the simulation ends. If used, these macros must be used during the check_phase.</li>
</ul>
</em></li>
<li><em> DV_SPINWAIT<ul>
<li>It is recommended to use this macro in situations that require an isolation fork to disable some process after waiting for a specified amount of time, as it provides proper process isolation such as the example below:</li>
</ul>
</em></li>
</ol>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md36"></a>
systemverilog</h1>
<p><em> // forked threads should be labeled if they serve a specific purpose, // like the isolation thread below fork : isolation_fork { fork { &lt;specified code to execute&gt; } { &lt;watchdog timer logic with error reporting&gt; } join_any disable fork() { } join </em></p>
<h1><a class="anchor" id="autotoc_md37"></a>
autotoc_md37</h1>
<p><em> </em></p>
<h3><a class="anchor" id="autotoc_md38"></a>
General macro use guidelines</h3>
<p><em></p><ol type="1">
<li>Macro Naming:<ul>
<li>If the macro wraps some fundamental UVM functionality and deals directly with UVM functions, like uvm_component_new, and so on, the macro must be named all in lower_snake_case.</li>
<li>If the macro expands into a block of code that does not deal directly with UVM functionality, and is for convenience, like the DV_CHECK_* macros, the macro must be named in UPPER_SNAKE_CASE.</li>
</ul>
</li>
<li>Macro vs. Parameters:<ul>
<li>If the intent is to define a constant that is a basic data typename or that is the result of an expression involving basic data types, a parameter (or localparam) must be used, depending on where the constants are being defined.</li>
<li>If the intent is to abstract away a code snippet or to represent a slice of an array, a macro must be used. If the macro is defined in a local perspective, it must be undefined at the } of the file, otherwise it will pollute the global namespace.</li>
</ul>
</li>
</ol>
<p></em></p>
<p><em></em></p>
<h3><a class="anchor" id="autotoc_md39"></a>
Typical gotchas with macro usage:</h3>
<p><em> While it is better to avoid macros altogether, they do make our lives easier by shortening pieces of repeated code, in a manner that cannot be achieved with a or a task. In general, the following describes the best practices to avoid common gotchas with macro usage.</em></p>
<p><em></p><ol type="1">
<li><p class="startli">Always wrap macro arguments in parentheses. If the macro evaluates to an expression, also wrap the whole expansion in parentheses.The following example illustrates how failing to do this can cause an unexpected behavior.</p>
<p class="startli">:-1: </p>
</li>
</ol>
<p></em></p>
<h1><a class="anchor" id="autotoc_md40"></a>
systemverilog</h1>
<p><em> #define AND(a, b) a &amp;&amp; b</em></p>
<p><em> assign x = AND(p || q, r) || s { public: // Bad: Wrong operator precedence! This results in: p || (q &amp;&amp; r) || s // which is not equal to ((p || q) &amp;&amp; r) || s. </em></p>
<h1><a class="anchor" id="autotoc_md41"></a>
autotoc_md41</h1>
<p><em> :+1: </em></p>
<h1><a class="anchor" id="autotoc_md42"></a>
systemverilog</h1>
<p><em> #define AND(a, b) ((a) &amp;&amp; (b))</em></p>
<p><em> assign x = AND(p || q, r) || s() { // Good: Output in-line with the expectation. </em></p>
<h1><a class="anchor" id="autotoc_md43"></a>
autotoc_md43</h1>
<p><em></p><ol type="1">
<li><p class="startli">Macro usage scope and avoiding namespace collisions.</p>
<p class="startli">Macros have a global scope regardless of where they are defined. Once compiled, they are visible to ALL subsequent sources in the same compilation unit as well as to all subsequent compilation units. Hence, care must be taken to prevent macro re-definitions. Some tools do not even warn about name collisions, causing unnecessary debug overhead.</p><ul>
<li><p class="startli">Macro names must be appropriately prefixed with a thematically chosen string. It is typical to use the file name or the package name as the prefix string for all macros defined within that source.</p>
<p class="startli">:-1: </p>
</li>
</ul>
</li>
</ol>
<p></em></p>
<h1><a class="anchor" id="autotoc_md44"></a>
systemverilog</h1>
<p><em> // file: dv_macros.h #define STRINGIFY(s) #s // Bad: UVM library code also defines a macro with the same name. // Depending on the tool, this may be flagged as an error. </em></p>
<h1><a class="anchor" id="autotoc_md45"></a>
autotoc_md45</h1>
<p><em> :+1: </em></p>
<h1><a class="anchor" id="autotoc_md46"></a>
systemverilog</h1>
<p><em> // file: dv_macros.h #define <a class="el" href="dv__macros_8svh.html#a8a32c3b2aaef1021af8464139b0d1756">DV_STRINGIFY(s)</a> #s </em></p>
<h1><a class="anchor" id="autotoc_md47"></a>
autotoc_md47</h1>
<p><em></p><ul>
<li><p class="startli">If the scope of the macros defined are global in nature (useful for the entire testbench), then place them in a separate SystemVerilog header file with ifndef guards. It must only contain macro definitions and nothing else. The file name must be suffixed with _macros and have the .svh extension to denote that it is a header file.</p>
<p class="startli">:-1: </p>
</li>
</ul>
<p></em></p>
<h1><a class="anchor" id="autotoc_md48"></a>
systemverilog</h1>
<p><em> // file: dv_macros.h automatic void get_nco() { ... } // Bad: Putting functions and tasks in a header file that is potentially // included multiple times.</em></p>
<p><em> #define DV_FOO(...) ... // Bad: No ifndef guard. Macro re-definition warnings will be thrown if // this header file is included in multiple sources. </em></p>
<h1><a class="anchor" id="autotoc_md49"></a>
autotoc_md49</h1>
<p><em> :+1: </em></p>
<h1><a class="anchor" id="autotoc_md50"></a>
systemverilog</h1>
<p><em> // file: <a class="el" href="dv__macros_8svh.html">dv_macros.svh</a> #ifndef DV_FOO #define DV_FOO(...) ... #endif</em></p>
<p><em> #ifndef DV_BAR #define DV_BAR xyz #endif </em></p>
<h1><a class="anchor" id="autotoc_md51"></a>
autotoc_md51</h1>
<p><em></p><ul>
<li><p class="startli">If the scope of the macros defined is limited to a package or source (individual interface, /** */ ), the file. Always undef them at the } of the file so that they are no longer visible to subsequent sources during compilation. Do not put ifndef guards on these macros, so that the re-definitions if encountered, are flagged.</p>
<p class="startli">:-1: </p>
</li>
</ul>
<p></em></p>
<h1><a class="anchor" id="autotoc_md52"></a>
systemverilog</h1>
<p><em> // file: foo_init_seq.sv #ifndef GET_DATA #define GET_DATA(baz) ... #endif // Bad: Macro-redefinition if encountered, will be ignored due to the // ifndef guard. Previously defined macro is invoked instead. // Bad: Macro name is not specific enough.</em></p>
<p><em> class foo_init_seq() { ... }; // EOF // Bad: Macro is not undefined at the end of the file. </em></p>
<h1><a class="anchor" id="autotoc_md53"></a>
autotoc_md53</h1>
<p><em> :+1: </em></p>
<h1><a class="anchor" id="autotoc_md54"></a>
systemverilog</h1>
<p><em> // file: foo_init_seq.sv #define GET_FOO_TX_FIFO_DATA_AFTER_OP(baz) ...</em></p>
<p><em> class foo_init_seq { public: ... };</em></p>
<p><em> #undef GET_FOO_TX_FIFO_DATA_AFTER_OP </em></p>
<h1><a class="anchor" id="autotoc_md55"></a>
autotoc_md55</h1>
<p><em> :+1: </em></p>
<h1><a class="anchor" id="autotoc_md56"></a>
systemverilog</h1>
<p><em> // file: foo_env_pkg.sv #define GET_FOO_TX_FIFO_DATA(baz) ...</em></p>
<p><em> ...</em></p>
<p><em> // Package sources #include "foo_env_cfg.sv" ... #include "foo_scoreboard.sv" #include "foo_env.sv"</em></p>
<p><em></p><pre class="fragment">    #undef GET_FOO_TX_FIFO_DATA
    // Good: Only the package sources can invoke this macro. It is not
             visible in any other code.
    ##
</pre><ol type="1">
<li><p class="startli">Wrap macros that resolve to multiple statements within { and }.</p>
<p class="startli">Multi-statement macros are typically problematic when invoked in a single line conditional expression without {..}. It is better to preempt this bug by wrapping the macro definition itself in {..}.</p>
<p class="startli">:-1: </p>
</li>
</ol>
<p></em></p>
<h1><a class="anchor" id="autotoc_md57"></a>
systemverilog</h1>
<p><em> #define UPDATE_VALUES(a, b) \ a = 88; \ b = 1955;</em></p>
<p><em> if (power_gw == 1.21) UPDATE_VALUES(speed, year) // Great Scott! The year is unconditionally set to 1955. </em></p>
<h1><a class="anchor" id="autotoc_md58"></a>
autotoc_md58</h1>
<p><em> :+1: </em></p>
<h1><a class="anchor" id="autotoc_md59"></a>
systemverilog</h1>
<p><em> #define UPDATE_VALUES(a, b) \ { \ a = 88; \ b = 1955; \ }</em></p>
<p><em> if (power_gw == 1.21) UPDATE_VALUES(speed, year) // Good: Both values are set only if the condition is met. </em></p>
<h1><a class="anchor" id="autotoc_md60"></a>
autotoc_md60</h1>
<p><em> Please see this <a href="https://www.veripool.org/papers/Preproc_Good_Evil_SNUGBos10_pres.pdf">paper</a> for more details and examples.</em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md61"></a>
Factory</h2>
<p><em> To use the UVM factory, these guidelines should be followed:</em></p>
<p><em></p><ol type="1">
<li>All classes must be registered with the factory. Use the uvm_object_utils and uvm_component_utils macros to register all non-parameterized classes, and use uvm_object_param_utils and uvm_component_param_utils to register all parameterized classes.</li>
<li>The create() API must be used to create all objects and components. Exceptions for this rule are any TLM related objects and covergroup objects, which should be created by directly calling new(), as they should not be registered with the factory.</li>
<li>When using the factory to create objects with &lt;type_name&gt;::type_id::create(), the &lt;type_name&gt; must be explicitly declared, parameters representing types must not be used here.</li>
<li>When using the factory to create objects, it is recommended to use the same name for both the name of the object and the variable used as a handle to the object to prevent unnecessary confusion from error messages.</li>
</ol>
<p></em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md62"></a>
systemverilog</h1>
<p><em> // create a single agent m_myblock_agent = myblock_agent::type_id::create("m_myblock_agent", this) { </em></p>
<h1><a class="anchor" id="autotoc_md63"></a>
autotoc_md63</h1>
<p><em></p><ol type="1">
<li>When using the factory to create an array of objects, decorate the name of the object in the create() call with the index of the object in the array.</li>
</ol>
<p></em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md64"></a>
systemverilog</h1>
<p><em> // create an array of objects foreach (myobject_array[i]) { myobject_array[i] = myobject::type_id::create($sformatf("myobject_array[%0d]", i), this); } </em></p>
<h1><a class="anchor" id="autotoc_md65"></a>
autotoc_md65</h1>
<p><em></p><ol type="1">
<li>For classes derived from uvm_component, the parent argument should be the keyword this, so that the object hierarchy can be built correctly.</li>
</ol>
<p></em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md66"></a>
systemverilog</h1>
<p><em> m_axi_driver = axi_driver::type_id::create("m_axi_driver", this); </em></p>
<h1><a class="anchor" id="autotoc_md67"></a>
autotoc_md67</h1>
<p><em></p><ol type="1">
<li>For classes derived from uvm_object, use gfn as part of the name argument to append the full hierachy name, since uvm_object hierarchies are not automatically built. Note that this only applies to class instances that are not instantiated within a uvm_component in the test hierarchy, as in this case the full hierarchy name will already be provided.</li>
</ol>
<p></em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md68"></a>
systemverilog</h1>
<p><em> m_my_txn = my_txn::type_id::create({gfn, ".m_my_txn"}) { public: </em></p>
<h1><a class="anchor" id="autotoc_md69"></a>
autotoc_md69</h1>
<p><em></p><ol type="1">
<li>All typename or instance overrides must be in place before creating the class instance. Factory usage examples:</li>
</ol>
<p></em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md70"></a>
systemverilog</h1>
<p><em> // Override all drivers in testbench with my_driver factory.set_type_override_by_type(current_driver::get_type(), my_driver::get_type()) { public:</em></p>
<p><em> // Override all drivers in testbench with my_driver - alternative syntax current_driver::type_id::set_type_override(my_driver::get_type());</em></p>
<p><em> // Override specific instance of current_driver with my_driver factory.set_inst_override_by_type("env1.m_agent1.driver", current_driver::get_type(), my_driver::get_type());</em></p>
<p><em> // Override specific instance of current driver - alternative syntax current_driver::type_id::set_inst_override(my_driver::get_type(), "env.m_agent1.driver"); </em></p>
<h1><a class="anchor" id="autotoc_md71"></a>
autotoc_md71</h1>
<p><em></em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md72"></a>
Configuration Mechanism</h2>
<p><em> When using the UVM configuration database, these guidelines should be followed:</em></p>
<p><em></p><ol type="1">
<li>The uvm_config_db API must be used. Do not use uvm_resource_db. Do not use set/get_config_object(), set/get_config_string(), or set/get_config_int(), these have been deprecated.</li>
<li>In general, a designated configuration object extended from uvm_object should be used for every uvm_env and uvm_agent component in the testbench.</li>
<li>It is recommended that the environments configuration object contain the agents configuration object.</li>
<li>The uvm_config_db API should be used to pass configuration objects to locations where they are needed. It should not be used to pass integers, strings, or other basic data types, since it is much easier for namespace collisions to occur when using lower level types.</li>
<li>Checks for success must always be performed when using the uvm_config_db. If the lookup fails, issue a uvm_fatal to terminate the simulation. This should be done as follows:</li>
</ol>
<p></em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md73"></a>
systemverilog</h1>
<p><em> if (!uvm_config_db &lt;...&gt; ::get(...)) { uvm_fatal(...) } </em></p>
<h1><a class="anchor" id="autotoc_md74"></a>
autotoc_md74</h1>
<p><em></p><ol type="1">
<li>Wildcards must not be used in the field argument of uvm_config_db::set(...) calls. It is allowed to use wildcards in the inst_name argument of these calls, with proper precautions.</li>
</ol>
<p></em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md75"></a>
Sequences</h2>
<p><em></p><ol type="1">
<li>It is recommended to keep sequences as generic as possible and to avoid writing directed sequences unless absolutely necessary.</li>
<li>It is recommended to avoid explicit delays in terms of absolute time to make code emulation friendly. Delays in terms of clock cycles are allowed.</li>
<li>The body() method should only execute the raw functional behavior of the sequence. Any associated housekeeping code should be placed elsewhere, such as in the pre_start() and post_start() methods.<ul>
<li>pre_start() and post_start() must be used instead of pre_body() and post_body(), as these will always be called, even for subsequences called from a parent sequence.</li>
</ul>
</li>
<li>When creating a sequence object, always randomize the sequence before starting it.</li>
<li>Virtual sequences must be used to coordinate the behavior of multiple agents and multiple sequences.</li>
<li>Virtual sequences must be started on the null sequencer or on a valid virtual sequencer.</li>
</ol>
<p></em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md76"></a>
Sequence Items</h2>
<p><em> It is recommended, but not necessary, to create small "unit tests" for transactions objects to ensure the randomization constraints are working as intended.</em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md77"></a>
RAL Usage</h2>
<p><em> When using the UVM RAL model, care must be taken when using uvm_reg::set() and uvm_reg::update(), as these are both non-atomic operations that can easily cause race conditions if there are any parallel threads.</em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md78"></a>
Objections and Coordinating End of Test</h2>
<p><em></em></p>
<p><em>As a general principle, a phase should not } when either there is more stimulus to send during that phase or the DUT has yet to respond to some stimulus that has been sent.</em></p>
<p><em>To prevent a phase from ending when there is more stimulus to send, a test class must raise and lower objections.</em></p>
<p><em>To prevent a phase from ending before the DUT has responded to some stimulus, classes derived from uvm_component should raise and lower objections in their phases_ready_to_end() method.</em></p>
<p><em>It is also recommended to only include objections in the monitor component. When using this approach, these guidelines should be followed:</em></p>
<p><em></p><ol type="1">
<li>The monitors phase_ready_to_end() method should implement a watchdog timer that raises an objection if any traffic is seen on the bus and lowers it once no traffic is seen within the timeout period. If traffic is seen, the watchdog resets its timer. Refer to the example below:</li>
</ol>
<p></em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md79"></a>
systemverilog</h1>
<p><em> // Example code for the monitor class. // This code assumes that the associated configuration object has an integer // property "ok_to_end_delay_ns", which gives the window timeout in // nanoseconds.</em></p>
<p><em>protected: bit ok_to_end = 0b1; bit watchdog_done = 0b0;</em></p>
<p><em> void phase_ready_to_end(uvm_phase phase) { if (phase.is(uvm_run_phase::get())) { if (watchdog_done) fork monitor_ready_to_end(); join_none if (!ok_to_end || !watchdog_done) { phase.raise_objection(this, $sformatf("%s objection raised", gfn)); fork { // wait until ok_to_end is set watchdog_ok_to_end(); phase.drop_objection(this, $sformatf("%s, objection dropped", gfn)); } join_none } }</em></p>
<p><em> } public: // This watchdog waits for ok_to_end_delay_ns nanoseconds while checking for // any traffic seen on the bus during this period. // If traffic is seen, the watchdog will restart until it sees no traffic. task watchdog_ok_to_end() { fork { bit watchdog_reset; fork forever { // check bus interface for traffic ; if (!ok_to_end &amp;&amp; !watchdog_reset) watchdog_reset = 1; } forever { &lt;cfg.ok_to_end_delay_ns * 1ns&gt; ; if (!watchdog_reset) { break; } else { watchdog_reset = 0; } } join_any; disable fork;</em></p>
<p><em> watchdog_done = 1; } join }</em></p>
<p><em> // This task is invoked as a non-blocking thread when phase_ready_to_end() // is first entered. // // This task should monitor the DUT's interface and control ok_to_end: it // should be cleared whenever there are any pending transactions and // set to 1 if there are no pending transactions. virtual task monitor_ready_to_end() { } </em></p>
<h1><a class="anchor" id="autotoc_md80"></a>
autotoc_md80</h1>
<p><em></p><ol type="1">
<li>It is recommended not to use other objections in the scoreboard; the scoreboard should just make use of information already available to it (like fifo size, etc...) to determine when it is ready to }, as the monitor has already guaranteed that no more traffic is seen on the bus. These fifo checks should be checked during its check_phase().</li>
</ol>
<p></em></p>
<p><em>The more general guidelines below should be followed when dealing with }-of-test timeouts or objections:</em></p>
<p><em></p><ol type="1">
<li>When calling raise_objection or drop_objection, a string must be passed as a second argument to describe the objection to help with debugging.</li>
</ol>
<p></em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md81"></a>
systemverilog</h1>
<p><em> phase.raise_objection(this, $sformatf("%s objection raised", gfn)); ... phase.drop_objection(this, $sformatf("%s objection dropped", gfn)); </em></p>
<h1><a class="anchor" id="autotoc_md82"></a>
autotoc_md82</h1>
<p><em></p><ol type="1">
<li>It is recommended to use the built-in UVM timeout mechanism, uvm_root::set_timeout(&lt;time_limit&gt;, 1). The base test in every testbench should specify a default timeout limit, which can be overridden by every derivative test. A standard plusarg +UVM_TIMEOUT=... is recommended to be used for this override mechanism.</li>
</ol>
<p></em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md83"></a>
Logging and Print Messages</h2>
<p><em></p><ol type="1">
<li>Print messages sent to the console should be kept to a minimum. Logs should be as concise as possible, by only writing key information when activity is present.</li>
<li>Whenever possible, log any data directly to log files instead of the console. It is recommended that only critical information/errors be sent to both the console and the log files.</li>
<li>Logging messages should be architected to be parsing "friendly"<ul>
<li>All related information should be kept on a single line.</li>
<li>Only the relevant data should be logged, for example, there is no need to log all fields of a transaction object when only a small subset is valid and relevant to the transaction being performed.</li>
<li>Log files should format lines consistently, starting with the simulation time that the logging event occurs, enabling easier post-processing.</li>
<li>The build in print() of uvm_object classes is not parsing "friendly", it is recommended not to use this .</li>
</ul>
</li>
<li>Do not use the uvm_report_* messaging functionality, or $display to print any messages. The uvm_{info/error/fatal} macros must be used instead.</li>
<li>Do not use the uvm_warning macro, use uvm_error or uvm_fatal instead.</li>
<li>The first argument to these report macros must be one of the gfn or gtn shorthand macros used in place of get_full_name() and get_type_name(). This will allow for easier debugging should something go wrong.</li>
<li>The UVM_NONE and UVM_FULL verbosity levels must not be used for any report messages. Recommended criteria for the choice of VERBOSITY value for uvm_info messages:<ul>
<li>UVM_LOW - important messages that occur a small number of times during a simulation.<ul>
<li>Instantiation of testbench components.</li>
<li>Reset assert/deassert, start/} of DUT initialization.</li>
<li>Start/} of traffic generation.</li>
</ul>
</li>
<li>UVM_MEDIUM - slightly more detailed messages.<ul>
<li>Contents of CSR fields during CSR transactions.</li>
<li>Reporting of significant events inside the DUT - fifo full, fifo empty, and so on.</li>
</ul>
</li>
<li>UVM_HIGH - Any information about DUT activity, reference model, and testbench that could be helpful for monitoring stimulation progress.<ul>
<li>Parsing/interpretation of fields in requests to the DUT and reference model.</li>
<li>Read/write operations to a memory model.</li>
<li>Status of transactions over SystemVerilog interfaces.</li>
<li>Values of data output by the DUT.</li>
</ul>
</li>
<li>UVM_DEBUG - Extremely specific information used for debugging failures.<ul>
<li>Any CSR exclusions.</li>
<li>Interface buses used to drive the /** */ .</li>
</ul>
</li>
</ul>
</li>
</ol>
<p></em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md84"></a>
DPI and C Connections</h2>
<p><em></p><ol type="1">
<li>DPI and native SystemVerilog calls have the same semantics and are thus indistinguishable. To preserve readability, a decorator must be added as such:<ul>
<li>Functions/tasks exported from SV to C must be prefixed with sv_dpi_.</li>
</ul>
</li>
</ol>
<p></em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md85"></a>
systemverilog</h1>
<p><em> </em></p>
<h1><a class="anchor" id="autotoc_md86"></a>
autotoc_md86</h1>
<p><em></p><ul>
<li>Functions imported from C to SV must be prefixed with c_dpi_.</li>
</ul>
<p></em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md87"></a>
systemverilog</h1>
<p><em> int c_dpi_adder(const int a, const int b); </em></p>
<h1><a class="anchor" id="autotoc_md88"></a>
autotoc_md88</h1>
<p><em></p><ol type="1">
<li>DPI usage is recommended in the following scenarios:<ul>
<li>Interfacing with C/C++ based reference models.</li>
<li>Usage of optimized C/C++ libraries.</li>
<li>Emulation.</li>
</ul>
</li>
<li>DPI usage is not recommended when the functionality can be handled natively in SV.</li>
<li>General DPI coding guidelines<ul>
<li>Do not cross the language boundary frequently.</li>
<li>If a SV-&gt;C call consumes time and the C routine is not thread safe, protect the call with a semaphore to avoid synchronization issues.</li>
<li>In general, pass only basic data types as arguments to DPI calls.</li>
</ul>
</li>
</ol>
<p></em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md89"></a>
SystemVerilog Language Features</h1>
<p><em> </em></p>
<h2><a class="anchor" id="autotoc_md90"></a>
Function Declarations</h2>
<p><em> Functions declared within packages, as well as any other static entities such as modules and interfaces, must be explicitly scoped with either the static or automatic keyword.</em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md91"></a>
Randomization</h2>
<p><em> Good constraint coding style is important for faster simulations and better simulation performance.</em></p>
<p><em></p><ol type="1">
<li>Give all constraints a name that matches with what is being constrained, and suffix the constraint name with _c.</li>
</ol>
<p></em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md92"></a>
systemverilog</h1>
<p><em> constraint num_packets_c() { num_packets &lt; 8; } </em></p>
<h1><a class="anchor" id="autotoc_md93"></a>
autotoc_md93</h1>
<p><em></p><ol type="1">
<li><p class="startli">Avoid using loops in constraints whenever possible. In some cases, foreach can be replaced by inside.</p>
<p class="startli">:-1: </p>
</li>
</ol>
<p></em></p>
<h1><a class="anchor" id="autotoc_md94"></a>
systemverilog</h1>
<p><em> constraint con_c() { foreach (data[i]) { a != data[i]; } } </em></p>
<h1><a class="anchor" id="autotoc_md95"></a>
autotoc_md95</h1>
<p><em> :+1: </em></p>
<h1><a class="anchor" id="autotoc_md96"></a>
systemverilog</h1>
<p><em> constraint con_c() { !(a inside {data}); } </em></p>
<h1><a class="anchor" id="autotoc_md97"></a>
autotoc_md97</h1>
<p><em></p><ol type="1">
<li>If using loops in constraints is necessary, avoid doing calculations inside the loops.</li>
<li>Whenever possible, use bitmasking operations over modulus operations, as bitmasking operations are much faster.</li>
<li>If a constraint becomes too complex, it is highly recommended to split the constraint and separately randomize all relevant variables.</li>
<li>When randomizing an array of objects, it is generally recommended to not directly randomize the array, but to iterate through it and directly randomize each object to see better simulation performance.</li>
</ol>
<p></em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md98"></a>
Enums</h2>
<p><em> Enum names should be written in lower_snake_case, and should include the block name for clarity. The enumerated values should be written in UpperCamelCase and should include the name of the enum for clarity.</em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md99"></a>
systemverilog</h1>
<p><em>typedef enum { UartInterruptFrameErr, UartInterruptRxBufferFull, ... } uart_interrupt_e; </em></p>
<h1><a class="anchor" id="autotoc_md100"></a>
autotoc_md100</h1>
<p><em></em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md101"></a>
Interfaces, Clocking Blocks, Modports</h2>
<p><em></p><ol type="1">
<li>Do not use the /** */ (.</li>
<li>Clocks and reset must be generated in SystemVerilog modules, interfaces, or in the UVM component hierarchy. Do not do this generation in uvm_object derived classes.</li>
<li>Use clocking blocks in a SystemVerilog /** */ synchronous DUT interfaces.</li>
<li>It is recommended to implement a reusable /** */ testbenches that will be included in integration/system level testbenches.</li>
</ol>
<p></em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md102"></a>
Loop Operators</h2>
<p><em> It is highly recommended to use foreach loops as often as possible over any equivalent loop operators, as they are much more concise and less prone to any subtle errors.</em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md103"></a>
Code Within Asserts</h2>
<p><em> For any randomization that is required, the macros specified in the <a href="#macro-usage">Randomization Macros section</a> must be used. Do not use assert() to check manual randomization calls, use the provided macros instead. More broadly, do not place any expression with side effects into an assert() statement.</em></p>
<p><em>:-1: </em></p>
<h1><a class="anchor" id="autotoc_md104"></a>
systemverilog</h1>
<p><em>// Do not assert the output of randomize() calls // 1. ret = item.randomize() with {&lt;constraints&gt;}) { assert(ret) { // 2. assert(randomize(&lt;variable&gt;) with {&lt;constraints&gt;}); // 3. assert(item.randomize() with {&lt;constraints&gt;}); // 4. assert(function_that_has_side_effects()); </em></p>
<h1><a class="anchor" id="autotoc_md105"></a>
autotoc_md105</h1>
<p><em> </em></p>
<h2><a class="anchor" id="autotoc_md106"></a>
Wait and Fork</h2>
<p><em> Always put wait fork and disable fork constructs inside of an isolation fork...join block to avoid erroneous waiting. It is recommended to use the DV_SPINWAIT macro whenever possible, <a href="#macro-usage">as described here</a>.</em></p>
<p><em>When disabling subprocesses, this may be done by using disable fork to terminate all processes or by disable thread_label to disable a specific thread. You may not use disable fork_label to disable all threads in a fork statement because there is inconsistent support for this among EDA tools. The use of disable fork_label is not compliant to the SystemVerilog-2017 standard (see Section 9.6.2 and 9.6.3 of the SV2017 LRM). Example code:</em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md107"></a>
autotoc_md107</h1>
<p><em>fork: fork_label { } ... join_any</em></p>
<p><em>// INCORRECT. disable fork_label; // Valid, but does not respect parent child process relationships. disable thread_label; // Kills all threads spawned by the parent thread, including the ones in the // past. disable fork; </em></p>
<h1><a class="anchor" id="autotoc_md108"></a>
autotoc_md108</h1>
<p><em> </em></p>
<h2><a class="anchor" id="autotoc_md109"></a>
Wait And Non-Forever Loop</h2>
<p><em> Always create a watchdog timer along with the wait statement or the non-forever loop. Recommend to use the following macros.</em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md110"></a>
systemverilog</h1>
<p><em>// This does <code>wait (condition);</code> with a default watchdog timer. <a class="el" href="dv__macros_8svh.html#a743f98785c4ba510e0a0dd2cc7a7b597">DV_WAIT(condition)</a> </em></p>
<h1><a class="anchor" id="autotoc_md111"></a>
autotoc_md111</h1>
<p><em> </em></p>
<h1><a class="anchor" id="autotoc_md112"></a>
systemverilog</h1>
<p><em>DV_SPINWAIT(while (condition) { ... }) </em></p>
<h1><a class="anchor" id="autotoc_md113"></a>
autotoc_md113</h1>
<p><em> </em></p>
<h2><a class="anchor" id="autotoc_md114"></a>
Void Casts</h2>
<p><em> Do not void cast any /task calls that have useful return values, EXCEPT the following:</p><ul>
<li>system functions.</li>
<li>RAL predict() calls.</li>
<li>fifo/queue methods.</li>
</ul>
<p></em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md115"></a>
Associative Arrays</h2>
<p><em> Do not use wildcard indexed [*] associative arrays. Always specify a particular index type.</em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md116"></a>
Bind Statements</h2>
<p><em> bind statements are the preferred approach for using assertion-based monitors. For these situations, using .* is allowed for making implicit port declarations when binding a /** */ .</em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md117"></a>
Simulator-specific Code</h2>
<p><em> Always wrap simulator-specific code inside preprocessor guards. The macro names VCS, INCA, XCELIUM are defined for the VCS, Incisive/NCsim/Irun, and Xcelium/xrun simulators respectively, these must be used to wrap relevant code, as shown below:</em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md118"></a>
systemverilog</h1>
<p><em>#ifdef VCS $stack() { #endif </em></p>
<h1><a class="anchor" id="autotoc_md119"></a>
autotoc_md119</h1>
<p><em></em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md120"></a>
Forbidden System Tasks and Functions</h2>
<p><em> Do not use the following system functions</em></p>
<p><em></p><ul>
<li>$psprintf, this is not in the SystemVerilog LRM. Use $sformatf instead.</li>
<li>$random and $dist_*, these functions are not part of the SystemVerilog random stability model and can break simulation reproducibility. Use $urandom or a randomization macro instead.</li>
<li>$srandom, this is not part of the SystemVerilog standard. Use process::self().srandom() instead.</li>
</ul>
<p></em></p>
<p><em></em></p>
<h2><a class="anchor" id="autotoc_md121"></a>
Backdoor Force and Probe in Chip-level</h2>
<p><em> Chip-level tests could be run in both RTL and gate sim. Since some signals may not be preserved in the same path after synthesis, we need follow these rules to use backdoor force or probe. This assumes gate-level netlist wont be flattened.</em></p>
<p><em></p><ul>
<li>Reference /** */ / , / preserved in non-flattened netlist.</li>
<li>Reference logic if possible. If that is not possible, structs are likely converted to a giant vector. We can cast that vector to the struct and thus still access the individual members.</li>
<li>Do not reference internal nets, as those will likely not be preserved. If we really need to do so, they should be placed in an anchored buffer, in order to preserve the path.</li>
<li>Do not reference to internal clocks/resets, as they may not be preserved, even if the clocks/resets are in the /** */ /. , .</li>
<li>CSR hierarchies are likely to be preserved, so CSR backdoor access will still work.</li>
</ul>
<p></em></p>
<p><em></em></p>
<h1><a class="anchor" id="autotoc_md122"></a>
SystemVerilog Assertions</h1>
<p><em> Most, if not all design properties are captured as in-line assertions within the RTL itself. The guidance on usage and implementation of assertions can be found in the adjoining <a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#assertion-macros">lowRISC Verilog style guide</a>.</em></p>
<p><em>In some cases, it may be useful to capture specific design behaviors and their expected outcomes as assertion checks, rather than checks in the scoreboard, or other UVM testbench components. Such properties may reference internal RTL signals at the same or different hierarchies. They may be too complex to embed within the RTL itself. So, they may instead be captured in a separate SystemVerilog assertion (SVA) module.</em></p>
<p><em>The following guidelines help maximize the reuse of these SVA modules horizontally (an IP design is enhanced externally, and thus, has an extended testbench that reuses heavily from the original testbench) and vertically (an IP instantiated in a larger design, such as an SoC).</em></p>
<p><em></p><ol type="1">
<li>The SVA /** */ . checkers, they must not drive or force internal signals. Doing so may lead to confusion and increase the debug overhead.</li>
</ol>
<ol type="1">
<li><p class="startli">Use the <a href="https://github.com/lowRISC/opentitan/blob/master/hw/ip/prim/rtl/prim_assert.sv">assertion macros</a>.</p>
<p class="startli">:-1: </p>
</li>
</ol>
<p></em></p>
<h1><a class="anchor" id="autotoc_md123"></a>
systemverilog</h1>
<p><em> // Manually typing the complete assertion statement is tedious and error- // prone. OneHotCheck_A: assert property((@posedge clk) disable iff (!rst_n) valid |=&gt; $onehot(data)) { else $error(...) { </em></p>
<h1><a class="anchor" id="autotoc_md124"></a>
autotoc_md124</h1>
<p><em> :+1: </em></p>
<h1><a class="anchor" id="autotoc_md125"></a>
systemverilog</h1>
<p><em> // Assertion macros are concise and hide some extra functionalities // underneath. ASSERT(OneHotCheck_A, valid |=&gt; $onehot(data)) </em></p>
<h1><a class="anchor" id="autotoc_md126"></a>
autotoc_md126</h1>
<p><em></p><ol type="1">
<li><p class="startli">Do not instantiate the SVA /** */ . , the RTL /** */ . is bound to the RTL module, an instance of the SVA /** */ underneath all instances of the RTL module.</p>
<p class="startli">:-1: </p>
</li>
</ol>
<p></em></p>
<h1><a class="anchor" id="autotoc_md127"></a>
systemverilog</h1>
<p><em> // Instantiating the SVA module in the testbench forces the user to use // absolute hierarchical paths to signals within the assertion properties // in the SVA module. This hampers reuse, since those paths may not exist // in other testbenches. sva_module_for_aes_core u_sva_module_for_aes_core(.clk(...), ...) { </em></p>
<h1><a class="anchor" id="autotoc_md128"></a>
autotoc_md128</h1>
<p><em> :+1: </em></p>
<h1><a class="anchor" id="autotoc_md129"></a>
systemverilog</h1>
<p><em> // Bind the SVA module to the RTL module directly. All instances of // <code>aes_core</code> in the design will benefit from the SVA checks. The SVA // module can also be reused in other testbenches, which may contain // additional instances of this RTL module elsewhere in the design. bind aes_core sva_module_for_aes_core u_sva_module_for_aes_core(.clk(...), ...); </em></p>
<h1><a class="anchor" id="autotoc_md130"></a>
autotoc_md130</h1>
<p><em></p><ol type="1">
<li><p class="startli">Do not use absolute hierarchical paths to signals in the SVA modules (the previous bullet explains why). The bind enables cross /** */ signals in the RTL /** */ the SVA module.</p>
<p class="startli">:-1: </p>
</li>
</ol>
<p></em></p>
<h1><a class="anchor" id="autotoc_md131"></a>
systemverilog</h1>
<p><em> // Path tb.dut.u_aes.u_aes_core.u_foo does not exist in other // testbenches. This module is not reusable in other testbenches. ASSERT(CheckProp_A, valid |=&gt; $onehot(tb.dut.u_aes.u_aes_core.u_bar.u_baz.u_quux.data_q)) ASSERT(CheckProp_A, tb.dut.u_aes.u_aes_core.u_foo.state_q == Idle |=&gt; AES_CORE_BAR_HIER.u_baz.u_quux.data_q == 0) </em></p>
<h1><a class="anchor" id="autotoc_md132"></a>
autotoc_md132</h1>
<p><em> :+1: </em></p>
<h1><a class="anchor" id="autotoc_md133"></a>
systemverilog</h1>
<p><em> // Binding the SVA module to <code>aes_core</code> obviates the need to specify the // absolute hierarchical paths to internal signals. Cross module // reference with partial paths is sufficient. This SVA module can now be // reused in the other testbenches. ASSERT(CheckProp_A, valid |=&gt; $onehot(u_bar.u_baz.u_quux.data_q)) ASSERT(CheckOtherProp_A, u_foo.state_q == Idle |=&gt; u_bar.u_baz.u_quux.data_q == 0) </em></p>
<h1><a class="anchor" id="autotoc_md134"></a>
autotoc_md134</h1>
<p><em></p><ol type="1">
<li>If the assertions reference signals at different sub-hierarchies, then bind the SVA /** */ . examples, that would be the aes_core module.</li>
</ol>
<ol type="1">
<li><p class="startli">Consolidate all SVA binds in a dedicated bindfile. The bind invocations are placed in a dedicated SystemVerilog module, called the 0bindfile. Bindfiles are treated as entities that are separate from the testbench module. They are passed to the simulator as one of the top level modules for elaboration. The bindfiles themselves, can be reused in other testbenches, by simply passing them as a top level entity to the simulator in those other testbenches as well.</p>
<p class="startli">:-1: </p>
</li>
</ol>
<p></em></p>
<h1><a class="anchor" id="autotoc_md135"></a>
systemverilog</h1>
<p><em> // The testbench module which instantiates the design under test (DUT). /** */ () {</em></p>
<p><em> // This module is considered 'unreusable'. The <code>bind</code> invocations below // must hence be replicated in other testbenches where the SVA module can // be reused. bind aes_core sva_module_for_aes_core u_sva_module_for_aes_core(.clk(...), ...);</em></p>
<p><em> } </em></p>
<h1><a class="anchor" id="autotoc_md136"></a>
autotoc_md136</h1>
<p><em> :+1: </em></p>
<h1><a class="anchor" id="autotoc_md137"></a>
systemverilog</h1>
<p><em> // A dedicated bindfile for all AES assertions. /** */ () {</em></p>
<p><em> // This module is reusable in other testbenches. The <code>bind</code> invocations // need not be replicated in other testbenches. bind aes_core sva_module_for_aes_core u_sva_module_for_aes_core(.clk(...), ...);</em></p>
<p><em> } </em></p>
<h1><a class="anchor" id="autotoc_md138"></a>
autotoc_md138</h1>
<p><em></p><ol type="1">
<li><p class="startli">Bind SVA modules to RTL modules and not to specific instances of the RTL module. Binding the SVA /** */ , issues - other testbenches may have additional instances of the RTL /** */ elsewhere in the design, which will miss out on the SVA checks. If there is a strong justifiable reason to bind the SVA /** */ , then refrain from specifying the absolute hierarchical path to the instance. Instead, use the bind &lt;module_name&gt;: &lt;instance_name&gt; notation.</p>
<p class="startli">:-1: </p>
</li>
</ol>
<p></em></p>
<h1><a class="anchor" id="autotoc_md139"></a>
systemverilog</h1>
<p><em> // This bindfile is not reusable in other testbenches, because the <code>bind</code> // is applied to an instance with absolute hierarchical path, which may // not exist in other testbenches. bind tb.dut.u_aes.u_aes_core sva_module_for_aes_core u_sva_module_for_aes_core(.clk(...), ...) { </em></p>
<h1><a class="anchor" id="autotoc_md140"></a>
autotoc_md140</h1>
<p><em> :-1: </em></p>
<h1><a class="anchor" id="autotoc_md141"></a>
systemverilog</h1>
<p><em> // SVA module is only bound to <code>u_aes_core</code> instance of <code>aes_core</code>. This // bindfile is reusable in other testbenches. But note that only the // <code>aes_core</code> instance named <code>u_aes_core</code> will receive the SVA checks. // Discouraged, but fine reusablility-wise. bind aes_core: u_aes_core sva_module_for_aes_core u_sva_module_for_aes_core(.clk(...), ...); </em></p>
<h1><a class="anchor" id="autotoc_md142"></a>
autotoc_md142</h1>
<p><em> :+1: </em></p>
<h1><a class="anchor" id="autotoc_md143"></a>
systemverilog</h1>
<p><em> // This bindfile is reusable in other testbenches. bind aes_core sva_module_for_aes_core u_sva_module_for_aes_core(.clk(...), ...); </em></p>
<h1><a class="anchor" id="autotoc_md144"></a>
autotoc_md144</h1>
<p><em> /** </em></p>
</div>

<h3><a id="md_docs_style_guides_VerilogCodingStyle"></a>lowRISC Verilog Coding Style Guide</h3><div class="textblock"><h1><a class="anchor" id="autotoc_md147"></a>
Basics</h1>
<h2><a class="anchor" id="autotoc_md148"></a>
Summary</h2>
<p>Verilog is the main logic design language for lowRISC Comportable IP.</p>
<p>Verilog and SystemVerilog (often generically referred to as just "Verilog" in this document) can be written in vastly different styles, which can lead to code conflicts and code review latency. This style guide aims to promote Verilog readability across groups. To quote the <a href="https://google.github.io/styleguide/cppguide.html">Google C++ style guide</a>: "Creating common, required idioms and patterns makes code much easier to
understand."</p>
<p>This guide defines the Comportable style for Verilog. The goals are to:</p>
<ul>
<li>promote consistency across hardware development projects</li>
<li>promote best practices</li>
<li>increase code sharing and re-use</li>
</ul>
<p>This style guide defines style for both Verilog-2001 and SystemVerilog compliant code. Additionally, this style guide defines style for both synthesizable and test bench code.</p>
<p>See the <a href="#appendix---condensed-style-guide">Appendix</a> for a condensed tabular representation of this style guide.</p>
<p><b>Table of Contents</b></p>
<ul>
<li><a href="#lowrisc-verilog-coding-style-guide">lowRISC Verilog Coding Style Guide</a><ul>
<li><a href="#basics">Basics</a><ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#terminology-conventions">Terminology Conventions</a></li>
<li><a href="#default-to-c-like-formatting">Default to C-like Formatting</a></li>
<li><a href="#style-guide-exceptions">Style Guide Exceptions</a></li>
<li><a href="#which-verilog-to-use">Which Verilog to Use</a></li>
</ul>
</li>
<li><a href="#verilogsystemverilog-conventions">Verilog/SystemVerilog Conventions</a><ul>
<li><a href="#summary-1">Summary</a></li>
<li><a href="#file-extensions">File Extensions</a></li>
<li><a href="#general-file-appearance">General File Appearance</a><ul>
<li><a href="#characters">Characters</a></li>
<li><a href="#posix-file-endings">POSIX File Endings</a></li>
<li><a href="#line-length">Line Length</a></li>
<li><a href="#no-tabs">No Tabs</a></li>
<li><a href="#no-trailing-spaces">No Trailing Spaces</a></li>
</ul>
</li>
<li><a href="#{--}">Begin / End</a></li>
<li><a href="#indentation">Indentation</a><ul>
<li><a href="#indented-sections">Indented Sections</a></li>
<li><a href="#line-wrapping">Line Wrapping</a></li>
<li><a href="#preprocessor-directives">Preprocessor Directives</a></li>
</ul>
</li>
<li><a href="#spacing">Spacing</a><ul>
<li><a href="#comma-delimited-lists">Comma-delimited Lists</a></li>
<li><a href="#tabular-alignment">Tabular Alignment</a></li>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#array-dimensions-in-declarations">Array Dimensions in Declarations</a></li>
<li><a href="#parameterized-types">Parameterized Types</a></li>
<li><a href="#labels">Labels</a></li>
<li><a href="#case -items">Case items</a> {</li>
<li><a href="#-and-task-calls">Function And Task Calls</a></li>
<li><a href="#macro-calls">Macro Calls</a></li>
<li><a href="#line-continuation">Line Continuation</a></li>
<li><a href="#space-around-keywords">Space Around Keywords</a></li>
</ul>
</li>
<li><a href="#parentheses">Parentheses</a><ul>
<li><a href="#ternary-expressions">Ternary Expressions</a></li>
</ul>
</li>
<li><a href="#comments">Comments</a></li>
<li><a href="#declarations">Declarations</a></li>
<li><a href="#basic-template">Basic Template</a></li>
</ul>
</li>
<li><a href="#naming">Naming</a><ul>
<li><a href="#summary-2">Summary</a></li>
<li><a href="#constants">Constants</a><ul>
<li><a href="#parameterized-objects-modules-etc">Parameterized Objects (modules, etc.)</a></li>
</ul>
</li>
<li><a href="#macro-definitions">Macro Definitions</a></li>
<li><a href="#suffixes">Suffixes</a></li>
<li><a href="#enumerations">Enumerations</a></li>
<li><a href="#signal-naming">Signal Naming</a><ul>
<li><a href="#use-descriptive-names">Use descriptive names</a></li>
<li><a href="#prefixes">Prefixes</a></li>
<li><a href="#hierarchical-consistency">Hierarchical consistency</a></li>
</ul>
</li>
<li><a href="#clocks">Clocks</a></li>
<li><a href="#resets">Resets</a></li>
</ul>
</li>
<li><a href="#language-features">Language Features</a><ul>
<li><a href="#preferred-systemverilog-constructs">Preferred SystemVerilog Constructs</a></li>
<li><a href="#package-dependencies">Package Dependencies</a></li>
<li><a href="#module-declaration">Module Declaration</a></li>
<li><a href="#module-instantiation">Module Instantiation</a></li>
<li><a href="#constants-1">Constants</a></li>
<li><a href="#signal-widths">Signal Widths</a><ul>
<li><a href="#always-be-explicit-about-the-widths-of-number-literals">Always be explicit about the widths of number literals.</a></li>
<li><a href="#port-connections-on-module-instances-must-always-match-widths-correctly">Port connections on /** */ .&lt;/&gt;&gt;Do not use multi-bit signals in a boolean context.</a></li>
<li><a href="#bit-slicing">Bit Slicing</a></li>
<li><a href="#handling-width-overflow">Handling Width Overflow</a></li>
</ul>
</li>
<li><a href="#blocking-and-non-blocking-assignments">Blocking and Non-blocking Assignments</a></li>
<li><a href="#delay-modeling">Delay Modeling</a></li>
<li><a href="#sequential-logic-latches">Sequential Logic (Latches)</a></li>
<li><a href="#sequential-logic-registers">Sequential Logic (Registers)</a></li>
<li><a href="#dont-cares-xs">Dont Cares (Xs)</a><ul>
<li><a href="#catching-errors-where-invalid-values-are-consumed">Catching errors where invalid values are consumed</a></li>
<li><a href="#specific-guidance-on-case -statements-and-ternaries">Specific Guidance on Case Statements and Ternaries</a> {</li>
<li><a href="#dynamic-array-indexing">Dynamic Array Indexing</a></li>
</ul>
</li>
<li><a href="#combinational-logic">Combinational Logic</a></li>
<li><a href="#case -statements">Case Statements</a> {<ul>
<li><a href="#wildcards-in-case-items">Wildcards in case items</a> {</li>
</ul>
</li>
<li><a href="#generate-constructs">Generate Constructs</a></li>
<li><a href="#signed-arithmetic">Signed Arithmetic</a></li>
<li><a href="#number-formatting">Number Formatting</a></li>
<li><a href="#functions-and-tasks">Functions and Tasks</a></li>
<li><a href="#problematic-language-features-and-constructs">Problematic Language Features and Constructs</a><ul>
<li><a href="#floating-begin-end-blocks">Floating {-} blocks</a></li>
<li><a href="#hierarchical-references">Hierarchical references</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#design-conventions">Design Conventions</a><ul>
<li><a href="#summary-3">Summary</a></li>
<li><a href="#declare-all-signals">Declare all signals</a></li>
<li><a href="#use-logic-for-synthesis">Use logic for synthesis</a></li>
<li><a href="#logical-vs-bitwise">Logical vs. Bitwise</a></li>
<li><a href="#packed-ordering">Packed Ordering</a></li>
<li><a href="#unpacked-ordering">Unpacked Ordering</a></li>
<li><a href="#finite-state-machines">Finite State Machines</a></li>
<li><a href="#active-low-signals">Active-Low Signals</a></li>
<li><a href="#differential-pairs">Differential Pairs</a></li>
<li><a href="#delays">Delays</a></li>
<li><a href="#wildcard-import-of-packages">Wildcard import of packages</a></li>
<li><a href="#assertion-macros">Assertion Macros</a><ul>
<li><a href="#a-note-on-security-critical-applications">A Note on Security Critical Applications</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendix---condensed-style-guide">Appendix - Condensed Style Guide</a><ul>
<li><a href="#basic-style-elements">Basic Style Elements</a></li>
<li><a href="#construct-naming">Construct Naming</a></li>
<li><a href="#suffixes-for-signals-and-types">Suffixes for signals and types</a></li>
<li><a href="#language-features-1">Language features</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md149"></a>
Terminology Conventions</h2>
<p>Unless otherwise noted, the following terminology conventions apply to this style guide:</p>
<ul>
<li>The word <em><b>must</b></em> indicates a mandatory requirement. Similarly, <em><b>do not</b></em> indicates a prohibition. Imperative and declarative statements correspond to <em><b>must</b></em>.</li>
<li>The word <em><b>recommended</b></em> indicates that a certain course of action is preferred or is most suitable. Similarly, <em><b>not recommended</b></em> indicates that a course of action is unsuitable, but not prohibited. There may be reasons to use other options, but the implications and reasons for doing so must be fully understood.</li>
<li>The word <em><b>may</b></em> indicates a course of action is permitted and optional.</li>
<li>The word <em><b>can</b></em> indicates a course of action is possible given material, physical, or causal constraints.</li>
</ul>
<h2><a class="anchor" id="autotoc_md150"></a>
Default to C-like Formatting</h2>
<p><em><b>Where appropriate, format code consistent with <a href="https://google.github.io/styleguide/cppguide.html">https://google.github.io/styleguide/cppguide.html</a></b></em></p>
<p>Verilog is a C-like language, and where appropriate, we default to being consistent with <a href="https://google.github.io/styleguide/cppguide.html">Googles C++ Style Guide</a>.</p>
<p>In particular, we inherit these specific formatting guidelines:</p>
<ul>
<li>Generally, <a href="#naming">names</a> should be descriptive and avoid abbreviations.</li>
<li>Non-ASCII characters are forbidden.</li>
<li>Indentation uses spaces, no tabs. Indentation is two spaces for nesting, four spaces for line continuation.</li>
<li>Place a space between if and the parenthesis in <a href="https://google.github.io/styleguide/cppguide.html#Conditionals">conditional expressions</a>.</li>
<li>Use horizontal whitespace around operators, and avoid trailing whitespace at the } of lines.</li>
<li>Maintain consistent and good <a href="https://google.github.io/styleguide/cppguide.html#Punctuation,_Spelling_and_Grammar">punctuation, spelling, and grammar</a> (within comments).</li>
<li>Use standard formatting for <a href="#comments">comments</a>, including C-like formatting for <a href="https://google.github.io/styleguide/cppguide.html#TODO_Comments">TODO</a> and <a href="https://google.github.io/styleguide/cppguide.html#Deprecation_Comments">deprecation</a>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md151"></a>
Style Guide Exceptions</h2>
<p><em><b>Justify all exceptions with a comment.</b></em></p>
<p>No style guide is perfect. There are times when the best path to a working design, or for working around a tool issue, is to simply cut the Gordian Knot and create code that is at variance with this style guide. It is always okay to deviate from the style guide by necessity, as long as that necessity is clearly justified by a brief comment, as well as a lint waiver pragma where appropriate.</p>
<h2><a class="anchor" id="autotoc_md152"></a>
Which Verilog to Use</h2>
<p><em><b>Prefer SystemVerilog-2017.</b></em></p>
<p>All RTL and tests should be developed in SystemVerilog, following the <a href="https://ieeexplore.ieee.org/document/8299595">IEEE 1800-2017 (SystemVerilog-2017) standard</a>, except for <a href="#problematic-language-features-and-constructs">prohibited features</a>.</p>
<p>The standards document is available free of cost through <a href="https://ieeexplore.ieee.org/browse/standards/get-program/page/series?id=80">IEEE GET</a> (a registration is required).</p>
<h1><a class="anchor" id="autotoc_md153"></a>
Verilog/SystemVerilog Conventions</h1>
<h2><a class="anchor" id="autotoc_md154"></a>
Summary</h2>
<p>This section addresses primarily aesthetic aspects of style: line length, indentation, spacing, etc.</p>
<h2><a class="anchor" id="autotoc_md155"></a>
File Extensions</h2>
<p><em><b>Use the .sv extension for SystemVerilog files (or .svh for files that are included via the preprocessor).</b></em></p>
<p>File extensions have the following meanings:</p>
<ul>
<li>.sv indicates a SystemVerilog file defining a /** */ .</li>
<li>.svh indicates a SystemVerilog header file intended to be included in another file using a preprocessor include directive.</li>
<li>.v indicates a Verilog-2001 file defining a /** */ .</li>
<li>.vh indicates a Verilog-2001 header file.</li>
</ul>
<p>Only .sv and .v files are intended to be compilation units. .svh and .vh files may only be include-ed into other files.</p>
<p>With exceptions of netlist files, each .sv or .v file should contain only one module, and the name should be associated. For instance, file foo.sv should contain only the /** */ .</p>
<h2><a class="anchor" id="autotoc_md156"></a>
General File Appearance</h2>
<h3><a class="anchor" id="autotoc_md157"></a>
Characters</h3>
<p>***Use only ASCII characters with UNIX-style line endings("\n").***</p>
<h3><a class="anchor" id="autotoc_md158"></a>
POSIX File Endings</h3>
<p>***All lines on non-empty files must } with a newline ("\n").***</p>
<h3><a class="anchor" id="autotoc_md159"></a>
Line Length</h3>
<p><em><b>Wrap the code at 100 characters per line.</b></em></p>
<p>The maximum line length for style-compliant Verilog code is 100 characters per line.</p>
<p>Exceptions:</p>
<ul>
<li>Any place where line wraps are impossible (for example, an include path might extend past 100 characters).</li>
</ul>
<p><a href="#line-wrapping">Line-wrapping</a> contains additional guidelines on how to wrap long lines.</p>
<h3><a class="anchor" id="autotoc_md160"></a>
No Tabs</h3>
<p><em><b>Do not use tabs anywhere.</b></em></p>
<p>Use spaces to indent or align text. See <a href="#indentation">Indentation</a> for rules about indentation and wrapping.</p>
<p>To convert tabs to spaces on any file, you can use the <a href="http://linux.die.net/man/1/expand">UNIX expand</a> utility.</p>
<h3><a class="anchor" id="autotoc_md161"></a>
No Trailing Spaces</h3>
<p><em><b>Delete trailing whitespace at the } of lines.</b></em></p>
<h2><a class="anchor" id="autotoc_md162"></a>
Begin / End</h2>
<p><em><b>Use { and } unless the whole statement fits on a single line.</b></em></p>
<p>If a statement wraps at a block boundary, it must use { and }. Only if a whole semicolon-terminated statement fits on a single line can { and } be omitted.</p>
<p>&amp;#x1f44d() { </p>
<h1><a class="anchor" id="autotoc_md163"></a>
systemverilog {.good}</h1>
<p>// Wrapped procedural block requires begin and end. always_ff @(posedge clk) { q &lt;= d() { } </p>
<h1><a class="anchor" id="autotoc_md164"></a>
autotoc_md164</h1>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md165"></a>
systemverilog {.good}</h1>
<p>// The exception case, where begin and end may be omitted as the entire // structure fits on a single line. always_ff @(posedge clk) q &lt;= d; </p>
<h1><a class="anchor" id="autotoc_md166"></a>
autotoc_md166</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md167"></a>
systemverilog {.bad}</h1>
<p>// Incorrect because a wrapped statement must have begin and end. always_ff @(posedge clk) q &lt;= d; </p>
<h1><a class="anchor" id="autotoc_md168"></a>
autotoc_md168</h1>
<p>{ must be on the same line as the preceding keyword, and ends the line. } must start a new line. end else { must be together on one line. The only exception is if } has a label, a following else should be on a new line.</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md169"></a>
systemverilog {.good}</h1>
<p>// "end else begin" are on the same line. if (condition) { foo = bar; } else { foo = bum; } </p>
<h1><a class="anchor" id="autotoc_md170"></a>
autotoc_md170</h1>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md171"></a>
systemverilog {.good}</h1>
<p>// begin/end are omitted because each semicolon-terminated statement fits on // a single line. if (condition) foo = bar; else foo = bum; </p>
<h1><a class="anchor" id="autotoc_md172"></a>
autotoc_md172</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md173"></a>
systemverilog {.bad}</h1>
<p>// Incorrect because "else" must be on the same line as "end". if (condition) { foo = bar; } else { foo = bum; } </p>
<h1><a class="anchor" id="autotoc_md174"></a>
autotoc_md174</h1>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md175"></a>
systemverilog {.good}</h1>
<p>// An exception is made for labeled blocks. if (condition) { foo = bar; } else { foo = bum; } </p>
<h1><a class="anchor" id="autotoc_md176"></a>
autotoc_md176</h1>
<p>The above style also applies to individual case items within a case statement. { and } may be omitted if the entire case item (the case expression and the associated statement) fits on a single line. Otherwise, use the { keyword on the same line as the case expression.</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md177"></a>
systemverilog {.good}</h1>
<p>// Consistent use of begin and end for each case item is good. unique case (state_q) { StIdle: { state_d = StA; } StA: { state_d = StB; } StB: { state_d = StIdle; foo = bar; } default: { state_d = StIdle; } } </p>
<h1><a class="anchor" id="autotoc_md178"></a>
autotoc_md178</h1>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md179"></a>
systemverilog {.good}</h1>
<p>// Case items that fit on a single line may omit begin and end. unique case (state_q) { StIdle: state_d = StA; StA: state_d = StB; StB: { state_d = StIdle; foo = bar; } default: state_d = StIdle; } </p>
<h1><a class="anchor" id="autotoc_md180"></a>
autotoc_md180</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md181"></a>
systemverilog {.bad}</h1>
<p>unique case (state_q) { StIdle: // These lines are incorrect because we should not wrap state_d = StA; // case items at a block boundary without using begin StA: // and end. Case items should fit on a single line, or state_d = StB; // else the procedural block must have begin and end. StB: { foo = bar; state_d = StIdle; } default: { state_d = StIdle; } } </p>
<h1><a class="anchor" id="autotoc_md182"></a>
autotoc_md182</h1>
<h2><a class="anchor" id="autotoc_md183"></a>
Indentation</h2>
<p><em><b>Indentation is two spaces per level.</b></em></p>
<p>Use spaces for indentation. Do not use tabs. You should set your editor to emit spaces when you hit the tab key.</p>
<h3><a class="anchor" id="autotoc_md184"></a>
Indented Sections</h3>
<p>Always add an additional level of indentation to the enclosed sections of all paired keywords. Examples of SystemVerilog keyword pairs: { / }, /** */ / }, / , / };, / }.</p>
<h3><a class="anchor" id="autotoc_md185"></a>
Line Wrapping</h3>
<p>When wrapping a long expression, indent the continued part of the expression by four spaces, like this:</p>
<p>&amp;#x1f44d() { </p>
<h1><a class="anchor" id="autotoc_md186"></a>
systemverilog {.good}</h1>
<p>assign zulu = enabled &amp;&amp; ( alpha &lt; bravo &amp;&amp; charlie &lt; delta ) {</p>
<p>assign addr = addr_gen_function_with_many_params( thing, other_thing, long_parameter_name, x, y, extra_param1, extra_param2 );</p>
<p>assign structure = { src: src, dest: dest, default: 0 }; </p>
<h1><a class="anchor" id="autotoc_md187"></a>
autotoc_md187</h1>
<p>Or, if it improves readability, align the continued part of the expression with a grouping open parenthesis or brace, like this:</p>
<p>:+1: </p>
<h1><a class="anchor" id="autotoc_md188"></a>
systemverilog {.good}</h1>
<p>assign zulu = enabled &amp;&amp; (alpha &lt; bravo &amp;&amp; charlie &lt; delta);</p>
<p>assign addr = addr_gen_function(thing, other_thing, long_parameter_name, x, y);</p>
<p>assign structure = {src: src, dest: dest, default: 0}; </p>
<h1><a class="anchor" id="autotoc_md189"></a>
autotoc_md189</h1>
<p>Operators in a wrapped expression can be placed at either the } or the beginning of each line, but this must be done consistently within a file.</p>
<p>Open syntax characters such as { or ( that } one line of a multi-line expression should be terminated with close characters (}, )) on their own line. Examples:</p>
<p>:+1: </p>
<h1><a class="anchor" id="autotoc_md190"></a>
systemverilog {.good}</h1>
<p>assign bus_concatenation = { bus_valid, bus_parity[8], bus_valid[63:0] };</p>
<p>inst_type inst_name1 ( .clk_i (clk), .data_valid_i(data_valid), .data_value_i(data_value), .data_ready_o(data_ready) ); </p>
<h1><a class="anchor" id="autotoc_md191"></a>
autotoc_md191</h1>
<h3><a class="anchor" id="autotoc_md192"></a>
Preprocessor Directives</h3>
<p><em><b>Keep branching preprocessor directives left-aligned and un-indented.</b></em></p>
<p>Keep branching preprocessor directives ( ifdef, ifndef, else, </p>
<h1><a class="anchor" id="autotoc_md193"></a>
elsif##, ## #endif##) aligned to the left, even if they are nested. Indent</h1>
<p>the conditional branches of text as if the preprocessor directives were absent. Non-branching preprocessor directives must follow the same indentation rules as the regular code.</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md194"></a>
systemverilog {.good}</h1>
<p>#ifdef FOO // #include "foo.sv"; // parameter bit A = 1; // normal indentation for the regular code #ifdef BAR // parameter bit A = 2; #else parameter bit A = 3; #endif #endif</p>
<h1><a class="anchor" id="autotoc_md195"></a>
autotoc_md195</h1>
<p>Un-indented branching preprocessor directives disrupt the flow of reading to emphasize that there is conditional text. Leaving conditional branch text un-indented will result in post-preprocessed text looking properly indented.</p>
<h2><a class="anchor" id="autotoc_md196"></a>
Spacing</h2>
<h3><a class="anchor" id="autotoc_md197"></a>
Comma-delimited Lists</h3>
<p><em><b>For multiple items on a line, one space must separate the comma and the next character.</b></em></p>
<p>Additional whitespace is allowed for readability.</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md198"></a>
systemverilog {.good}</h1>
<p>bus = {addr, parity, data}; a = myfunc(lorem, ipsum, dolor, sit, amet, consectetur, adipiscing, elit, rhoncus); mymodule mymodule(.a(a), .b(b)); </p>
<h1><a class="anchor" id="autotoc_md199"></a>
autotoc_md199</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md200"></a>
systemverilog {.bad}</h1>
<p>{parity,data} = bus; a = myfunc(a,b,c); mymodule mymodule(.a(a),.b(b)); </p>
<h1><a class="anchor" id="autotoc_md201"></a>
autotoc_md201</h1>
<h3><a class="anchor" id="autotoc_md202"></a>
Tabular Alignment</h3>
<p>Tabular alignment groups two or more similar lines so that the identical parts are directly above one another. This alignment makes it easy to see which characters are the same and which characters are different between lines.</p>
<p><em><b>The use of tabular alignment is generally encouraged.</b></em></p>
<p><em><b>The use of tabular alignment is required for some constructs as detailed in the corresponding subsection of this guide.</b></em></p>
<p>Constructs which require tabular alignment:</p>
<ul>
<li><a href="#module-instantiation">Port expressions in /** */ &lt;/&gt; Each block of code, separated by an empty line, is treated as separate "table". Use spaces, not tabs. For example: :+1: @section autotoc_md203 systemverilog logic &lt;7:0&gt; my_interface_data() { logic &lt;15:0&gt; my_interface_address; logic my_interface_enable; logic another_signal; logic &lt;7:0&gt; something_else; @section autotoc_md204 :+1: @section autotoc_md205 systemverilog mod u_mod ( .clk_i, .rst_ni, .sig_i (my_signal_in), .sig2_i (my_signal_out), // comment with no blank line maintains the block .in_same_block_i(my_signal_in), .sig3_i (something),  .in_another_block_i(my_signal_in), .sig4_i (something) ); @section autotoc_md206 @subsubsection autotoc_md207 Expressions <em><b>Include whitespace on both sides of all binary operators.</b></em> Use spaces around binary operators. Add sufficient whitespace to aid readability. For example: &amp;#x1f44d; @section autotoc_md208 systemverilog {.good} assign a = ((addr &amp; mask) == My_addr) ? b[1] : ~b[0]; // good @section autotoc_md209 is better than &amp;#x1f44e; @section autotoc_md210 systemverilog {.bad} assign a=((addr&amp;mask)==My_addr)?b[1]:~b[0]; // bad @section autotoc_md211 <b>Exception:</b> when declaring a bit vector, it is acceptable to use the compact notation. For example: &amp;#x1f44d; @section autotoc_md212 systemverilog {.good} wire &lt;WIDTH-1:0&gt; foo; // this is acceptable wire &lt;WIDTH - 1 : 0&gt; foo; // fine also, but not necessary @section autotoc_md213 When splitting alternation expressions into multiple lines, use a format that is similar to an equivalent if-then-else line. For example: &amp;#x1f44d; @section autotoc_md214 systemverilog {.good} assign a = ((addr &amp; mask) == MY_ADDRESS) ? matches_value : doesnt_match_value; @section autotoc_md215 @subsubsection autotoc_md216 Array Dimensions in Declarations Add a space around packed dimensions. Do not add a space:space: between identifier and unpacked dimensions.. between multiple dimensions. Applies to packed and unpacked arrays as well as dynamic arrays, associative arrays, and queues. &amp;#x1f44d; @section autotoc_md217 systemverilog {.good} logic &lt;7:0&gt; [4] data[128][2]; typedef logic &lt;31:0&gt; word_t; bit bit_array[512]; data_t some_array[]; data_t some_map[addr_t]; data_t some_q[$]; @section autotoc_md218 &amp;#x1f44e; @section autotoc_md219 systemverilog {.bad} // There must not be a space between dimensions. logic &lt;7:0&gt; [4] data[128] [2]; // There must be a space around packed dimensions. typedef logic &lt;31:0&gt; word_t; // There must not be a space between identifier and unpacked dimension. bit bit_array [512]; // Dynamic, associative, and queue "dimensions" are treated the same as unpacked // dimensions. There must not be a space. data_t some_array []; data_t some_map [addr_t]; data_t some_q [$]; @section autotoc_md220 @subsubsection autotoc_md221 Parameterized Types <em><b>Add one space before type parameters, except when the type is part of a qualified name.</b></em> A qualified name contains at least one scope :: operator connecting its segments. A space in a qualified name would break the continuity of a reference to one symbol, so it must not be added. Parameter lists must follow the space-after-comma</a> rule.</li>
</ul>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md222"></a>
systemverilog {.good}</h1>
<p>my_fifo &lt;.WIDTH(4), .DEPTH(2)&gt; my_fifo_nibble ...</p>
<p>class foo : public bar &lt;32, 8&gt; { public: // unqualified base class ... };</p>
<p>foo_h = my_class &lt;.X(1), .Y(0)&gt; ::type_id::create("foo_h"); // static method call</p>
<p>my_pkg::x_class &lt;8, 1&gt; bar; // package-qualified name </p>
<h1><a class="anchor" id="autotoc_md223"></a>
autotoc_md223</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md224"></a>
systemverilog {.bad}</h1>
<p>my_fifo &lt;.WIDTH(4), .DEPTH(2)&gt; my_fifo_2by4 ...</p>
<p>class foo : public bar &lt;32, 8&gt; { public: // unqualified base class ... };</p>
<p>foo_h = my_class &lt;.X(1), .Y(0)&gt; ::type_id::create("foo_h"); // static method call</p>
<p>my_pkg::x_class &lt;8, 1&gt; bar; // package-qualified name </p>
<h1><a class="anchor" id="autotoc_md225"></a>
autotoc_md225</h1>
<h3><a class="anchor" id="autotoc_md226"></a>
Labels</h3>
<p><em><b>When labeling code blocks, add one space before and after the colon.</b></em></p>
<p>For example:</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md227"></a>
systemverilog {.good}</h1>
<p>{ } </p>
<h1><a class="anchor" id="autotoc_md228"></a>
autotoc_md228</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md229"></a>
systemverilog {.bad}</h1>
<p>} // There must be a space before and after the colon. } // There must be a space before the colon. </p>
<h1><a class="anchor" id="autotoc_md230"></a>
autotoc_md230</h1>
<h3><a class="anchor" id="autotoc_md231"></a>
Case items</h3>
<p>There must be no whitespace before a case items colon; there must be at least one space after the case items colon.</p>
<p>The default case item must include a colon.</p>
<p>For example:</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md232"></a>
systemverilog {.good}</h1>
<p>unique case (my_state) { StInit: $display("Shall we begin"); StError: $display("Oh boy this is Bad"); default: { my_state = StInit; interrupt = 1; } } </p>
<h1><a class="anchor" id="autotoc_md233"></a>
autotoc_md233</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md234"></a>
systemverilog {.bad}</h1>
<p>unique case (0b1) { (my_state == StError) : interrupt = 1; // Excess whitespace before colon default:{ } // Missing space after colon } </p>
<h1><a class="anchor" id="autotoc_md235"></a>
autotoc_md235</h1>
<h3><a class="anchor" id="autotoc_md236"></a>
Function And Task Calls</h3>
<p><em><b>Function and task calls must not have any spaces between the name or task name and the open parenthesis.</b></em></p>
<p>For example:</p>
<p>&amp;#x1f44d() { </p>
<h1><a class="anchor" id="autotoc_md237"></a>
systemverilog {.good}</h1>
<p>process_packet(pkt); </p>
<h1><a class="anchor" id="autotoc_md238"></a>
autotoc_md238</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md239"></a>
systemverilog {.bad}</h1>
<p>process_packet (pkt); // There must not be a space before "(" </p>
<h1><a class="anchor" id="autotoc_md240"></a>
autotoc_md240</h1>
<h3><a class="anchor" id="autotoc_md241"></a>
Macro Calls</h3>
<p><em><b>Macro calls must not have any spaces between the macro name and the open parenthesis.</b></em></p>
<p>For example:</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md242"></a>
systemverilog {.good}</h1>
<p>uvm_error(ID, "you fail") ASSERT(name, a &amp; b, clk, rst) </p>
<h1><a class="anchor" id="autotoc_md243"></a>
autotoc_md243</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md244"></a>
systemverilog {.bad}</h1>
<p>uvm_error (ID, "you fail") // ASSERT (name, a &amp; b, clk, rst) </p>
<h1><a class="anchor" id="autotoc_md245"></a>
autotoc_md245</h1>
<h3><a class="anchor" id="autotoc_md246"></a>
Line Continuation</h3>
<p><em><b>It is mandatory to right-align line continuations.</b></em></p>
<p>Aligning line continuations (\ character) helps visually mark the } of a multi-line macro. The position of alignment only needs to be beyond the rightmost extent of a multi-line macro by at least one space, when a space does not split a token, but should not exceed the maximum line length.</p>
<h1><a class="anchor" id="autotoc_md247"></a>
systemverilog</h1>
<p>#define REALLY_LONG_MACRO(arg1, arg2, arg3) \ do_something(arg1); \ do_something_else(arg2); \ final_action(arg3); </p>
<h1><a class="anchor" id="autotoc_md248"></a>
autotoc_md248</h1>
<h3><a class="anchor" id="autotoc_md249"></a>
Space Around Keywords</h3>
<p><em><b>Include whitespace before and after SystemVerilog keywords.</b></em></p>
<p>Do not include a whitespace:</p>
<ul>
<li>before keywords that immediately follow a group opening, such as an open parenthesis.</li>
<li>before a keyword at the beginning of a line.</li>
<li>after a keyword at the } of a line.</li>
</ul>
<p>For example:</p>
<h1><a class="anchor" id="autotoc_md250"></a>
systemverilog</h1>
<p>// Normal indentation before if. Include a space after if. if (foo) { } // Include a space after always, but not before posedge. always_ff @(posedge clk) { } </p>
<h1><a class="anchor" id="autotoc_md251"></a>
autotoc_md251</h1>
<h2><a class="anchor" id="autotoc_md252"></a>
Parentheses</h2>
<p><em><b>Use parentheses to make operations unambiguous.</b></em></p>
<p>In any instance where a reasonable human would need to expend thought or refer to an operator precedence chart, use parentheses instead to make the order of operations unambiguous.</p>
<h3><a class="anchor" id="autotoc_md253"></a>
Ternary Expressions</h3>
<p><em><b>Ternary expressions nested in the true condition of another ternary expression must be enclosed in parentheses.</b></em></p>
<p>For example:</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md254"></a>
systemverilog {.good}</h1>
<p>assign foo = condition_a ? (condition_a_x ? x : y) : b; </p>
<h1><a class="anchor" id="autotoc_md255"></a>
autotoc_md255</h1>
<p>While the following nested ternary has only one meaning to the compiler, the meaning can be unclear and error-prone to humans:</p>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md256"></a>
systemverilog {.bad}</h1>
<p>assign foo = condition_a ? condition_a_x ? x : y : b; </p>
<h1><a class="anchor" id="autotoc_md257"></a>
autotoc_md257</h1>
<p><em><b>Parentheses may be omitted if the code formatting conveys the same information, for example when describing a priority mux.</b></em></p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md258"></a>
systemverilog {.good}</h1>
<p>assign foo = condition_a ? a : condition_b ? b : not_a_nor_b; </p>
<h1><a class="anchor" id="autotoc_md259"></a>
autotoc_md259</h1>
<h2><a class="anchor" id="autotoc_md260"></a>
Comments</h2>
<p>***C++ style comments (// foo`) are preferred. C style comments (/* bar */) can also be used.***</p>
<p>A comment on its own line describes the code that follows. A comment on a line with code describes that line of code.</p>
<p>For example:</p>
<h1><a class="anchor" id="autotoc_md261"></a>
systemverilog</h1>
<p>// This comment describes the following module. /** */ () { ... }</p>
<p>localparam bit ValBaz = 1; // This comment describes the item to the left. </p>
<h1><a class="anchor" id="autotoc_md262"></a>
autotoc_md262</h1>
<p>It can sometimes be useful to structure the code using header-style comments in order to separate different functional parts (like FSMs, the main datapath or registers) within a module. In that case, the preferred style is a single-line section name, framed with //` C++ style comments as follows:</p>
<h1><a class="anchor" id="autotoc_md263"></a>
systemverilog</h1>
<p>/** */ () {</p>
<p>//////////////// // Controller // //////////////// ...</p>
<p>/////////////////////// // Main ALU Datapath // /////////////////////// ...</p>
<p>} </p>
<h1><a class="anchor" id="autotoc_md264"></a>
autotoc_md264</h1>
<p>If the designer would like to use comments to mark the beginning/} of a particular section for better readability (e.g. in nested for loop blocks), the preferred way is to use a single-line comment with no extra delineators, as shown in the examples below.</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md265"></a>
systemverilog {.good}</h1>
<p>// begin: iterate over foobar for (...) { ... } // end: iterate over foobar </p>
<h1><a class="anchor" id="autotoc_md266"></a>
autotoc_md266</h1>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md267"></a>
systemverilog {.good}</h1>
<p>for (...) { // iterate over foobar ... } // iterate over foobar </p>
<h1><a class="anchor" id="autotoc_md268"></a>
autotoc_md268</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md269"></a>
systemverilog {.bad}</h1>
<p>//-----------------------&mdash; iterate over foobar ----------------------------&mdash; for (...) { ... } //-----------------------&mdash; iterate over foobar ----------------------------&mdash; </p>
<h1><a class="anchor" id="autotoc_md270"></a>
autotoc_md270</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md271"></a>
systemverilog {.bad}</h1>
<p>/////////////////////////////// // begin iterate over foobar // /////////////////////////////// for (...) { ... } /////////////////////////////// // end iterate over foobar // /////////////////////////////// </p>
<h1><a class="anchor" id="autotoc_md272"></a>
autotoc_md272</h1>
<h2><a class="anchor" id="autotoc_md273"></a>
Declarations</h2>
<p><em><b>Signals must be declared before they are used. This means that implicit net declarations must not be used.</b></em></p>
<p>Within modules, it is <b>recommended</b> that signals, types, enums, and localparams be declared close to their first use. This makes it easier for the reader to find the declaration and see the signal type.</p>
<h2><a class="anchor" id="autotoc_md274"></a>
Basic Template</h2>
<p><em><b>A template that demonstrates many of the items is given below.</b></em></p>
<p>Template:</p>
<h1><a class="anchor" id="autotoc_md275"></a>
systemverilog</h1>
<p>// Copyright lowRISC contributors. // Licensed under the Apache License, Version 2.0, see LICENSE for details. // SPDX-License-Identifier: Apache-2.0 // // One line description of the module</p>
<p>/** */ &lt; parameter Width = 80, parameter Height = 24 </p><blockquote class="doxtable">
<p>module my_module ( </p>
</blockquote>
<p>input clk_i, input rst_ni, input req_valid_i, input [Width-1:0] req_data_i, output req_ready_o, ... ) {</p>
<p>logic &lt;Width-1:0&gt; req_data_masked;</p>
<p>submodule u_submodule ( .clk_i, .rst_ni, .req_valid_i, .req_data_i (req_data_masked), .req_ready_o(req_ready), ... );</p>
<p>always_comb { req_data_masked = req_data_i; case (fsm_state_q) { ST_IDLE: { req_data_masked = req_data_i &amp; MASK_IDLE; ... }</p>
<p>...</p>
<p>} </p>
<h1><a class="anchor" id="autotoc_md276"></a>
autotoc_md276</h1>
<h1><a class="anchor" id="autotoc_md277"></a>
Naming</h1>
<h2><a class="anchor" id="autotoc_md278"></a>
Summary</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Construct   </th><th class="markdownTableHeadNone">Style    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Declarations (module, class, package, interface)   </td><td class="markdownTableBodyNone">lower_snake_case    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Instance names   </td><td class="markdownTableBodyNone">lower_snake_case    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Signals (nets and ports)   </td><td class="markdownTableBodyNone">lower_snake_case    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Variables, functions, tasks   </td><td class="markdownTableBodyNone">lower_snake_case    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Named code blocks   </td><td class="markdownTableBodyNone">lower_snake_case    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">\define macros   </td><td class="markdownTableBodyNone">ALL_CAPS    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Tunable parameters for parameterized modules, classes, and interfaces   </td><td class="markdownTableBodyNone">UpperCamelCase    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Constants   </td><td class="markdownTableBodyNone">ALL_CAPS or UpperCamelCase    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Enumeration types   </td><td class="markdownTableBodyNone">lower_snake_case_e    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Other typedef types   </td><td class="markdownTableBodyNone">lower_snake_case_t    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Enumerated value names   </td><td class="markdownTableBodyNone">UpperCamelCase   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md279"></a>
Constants</h2>
<p><em><b>Declare global constants using parameters in the project package file.</b></em></p>
<p>In this context, <b>constants</b> are distinct from tuneable parameters for objects such as parameterized modules, classes, etc.</p>
<p>Explicitly declare the type for constants.</p>
<p>When declaring a constant:</p>
<ul>
<li>within a package use parameter.</li>
<li>within a /** */ .</li>
</ul>
<p>The preferred method of defining constants is to declare a package and declare all constants as a parameter within that package. If the constants are to be used in only one file, it is acceptable to keep them defined within that file rather than a separate package.</p>
<p>Define project-wide constants in the projects main package.</p>
<p>Other packages may also be declared with their own parameter constants to facilitate the creation of IP that may be re-used across many projects.</p>
<p>The preferred naming convention for all immutable constants is to use ALL_CAPS, but there are times when the use of UpperCamelCase might be considered more natural.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Constant Type   </th><th class="markdownTableHeadNone">Style Preference   </th><th class="markdownTableHeadNone">Conversation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">\define   </td><td class="markdownTableBodyNone">ALL_CAPS   </td><td class="markdownTableBodyNone">Truly constant    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">/** */   </td><td class="markdownTableBodyNone">UpperCamelCase   </td><td class="markdownTableBodyNone">truly modifiable by instantiation, not constant    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">derived localparam   </td><td class="markdownTableBodyNone">UpperCamelCase   </td><td class="markdownTableBodyNone">while not modified directly, still tracks /** */    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tuneable localparam   </td><td class="markdownTableBodyNone">UpperCamelCase   </td><td class="markdownTableBodyNone">while not expected to change upon RTL version, is used by designer to explore the design space conveniently    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">true localparam constant   </td><td class="markdownTableBodyNone">ALL_CAPS   </td><td class="markdownTableBodyNone">Example localparam OP_JALR = 0xA0() {   </td></tr>
</table>
<p>| enum { OP_JALR = 0xA0 { public: | | enum { ST_IDLE, ST_FRAME_START, ST_DYN_INSTR_READ ..., typedef enum ... { StIdle, StFrameStart, StDynInstrRead.... A collection of arbitrary values, could be either convention. |</p>
<p>The units for a constant should be described in the symbol name, unless the constant is unitless or the units are "bits." For example, FooLengthBytes.</p>
<p>Example:</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md280"></a>
systemverilog {.good}</h1>
<p>// package-scope</p>
<p>parameter int unsigned NUM_CPU_CORES = 64; // reference elsewhere as my_pkg::NUM_CPU_CORES</p>
<h1><a class="anchor" id="autotoc_md281"></a>
autotoc_md281</h1>
<h3><a class="anchor" id="autotoc_md282"></a>
Parameterized Objects (modules, etc.)</h3>
<p><em><b>Use parameter to parameterize, and localparam to declare module-scoped constants. Within a package, use parameter.</b></em></p>
<p>You can create parameterized modules, classes, and interfaces to facilitate design re-use.</p>
<p>Use the keyword parameter within the /** */ /** */ instantiation. The preferred naming convention for all parameters is UpperCamelCase. Some projects may choose to use ALL_CAPS to differentiate tuneable parameters from constants.</p>
<p>Derived parameters within the /** */ . An example is shown below.</p>
<h1><a class="anchor" id="autotoc_md283"></a>
systemverilog</h1>
<p>/** */ &lt; parameter int Depth = 2048, // 8kB default localparam int Aw = $clog2(Depth) // derived parameter </p><blockquote class="doxtable">
<p>module modname ( </p>
</blockquote>
<p>... ) {</p>
<p>} </p>
<h1><a class="anchor" id="autotoc_md284"></a>
autotoc_md284</h1>
<h1><a class="anchor" id="autotoc_md285"></a>
#define## and defparam should never be used to parameterize a module.</h1>
<p>Use <a href="#constants">package parameters</a> to transmit global constants through a hierarchy instead of parameters. To declare a constant whose scope is internal to the particular SystemVerilog module, <a href="#constants">use localparam instead</a>.</p>
<p>Examples of when to use parameterized modules:</p>
<ul>
<li>When multiple instances of a /** */ , differentiated by a parameter.</li>
<li>As a means of specializing a /** */ .</li>
<li>As a means of documenting which global parameters are permitted to change within the module.</li>
</ul>
<p>Explicitly declare the type for parameters.</p>
<p>Use the type of the parameter to help constrain the legal range. E.g. int unsigned for general non-negative integer values, bit for boolean values. Any further restrictions on tuneable parameter values must be documented with assertions.</p>
<p>Tuneable parameter values should always have reasonable defaults.</p>
<p>For additional reading, see [New Verilog-2001 Techniques for Creating Parameterized Models](<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-884-complex-digital-systems-spring-2005/related-resources/parameter_models.pdf">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-884-complex-digital-systems-spring-2005/related-resources/parameter_models.pdf</a>).</p>
<h2><a class="anchor" id="autotoc_md286"></a>
Macro Definitions</h2>
<p><em><b>Macros should be ALL_CAPITALS with underscores.</b></em></p>
<p>Macros should be all capitals with underscores.</p>
<p>A <b>global define</b> is a tick-defined macro in a header file that is shared by all source files in a project. To reduce namespace collisions, global defines should be prefixed by the name of a group of related macros, followed by a pair of underscores:</p>
<h1><a class="anchor" id="autotoc_md287"></a>
systemverilog</h1>
<p>// The following two constants are in the FOO namespace of the // SN chip. #define SN_FOO__ALPHA_BETA 5 #define SN_FOO__GAMMA_OMEGA 6 </p>
<h1><a class="anchor" id="autotoc_md288"></a>
autotoc_md288</h1>
<p>private: A ** define** is a tick-defined macro that should only be used within the scope of a single file. It must be explicitly undefined after use, to avoid polluting the global macro namespace. To indicate that a macro is only meant to be used in the scope, the macro name should be prefixed with a single underscore.</p>
<p>To ensure that defines stay local, be careful not to include other files between the macro definition and undef.</p>
<p>Example:</p>
<h1><a class="anchor" id="autotoc_md289"></a>
systemverilog</h1>
<p>#define <em>MAKE_THING(_x) \ thing i_thing</em>##_x (.clk(clk), .i(i##_x) .o(o##_x)) { _MAKE_THING(a) _MAKE_THING(b) _MAKE_THING(c) #undef _MAKE_THING </p>
<h1><a class="anchor" id="autotoc_md290"></a>
autotoc_md290</h1>
<h2><a class="anchor" id="autotoc_md291"></a>
Suffixes</h2>
<p>Suffixes are used in several places to give guidance to intent. The following table lists the suffixes that have special meaning.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Suffix(es)   </th><th class="markdownTableHeadCenter">Arena   </th><th class="markdownTableHeadNone">Intent    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">_e   </td><td class="markdownTableBodyCenter">typedef   </td><td class="markdownTableBodyNone">Enumerated types    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">_t   </td><td class="markdownTableBodyCenter">typedef   </td><td class="markdownTableBodyNone">Other typedefs, including signal clusters    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">_n   </td><td class="markdownTableBodyCenter">signal name   </td><td class="markdownTableBodyNone">Active low signal    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">_n, _p   </td><td class="markdownTableBodyCenter">signal name   </td><td class="markdownTableBodyNone">Differential pair, active low and active high    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">_d, _q   </td><td class="markdownTableBodyCenter">signal name   </td><td class="markdownTableBodyNone">Input and output of register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">_q2,_q3, etc   </td><td class="markdownTableBodyCenter">signal name   </td><td class="markdownTableBodyNone">Pipelined versions of signals; _q is one cycle of latency, _q2 is two cycles, _q3 is three, etc    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">_i, _o, _io   </td><td class="markdownTableBodyCenter">signal name   </td><td class="markdownTableBodyNone">Module inputs, outputs, and bidirectionals   </td></tr>
</table>
<p>When multiple suffixes are necessary use the following guidelines:</p>
<ul>
<li>Guidance suffixes are added together and not separated by additional _ characters (_ni not _n_i)</li>
<li>If the signal is active low _n will be the first suffix</li>
<li>If the signal is a /** */ / .</li>
<li>It is not mandatory to propagate _d and _q to /** */ .</li>
</ul>
<p>Example:</p>
<p>&amp;#x1f44d() { </p>
<h1><a class="anchor" id="autotoc_md292"></a>
systemverilog {.good}</h1>
<p>/** */ ( input clk_i, input rst_ni, // Active low reset</p>
<p>// writer interface input [15:0] data_i, input valid_i, output ready_o,</p>
<p>// bi-directional bus inout [8] driver_io, // Bi directional signal</p>
<p>// Differential pair output output lvds_po, // Positive part of the differential signal output lvds_no // Negative part of the differential signal ) {</p>
<p>logic valid_d, valid_q, valid_q2, valid_q3; assign valid_d = valid_i; // next state assignment</p>
<p>always_ff @(posedge clk_i or negedge rst_ni) { if (!rst_ni) { valid_q &lt;= 0; valid_q2 &lt;= 0; valid_q3 &lt;= 0; } else { valid_q &lt;= valid_d; valid_q2 &lt;= valid_q; valid_q3 &lt;= valid_q2; } }</p>
<p>assign ready_o = valid_q3; // three clock cycles delay</p>
<p>} // simple </p>
<h1><a class="anchor" id="autotoc_md293"></a>
autotoc_md293</h1>
<h2><a class="anchor" id="autotoc_md294"></a>
Enumerations</h2>
<p><em><b>Name enumeration types snake_case_e. Name enumeration values ALL_CAPS or UpperCamelCase.</b></em></p>
<p>Always name enum types using typedef. The storage type of any enumerated type must be specified. For synthesizable enums, the storage type must be a 4-state data type (logic rather than bit).</p>
<p>Anonymous enum types are not allowed as they make it harder to use the type in other places throughout the project and across projects.</p>
<p>Enumeration type names should contain only lower-case alphanumeric characters and underscores. You must suffix enumeration type names with _e.</p>
<p>Enumeration value names (constants) should typically be ALL_CAPS, for example, READY_TO_SEND, to reflect their constant nature, especially for truly unchangeable values like defined opcode assignments. There are times when UpperCamelCase might be preferred, when the enumerated types assigned value is effectively a dont care to the designer, like state machine values. See the conversation on <a href="#constants">constants</a> for a discussion on how to think of this recommendation.</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md295"></a>
systemverilog {.good}</h1>
<p>typedef enum { // 8-bit opcodes OP_JALR = 0xA0, OP_ADDI = 0x47, OP_LDW = 0x0B } opcode_e; opcode_e op_val; </p>
<h1><a class="anchor" id="autotoc_md296"></a>
autotoc_md296</h1>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md297"></a>
systemverilog {.good}</h1>
<p>typedef enum { // A 2-bit enumerated type ACC_WRITE, ACC_READ, ACC_PAUSE } access_e; // new named type is created access_e req_access, resp_access; </p>
<h1><a class="anchor" id="autotoc_md298"></a>
autotoc_md298</h1>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md299"></a>
systemverilog {.good}</h1>
<p>typedef enum { // A 2-bit enumerated type AccWrite, AccRead, AccPause } access_e; // new named type is created access_e req_access, resp_access; </p>
<h1><a class="anchor" id="autotoc_md300"></a>
autotoc_md300</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md301"></a>
systemverilog {.bad}</h1>
<p>enum { // Typedef is missing, storage type is missing. Write, Read } req_access, resp_access; // anonymous enum type </p>
<h1><a class="anchor" id="autotoc_md302"></a>
autotoc_md302</h1>
<h2><a class="anchor" id="autotoc_md303"></a>
Signal Naming</h2>
<p><em><b>Use lower_snake_case when naming signals.</b></em></p>
<p>In this context, a <b>signal</b> is meant to mean a net, variable, or port within a SystemVerilog design.</p>
<p>Signal names may contain lowercase alphanumeric characters and underscores.</p>
<p>Signal names should never } with an underscore followed by a number (for example, foo_1, foo_2, etc.). Many synthesis tools map buses into nets using that naming convention, so similarly named nets can lead to confusion when examining a synthesized netlist.</p>
<p>Reserved <a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx13_1/ite_r_verilog_reserved_words.htm">Verilog</a> or SystemVerilog keywords may never be used as names.</p>
<p>When interoperating with different languages, be mindful not to use keywords from other languages.</p>
<h3><a class="anchor" id="autotoc_md304"></a>
Use descriptive names</h3>
<p><em><b>Names should describe what a signals purpose is.</b></em></p>
<p>Use whole words. Avoid abbreviations and contractions except in the most common places. Favor descriptive signal names over brevity.</p>
<h3><a class="anchor" id="autotoc_md305"></a>
Prefixes</h3>
<p>Use common prefixes to identify groups of signals that operate together. For example, all elements of an AXI-S /** */ : , foo_ready, and foo_data.</p>
<p>Additionally, prefixes should be used to clearly label which signal is in which clock group for any /** */ . &lt; ="#" &gt;clock domains for more details.</p>
<p>Examples:</p>
<ul>
<li>Signals associated with controlling a blockram might share a bram_ prefix.</li>
<li>Signals that are synchronous with clk_dram rather than clk should share a dram_ prefix.</li>
</ul>
<p>Code example:</p>
<p>&amp;#x1f44d() { </p>
<h1><a class="anchor" id="autotoc_md306"></a>
systemverilog {.good}</h1>
<p>/** */ ( input clk_i, input rst_ni,</p>
<p>// writer interface input [15:0] wr_data_i, input wr_valid_i, output wr_ready_o,</p>
<p>// reader interface output [15:0] rd_data_o, output rd_valid_o, output [8] rd_fullness_o, input rd_ack_i,</p>
<p>// memory interface: output [8] mem_addr_o, output [15:0] mem_wdata_o, output mem_we_o, input [15:0] mem_rdata_i ) { </p>
<h1><a class="anchor" id="autotoc_md307"></a>
autotoc_md307</h1>
<p>This naming convention makes it easier to map port names onto similar signal names using simple and consistent rules. See the section on <a href="#hierarchical-consistency">Hierarchical Consistency</a> for more information.</p>
<h3><a class="anchor" id="autotoc_md308"></a>
Hierarchical consistency</h3>
<p><em><b>The same signal should have the same name at any level of the hierarchy.</b></em></p>
<p>A signal that connects to a port of an instance should have the same name as that port. By proceeding in this manner, signals that are directly connected should maintain the same name at any level of hierarchy.</p>
<p>Exceptions to this convention are expected, such as:</p>
<ul>
<li>When connecting a port to an element of an array of signals.</li>
<li>When mapping a generic port name to something more specific to the design. For example, two generic blocks, one with a host_bus port and one with a device_bus port might be connected by a foo_bar_bus signal.</li>
</ul>
<p>In each exceptional case, care should be taken to make the mapping of port names to signal names as unambiguous and consistent as possible.</p>
<h2><a class="anchor" id="autotoc_md309"></a>
Clocks</h2>
<p><em><b>All clock signals must { with clk.</b></em></p>
<p>The main system clock for a design must be named clk. It is acceptable to use clk to refer to the default clock that the majority of the logic in a /** */ is synchronous with.</p>
<p>If a /** */ , should be named with a unique identifier, preceded by the clk_ prefix. For example: clk_dram, clk_axi, etc. Note that this prefix will be used to identify other signals in that clock domain.</p>
<h2><a class="anchor" id="autotoc_md310"></a>
Resets</h2>
<p><em><b>Resets are active-low and asynchronous. The default name is rst_n.</b></em></p>
<p>Chip wide all resets are defined as active low and asynchronous. Thus they are defined as tied to the asynchronous reset input of the associated standard cell registers.</p>
<p>The default name is rst_n. If they must be distinguished by their clock, the clock name should be included in the reset name like rst_domain_n.</p>
<p>SystemVerilog allows either of the following syntax styles, but the style guide prefers the former.</p>
<h1><a class="anchor" id="autotoc_md311"></a>
systemverilog</h1>
<p>// preferred always_ff @(posedge clk or negedge rst_n) { if (!rst_n) { q &lt;= 0b0() { } else { q &lt;= d; } }</p>
<p>// legal but not preferred always_ff @(posedge clk, negedge rst_n) { if (!rst_n) { q &lt;= 0b0; } else { q &lt;= d; } } </p>
<h1><a class="anchor" id="autotoc_md312"></a>
autotoc_md312</h1>
<h1><a class="anchor" id="autotoc_md313"></a>
Language Features</h1>
<h2><a class="anchor" id="autotoc_md314"></a>
Preferred SystemVerilog Constructs</h2>
<p>Use these SystemVerilog constructs instead of their Verilog-2001 equivalents:</p>
<ul>
<li>always_comb is required over always @*.</li>
<li>logic is preferred over reg and wire.</li>
<li>Top-level parameter declarations are preferred over define globals.</li>
</ul>
<h2><a class="anchor" id="autotoc_md315"></a>
Package Dependencies</h2>
<p><em><b>Packages must not have cyclic dependencies.</b></em></p>
<p>Package files may depend on constants and types in other package files, but there must not be any cyclic dependencies. That is: if package A depends on a constant from package B, package B must not depend on anything from package A. While cyclic dependencies are permitted by the SystemVerilog language specification, their use can break some tools.</p>
<p>For example:</p>
<h1><a class="anchor" id="autotoc_md316"></a>
systemverilog</h1>
<p>// Package "bar" must not depend on anything in "foo": parameter int unsigned PageSizeBytes = 16 * bar::Kibi;</p>
<h1><a class="anchor" id="autotoc_md317"></a>
autotoc_md317</h1>
<h2><a class="anchor" id="autotoc_md318"></a>
Module Declaration</h2>
<p><em><b>Use the Verilog-2001 full port declaration style, and use the format below.</b></em></p>
<p>Use the Verilog-2001 combined port and I/O declaration style. Do not use the Verilog-95 list style. The port declaration in the /** */ declare the port name, type, and direction.</p>
<p>The opening parenthesis should be on the same line as the /** */ , and the first port should be declared on the following line.</p>
<p>The closing parenthesis should be on its own line, in column zero.</p>
<p>Indentation for /** */ rule of two space indentation.</p>
<p>The clock port(s) must be declared first in the port list, followed by any and all reset inputs.</p>
<p>Example without parameters:</p>
<p>&amp;#x1f44d() { </p>
<h1><a class="anchor" id="autotoc_md319"></a>
systemverilog {.good}</h1>
<p>/** */ ( input clk_i, input rst_ni, input [8] d_i, output logic &lt;7:0&gt; q_o ) { </p>
<h1><a class="anchor" id="autotoc_md320"></a>
autotoc_md320</h1>
<p>Example with parameters:</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md321"></a>
systemverilog {.good}</h1>
<p>/** */ &lt; parameter int unsigned Width = 8, </p><blockquote class="doxtable">
<p>module foo ( </p>
</blockquote>
<p>input clk_i, input rst_ni, input [Width-1:0] d_i, output logic &lt;Width-1:0&gt; q_o ) { </p>
<h1><a class="anchor" id="autotoc_md322"></a>
autotoc_md322</h1>
<p>Do not use Verilog-95 style:</p>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md323"></a>
systemverilog {.bad}</h1>
<p>// WRONG: /** */ (, , ) { input wire &lt;2:0&gt; a; output logic b; ... </p>
<h1><a class="anchor" id="autotoc_md324"></a>
autotoc_md324</h1>
<h2><a class="anchor" id="autotoc_md325"></a>
Module Instantiation</h2>
<p><em><b>Use named ports to fully specify all instantiations.</b></em></p>
<p>When connecting signals to ports for an instantiation, use the named port style, like this:</p>
<h1><a class="anchor" id="autotoc_md326"></a>
systemverilog</h1>
<p>my_module i_my_instance ( .clk_i (clk_i), .rst_ni(rst_ni), .d_i (from_here), .q_o (to_there) ); </p>
<h1><a class="anchor" id="autotoc_md327"></a>
autotoc_md327</h1>
<p>If the port and the connecting signal have the same name, you can use the .port syntax (without parentheses) to indicate connectivity. For example:</p>
<h1><a class="anchor" id="autotoc_md328"></a>
systemverilog</h1>
<p>my_module i_my_instance ( .clk_i, .rst_ni, .d_i (from_here), .q_o (to_there) ); </p>
<h1><a class="anchor" id="autotoc_md329"></a>
autotoc_md329</h1>
<p>All declared ports must be present in the instantiation blocks. Unconnected outputs must be explicitly written as no-connects (for example: .output_port()), and unused inputs must be explicitly tied to ground (for example: .unused_input_port(0d0))</p>
<p>.* is not permitted.</p>
<p>Do not use positional arguments to connect signals to ports.</p>
<p>Instantiate ports in the same order as they are defined in the module.</p>
<p>Align port expressions in <a href="#tabular-alignment">tabular style</a>. Do not include whitespace before the opening parenthesis of the longest port name. Do not include whitespace after the opening parenthesis, or before the closing parenthesis enclosing the port expression.</p>
<p>:-1: </p>
<h1><a class="anchor" id="autotoc_md330"></a>
systemverilog</h1>
<p>mod u_mod( .clk_i, .rst_ni,</p>
<p>// Not allowed: avoid leading/trailing whitespace in expressions. .sig_1_i( sig_1 ), .sig_2_i( sig_2 ) );</p>
<p>mod u_mod( .clk_i, .rst_ni,</p>
<p>.short_sig_i (sig_1), // Not allowed: avoid whitespace between the longest signal name and the opening parenthesis. .a_very_long_signal_name_indeed_i (sig_2) ); </p>
<h1><a class="anchor" id="autotoc_md331"></a>
autotoc_md331</h1>
<p><em><b>Use named parameters for all instantiations.</b></em></p>
<p>When parameterizing an instance, specify the parameter using the named parameter style. An exception is if there is only one parameter that is obvious such as register width, then the instantiation can be implicit.</p>
<p>Indentation for /** */ rule of two space indentation.</p>
<h1><a class="anchor" id="autotoc_md332"></a>
systemverilog</h1>
<p>my_module &lt; .Height(5), .Width(10) </p><blockquote class="doxtable">
<p>my_module ( </p>
</blockquote>
<p>// ... ) {</p>
<p>my_reg &lt;16&gt; my_reg0 ( .clk_i, .rst_ni, .d_i (data_in), .q_o (data_out) ); </p>
<h1><a class="anchor" id="autotoc_md333"></a>
autotoc_md333</h1>
<p>Do not specify parameters positionally, unless there is only one parameter and the intent of that parameter is obvious, such as the width for a register instance.</p>
<p>Do not use defparam.</p>
<p><em><b>Do not instantiate recursively.</b></em></p>
<p>Modules may not instantiate themselves recursively.</p>
<h2><a class="anchor" id="autotoc_md334"></a>
Constants</h2>
<p><em><b>It is recommended to use symbolicly named constants instead of raw numbers.</b></em></p>
<p>Try to give commonly used constants symbolic names rather than repeatedly typing raw numbers.</p>
<p>Local constants should always be declared using localparam.</p>
<p>Global constants should always be declared in a separate .vh or .svh include file.</p>
<p>For SystemVerilog code, global constants should always be declared as package parameters. For Verilog-2001 compatible code, top-level parameters are not supported and define macros must be used instead.</p>
<p>Include the units for a constant as a suffix in the constants symbolic name. The exceptions to this rule are for constants that are inherently unitless, or if the constant is describing the default unit type, "bits."</p>
<p>Example:</p>
<h1><a class="anchor" id="autotoc_md335"></a>
systemverilog</h1>
<p>localparam int unsigned INTERFACE_WIDTH = 64; // Bits localparam int unsigned INTERFACE_WIDTH_BYTES = (INTERFACE_WIDTH + 7) / 8; localparam int unsigned INTERFACE_WIDTH_64B_WORDS = (INTERFACE_WIDTH + 63) / 64; localparam int unsigned IMAGE_WIDTH_PIXELS = 640; localparam int unsigned MEGA = 1000 * 1000; // Unitless localparam int unsigned MEBI = 1024 * 1024; // Unitless localparam int unsigned SYSTEM_CLOCK_HZ = 200 * MEGA; </p>
<h1><a class="anchor" id="autotoc_md336"></a>
autotoc_md336</h1>
<h2><a class="anchor" id="autotoc_md337"></a>
Signal Widths</h2>
<p><em><b>Be careful about signal widths.</b></em></p>
<h3><a class="anchor" id="autotoc_md338"></a>
Always be explicit about the widths of number literals.</h3>
<p>Examples:</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md339"></a>
systemverilog {.good}</h1>
<p>localparam logic &lt;3:0&gt; bar = 0d4;</p>
<p>assign foo = 0d2; </p>
<h1><a class="anchor" id="autotoc_md340"></a>
autotoc_md340</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md341"></a>
systemverilog {.bad}</h1>
<p>localparam logic &lt;3:0&gt; bar = 4;</p>
<p>assign foo = 2; </p>
<h1><a class="anchor" id="autotoc_md342"></a>
autotoc_md342</h1>
<p>Exceptions:</p>
<ul>
<li>When using parameterized widths, it is acceptable to simply use 0b1 (e.g. when incrementing) rather than contrivances such as {{(Bus_width-1){0b0}}, 10b1}. Alternately it could be written as Bus_width(1).</li>
<li>It is acceptable to use the 0 construct to create an automatic correctly sized zero.</li>
<li>Literals assigned to integer variants (e.g. byte, shortint, int, integer, and longint) do not need an explicit width.</li>
</ul>
<h3><a class="anchor" id="autotoc_md343"></a>
Port connections on /** @ingroup SVmodule */module instances must always match widths correctly.</h3>
<p>It is recommended to use explicit widths, rather than relying on Verilogs implicit zero-extension and truncation operations, whenever practical.</p>
<p>Examples:</p>
<p>&amp;#x1f44d() { </p>
<h1><a class="anchor" id="autotoc_md344"></a>
systemverilog {.good}</h1>
<p>my_module i_module ( .thirty_two_bit_input({0d0, sixteen_bit_word}) ); </p>
<h1><a class="anchor" id="autotoc_md345"></a>
autotoc_md345</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md346"></a>
systemverilog {.bad}</h1>
<p>my_module i_module ( // Incorrectly implicitly extends from 16 bit to 32 bit .thirty_two_bit_input(sixteen_bit_word) ); </p>
<h1><a class="anchor" id="autotoc_md347"></a>
autotoc_md347</h1>
<h3><a class="anchor" id="autotoc_md348"></a>
Do not use multi-bit signals in a boolean context.</h3>
<p>Rather than letting boolean operations and if expressions reduce a multi-bit signal to a single bit, explicitly compare the multi-bit signal to 0. The implicit conversion can hide subtle logic bugs.</p>
<p>Examples;</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md349"></a>
systemverilog {.good}</h1>
<p>logic &lt;3:0&gt; a, b; logic out;</p>
<p>assign out = (a != 0) &amp;&amp; (b == 0);</p>
<p>always_comb { if (a != 0) ... else ... } </p>
<h1><a class="anchor" id="autotoc_md350"></a>
autotoc_md350</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md351"></a>
systemverilog {.bad}</h1>
<p>logic &lt;3:0&gt; a, b; logic out;</p>
<p>// Incorrect because it implicitly converts 4-bit signals to 1-bit before AND. // Also, !b is different from ~b and can be hard to catch. assign out = a &amp;&amp; !b;</p>
<p>// Incorrect use of a multi-bit signal in an if expression always_comb { if (a) ... else ... } </p>
<h1><a class="anchor" id="autotoc_md352"></a>
autotoc_md352</h1>
<h3><a class="anchor" id="autotoc_md353"></a>
Bit Slicing</h3>
<p>Only use the bit slicing operator when the intent is to refer to a portion of a bit vector.</p>
<p>Examples:</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md354"></a>
systemverilog {.good}</h1>
<p>logic &lt;7:0&gt; a, b; logic &lt;6:0&gt; c;</p>
<p>assign a = 0d7; // good</p>
<p>assign a[7] = 0d5; // good - it's partial assignment. assign a = b; // good - the parser would warn on width mismatch. </p>
<h1><a class="anchor" id="autotoc_md355"></a>
autotoc_md355</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md356"></a>
systemverilog {.bad}</h1>
<p>logic &lt;7:0&gt; a, b;</p>
<p>assign a[8] = 0d7; // BAD - redundant and can mask linter warnings. assign a = b[8]; // BAD - redundant and masks linter warnings. </p>
<h1><a class="anchor" id="autotoc_md357"></a>
autotoc_md357</h1>
<h3><a class="anchor" id="autotoc_md358"></a>
Handling Width Overflow</h3>
<p>Beware of shift operations, which can produce a result wider than the operand. Bit-selection and concatenation may be clearer than shifting by a constant amount.</p>
<p>Addition and negation operations produce a result one bit wider than the operands, due to carry. An allowable exception to the rule about matching widths is to silently drop the carry on assignment.</p>
<p>Example:</p>
<h1><a class="anchor" id="autotoc_md359"></a>
systemverilog</h1>
<p>logic &lt;3:0&gt; cnt_d, cnt_q; assign cnt_d = cnt_q + 0x1; </p>
<h1><a class="anchor" id="autotoc_md360"></a>
autotoc_md360</h1>
<p>Or you may explicitly express dropping the carry by using size casting.</p>
<h1><a class="anchor" id="autotoc_md361"></a>
systemverilog</h1>
<p>assign cnt_d = 4(cnt_q + 0x1); </p>
<h1><a class="anchor" id="autotoc_md362"></a>
autotoc_md362</h1>
<h2><a class="anchor" id="autotoc_md363"></a>
Blocking and Non-blocking Assignments</h2>
<p><em><b>Sequential logic must use non-blocking assignments. Combinational blocks must use blocking assignments.</b></em></p>
<p>Never mix assignment types within a block declaration.</p>
<p>A sequential block (a block that latches state on a clock edge) must exclusively use non-block assignments, as defined in the Sequential Logic section below.</p>
<p>Purely combinational blocks must exclusively use blocking assignments.</p>
<p>This is one of Cliff Cummings <a href="http://www.ece.cmu.edu/~ece447/s13/lib/exe/fetch.php?media=synth-verilog-cummins.pdf">Golden Rules of Verilog</a>.</p>
<h2><a class="anchor" id="autotoc_md364"></a>
Delay Modeling</h2>
<p><em><b>Do not use #delay in synthesizable design modules.</b></em></p>
<p>Synthesizable design modules must be designed around a zero-delay simulation methodology. All forms of #delay, including #0, are not permitted.</p>
<p>See Cliff Cummings <a href="http://www.sunburst-design.com/papers/CummingsSNUG2002Boston_NBAwithDelays.pdf">Verilog Nonblocking Assignments With Delays, Myths &amp; Mysteries</a> for details.</p>
<h2><a class="anchor" id="autotoc_md365"></a>
Sequential Logic (Latches)</h2>
<p><em><b>The use of latches is discouraged - use flip-flops when possible.</b></em></p>
<p>Unless absolutely necessary, use flops/registers instead of latches.</p>
<p>If you must use a latch, use always_latch over always, and use non-blocking assignments (&lt;=). Never use blocking assignments (=).</p>
<h2><a class="anchor" id="autotoc_md366"></a>
Sequential Logic (Registers)</h2>
<p><em><b>Use the standard format for declaring sequential blocks.</b></em></p>
<p>In a sequential always block, only use non-blocking assignments (&lt;=). Never use blocking assignments (=).</p>
<p>Designs that mix blocking and non-blocking assignments for registers simulate incorrectly because some simulators process some of the blocking assignments in an always block as occurring in a separate simulation event as the non-blocking assignment. This process makes some signals jump registers, potentially leading to total protonic reversal. Thats bad.</p>
<p>Sequential statements for state assignments should only contain reset values and a next-state to state assignment, use a separate combinational-only block to generate that next-state value.</p>
<p>A correctly implemented 8-bit register with an value of "0xAB" would be implemented:</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md367"></a>
systemverilog {.good}</h1>
<p>logic foo_en; logic &lt;7:0&gt; foo_q, foo_d;</p>
<p>always_ff @(posedge clk or negedge rst_ni) { if (!rst_ni) { foo_q &lt;= 0xab; } else if (foo_en) { foo_q &lt;= foo_d; } } </p>
<h1><a class="anchor" id="autotoc_md368"></a>
autotoc_md368</h1>
<p>Do not allow multiple non-blocking assignments to the same bit.</p>
<p>Example:</p>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md369"></a>
systemverilog {.bad}</h1>
<p>if (cond1) { abc &lt;= 0x1; }</p>
<p>if (cond2) { abc &lt;= 0x2; } </p>
<h1><a class="anchor" id="autotoc_md370"></a>
autotoc_md370</h1>
<p>If both cond1 and cond2 are true, the Verilog standard says that the second assignment will take effect, but this is a style violation.</p>
<p>Even if cond1 and cond2 are mutually exclusive, make the second if into an #else if.</p>
<p>Exception: It is fine to set default values first, then specific values. However, it is preferred to do this work in a separate combinational block with explicit blocking assignments.</p>
<p>Example:</p>
<h1><a class="anchor" id="autotoc_md371"></a>
systemverilog</h1>
<p>always_ff @(posedge clk or negedge rst_ni) { if (!rst_ni) { state_q &lt;= StIdle; } else { state_q &lt;= state_d; } }</p>
<p>always_comb { state_d = state_q; // default assignment next state is present state unique case (state_q) { StIdle: state_d = StInit; // Idle State move to Init StInit: { // Initialize calculation if (conditional) { state_d = StIdle; } else { state_d = StCalc; } } StCalc: { // Perform calculation if (conditional) { state_d = StResult; } } StResult: state_d = Idle; default: ; } } </p>
<h1><a class="anchor" id="autotoc_md372"></a>
autotoc_md372</h1>
<p>Keep work in sequential blocks simple. If a sequential block becomes sufficiently complicated, consider splitting the combinational logic into a separate combinational (always_comb) block. Ideally, sequential blocks should contain only a register instantiation, with perhaps a load enable or an increment.</p>
<h2><a class="anchor" id="autotoc_md373"></a>
Dont Cares (Xs)</h2>
<p><em><b>The use of X literals in RTL code is strongly discouraged. RTL must not assert X to indicate "don't care" to synthesis in any case. In order to flag and detect invalid conditions, rather than assign and propagate X values, designs should fully define all signal values and make extensive use of SVAs to indicate the invalid conditions.</b></em></p>
<p>If not strictly controlled, the use of X assignments in RTL to flag invalid or dont care conditions can lead to simulation/synthesis mismatches.</p>
<p>Instead of assigning and propagating X in order to flag and detect invalid conditions, it is encouraged to make <b>extensive use of SVAs</b>. The added benefits of this design practice are that:</p>
<ul>
<li>No special code style is required to properly propagate X conditions,</li>
<li>The chance of accidentally introducing simulation/synthesis mismatches is systematically reduced,</li>
<li>Simulation fails quickly and less signal backtracking is needed to root-cause bugs,</li>
<li>In several cases, formal property verification (FPV) can be used to prove whether these SVAs can always be fulfilled,</li>
<li>In a security context, deterministic/defined behavior is desired, even for illegal/invalid/unreachable input combinations (sometimes stated more tersely as "for security-critical designs, there are no don't-cares").</li>
</ul>
<p>The solution presented here has similarities with the approaches presented in <a href="http://www.lcdm-eng.com/papers/snug04_assertiveX.pdf">"Being Assertive With Your X"</a> by Don Mills.</p>
<p>Note that although dont cares can be used to indicate possible optimization opportunities to the synthesis tool, it is debatable whether the gains in logic reduction are significant enough to outweigh the possible simulation/synthesis mismatch issues that the use of X literals may entail (especially with the gate-counts available in todays technologies).</p>
<h3><a class="anchor" id="autotoc_md374"></a>
Catching errors where invalid values are consumed</h3>
<p>For an internally-generated signal that could be invalid (but not driven to X) and is used to trigger some action (such as a register write-enable), it is recommened to add an assert to check that when the enable is true, the signal is valid. This triggers a simple to diagnose failure when an invalid value has been accidentally used.</p>
<h1><a class="anchor" id="autotoc_md375"></a>
systemverilog</h1>
<p>logic reg_addr; logic reg_wr_en;</p>
<p>// internal logic which generates reg_addr/reg_wr_en reg_en_addr will never // be X but must be ignored if reg_wr_en == 0 assign reg_addr = ... assign reg_wr_en = ...</p>
<p>...</p>
<p>// trigger some specific action when a certain register is written logic special_reg_en;</p>
<p>assign special_reg_en = (reg_addr == SPECIAL_REG_ADDR) &amp; reg_wr_en;</p>
<p>// Aim to keep RHS of implication as broad as possible ASSERT(NoSpecialRegEnWithoutRegEn, special_reg_en |-&gt; reg_wr_en); </p>
<h1><a class="anchor" id="autotoc_md376"></a>
autotoc_md376</h1>
<p>Where the value and its validity signal are generated by a DV environment which will drive X on invalid signals an ASSERT_KNOWN suffices.</p>
<h1><a class="anchor" id="autotoc_md377"></a>
systemverilog</h1>
<p>/** */ ( input [8] external_addr_i, input external_wr_en_i ) {</p>
<p>logic special_action_en;</p>
<p>assign special_action_en = (external_addr_i == SPECIAL_ADDR) &amp; external_wr_en_i;</p>
<p>ASSERT_KNOWN(special_action_en)</p>
<p>} </p>
<h1><a class="anchor" id="autotoc_md378"></a>
autotoc_md378</h1>
<h3><a class="anchor" id="autotoc_md379"></a>
Specific Guidance on Case Statements and Ternaries</h3>
<p>To comply with this style, RTL must place ASSERT_KNOWN assertions on all /** */ , beginning of the simulation, such as FIFO, SRAM or register file outputs.</p>
<h1><a class="anchor" id="autotoc_md380"></a>
systemverilog</h1>
<p>/** */ ( input ina_i, input inb_i, output logic out_o ) { assign out_o = ina_i ^ inb_i; ASSERT_KNOWN(OutKnown_A, out_o, clk_i, !rst_ni) } </p>
<h1><a class="anchor" id="autotoc_md381"></a>
autotoc_md381</h1>
<p>Further, it is encouraged to add assertions to the signals forming conditions of case statements, ternaries or if/else statements. The assertion style is at the designers discretion, and can range from simple ASSERT_KNOWN to fully functional assertions, as shown in the following examples:</p>
<h1><a class="anchor" id="autotoc_md382"></a>
systemverilog</h1>
<p>typedef enum {mode0, mode1, mode2} state_e; state_e sel;</p>
<p>// encouraged ASSERT_KNOWN(SelKnown_A, sel) always_comb { out0 = 0; out1 = 0; unique case (sel) { mode1: out0 = foo; mode2: out1 = bar; default: ; } }</p>
<p>// optional, but more explicit // not always applicable ASSERT(MainFsmCase_A, sel inside {mode0, mode1, mode2}, clk_i, !rst_ni) always_comb { out0 = 0; out1 = 0; unique case (sel) { mode1: out0 = foo; mode2: out1 = bar; default: ; } } </p>
<h1><a class="anchor" id="autotoc_md383"></a>
autotoc_md383</h1>
<p>In the context of ternary statements, the following are encouraged examples:</p>
<h1><a class="anchor" id="autotoc_md384"></a>
systemverilog</h1>
<p>// encouraged ASSERT_KNOWN(ModeKnown_A, mode_i, clk_i, !rst_ni) ASSERT_KNOWN(LenKnown_A, len_i, clk_i, !rst_ni) // assign '0 for all other combinations assign val = (mode_i == ENC) ? 0x01 : (mode_i == DEC &amp;&amp; len_i == LEN128) ? 0x36 : (mode_i == DEC &amp;&amp; len_i == LEN192) ? 0x80 : (mode_i == DEC &amp;&amp; len_i == LEN256) ? 0x40 : 80x00;</p>
<p>// optional, but more explicit ASSERT(ValSelValid_A, mode_i == ENC || mode_i == DEC &amp;&amp; len_i inside {LEN128, LEN192, LEN256}, clk_i, !rst_ni) // using one of the valid outputs for other combinations (saves logic) assign val = (mode_i == ENC) ? 0x01 : (mode_i == DEC &amp;&amp; len_i == LEN128) ? 0x36 : (mode_i == DEC &amp;&amp; len_i == LEN192) ? 0x80 : (mode_i == DEC &amp;&amp; len_i == LEN256) ? 0x40 : 80x01; </p>
<h1><a class="anchor" id="autotoc_md385"></a>
autotoc_md385</h1>
<p>Note that there are cases where the input into a case or ternary could be X but only under circumstances where it doesnt matter as the output will be ignored as some valid signal that qualifies the input is not set. For example the input may be fed directly from a memory or from a top-level input that a DV environment drives to X. A plain ASSERT_KNOWN will not work under these circumstances and it is appropriate to use an assert with some qualifying valid instead:</p>
<h1><a class="anchor" id="autotoc_md386"></a>
systemverilog</h1>
<p>ASSERT(AddrKnownIfValid, addr_valid |-&gt; !$isunknown(addr)) always_comb { out = 0 unique case (addr[2]) { ConstAddr1: out = foo; ConstAddr2: out = bar; default: out = baz; } } </p>
<h1><a class="anchor" id="autotoc_md387"></a>
autotoc_md387</h1>
<p>The aim should be to make the qualifying valid signal as wide reaching as possible rather than narrowing down the X check more than is required:</p>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md388"></a>
systemverilog {.bad}</h1>
<p>ASSERT(AddrKnownIfValid, addr_valid &amp; internal_condition_1 &amp; internal_condition_2 |-&gt; !$isunknown(addr)) </p>
<h1><a class="anchor" id="autotoc_md389"></a>
autotoc_md389</h1>
<h3><a class="anchor" id="autotoc_md390"></a>
Dynamic Array Indexing</h3>
<p>It should be noted that dynamic array indexing operations can implicitly lead to X. This should be avoided if possible by either aligning indexed arrays to powers of 2 or by adding guarding if statements around the indexing operation. These solutions are illustrated in the following examples.</p>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md391"></a>
systemverilog {.bad}</h1>
<p>logic selected; logic &lt;3:0&gt; idx; logic &lt;11:0&gt; foo; // problematic</p>
<p>assign foo = {0b1010_1111_0000}; assign selected = foo[idx]; </p>
<h1><a class="anchor" id="autotoc_md392"></a>
autotoc_md392</h1>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md393"></a>
systemverilog {.good}</h1>
<p>logic selected; logic &lt;3:0&gt; idx; logic &lt;15:0&gt; foo; // aligned to powers of two</p>
<p>assign foo = {0b0000, 120b1010_1111_0000}; assign selected = foo[idx]; </p>
<h1><a class="anchor" id="autotoc_md394"></a>
autotoc_md394</h1>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md395"></a>
systemverilog {.good}</h1>
<p>logic selected; logic &lt;3:0&gt; idx; logic &lt;11:0&gt; foo;</p>
<p>assign foo = {0b1010_1111_0000};</p>
<p>// guarding if statement assign selected = (idx &lt; $bits(foo)) ? foo[idx] : 0b0; </p>
<h1><a class="anchor" id="autotoc_md396"></a>
autotoc_md396</h1>
<h2><a class="anchor" id="autotoc_md397"></a>
Combinational Logic</h2>
<p><em><b>Avoid sensitivity lists, and use a consistent assignment type.</b></em></p>
<p>Use always_comb for SystemVerilog combinational blocks. Use always @* if only Verilog-2001 is supported. Never explicitly declare sensitivity lists for combinational logic.</p>
<p>Prefer assign statements wherever practical.</p>
<p>Example:</p>
<h1><a class="anchor" id="autotoc_md398"></a>
systemverilog</h1>
<p>assign final_value = xyz ? value_a : value_b; </p>
<h1><a class="anchor" id="autotoc_md399"></a>
autotoc_md399</h1>
<p>Where a case statement is needed, enclose it in its own always_comb block.</p>
<p>Synthesizable combinational logic blocks should only use blocking assignments.</p>
<p>Do not use three-state logic (Z state) to accomplish on-chip logic such as muxing.</p>
<p>Do not infer a latch inside a , as this may cause a simulation/synthesis mismatch.</p>
<h2><a class="anchor" id="autotoc_md400"></a>
Case Statements</h2>
<p><em><b>Avoid case-modifying pragmas. unique case is the best practice. Always define a default case.</b></em></p>
<p>Never use either the full_case or parallel_case pragmas. These pragmas can easily cause simulation/synthesis mismatches.</p>
<p>Here is an example of a style-compliant full case statement:</p>
<h1><a class="anchor" id="autotoc_md401"></a>
systemverilog</h1>
<p>always_comb { unique case (select) { 0b000: operand = accum0 &gt;&gt; 0() { 0b001: operand = accum0 &gt;&gt; 1; 0b010: operand = accum1 &gt;&gt; 0; 0b011: operand = accum1 &gt;&gt; 1; 0b1??: operand = regfile[select[2]]; default: operand = 0; // assign a default } } </p>
<h1><a class="anchor" id="autotoc_md402"></a>
autotoc_md402</h1>
<p>The unique prefix is recommended before all case statements, as it creates simulation assertions that can catch certain mistakes. In some cases, priority may be used instead of unique, though in such cases, cascaded ternary structures should be the preferred way of representing priority encoders as they are a more readable representation for priority encoders.</p>
<p>Be sure to use unique case correctly. In particular, make sure that:</p>
<ul>
<li>a default: statement is <b>always</b> included in order to avoid accidental inference of latches, even if all cases are covered. In simulation, a case expression that evaluates to X will not match any case and will behave as a latch, leading to different behavior than synthesis if no default is specified.</li>
<li>if no default assignments are given before the case statement as shown in the example above, any variables assigned in one case item must be assigned in all case items, including the default:. Failing to do this can lead to a simulation/synthesis mismatch as described in <a href="http://www.lcdm-eng.com/papers/snug12_Paper_final.pdf">Don Mills paper</a>.</li>
</ul>
<p>The following is a different example showing a style-compliant case statement variant that is frequently used for describing the next-state logic of a finite state machine. What is different from the previous example is that the default assignments are put before the unique case block, thus making it possible to omit common assignments in the individual cases further below. If it werent for the common default assignments before the case statement, all variables would have to be assigned a value in all cases and in the default: in order to prevent simulation/synthesis mismatches.</p>
<h1><a class="anchor" id="autotoc_md403"></a>
systemverilog</h1>
<p>always_comb { // common default assignments state_d = state_q; outa = 0b0; outb = 0b0; outc = 0b0;</p>
<p>unique case (state_q) { Idle: { state_d = Work; outa = in0; } Work: { state_d = Wait; outb = in1; } Wait: { state_d = Idle; outc = in2; } // always include a default case // empty default permissible due to defaults before case block default: ; } } </p>
<h1><a class="anchor" id="autotoc_md404"></a>
autotoc_md404</h1>
<h3><a class="anchor" id="autotoc_md405"></a>
Wildcards in case items</h3>
<p>Use case if wildcard operator behavior is not needed. Use case inside if wildcard operator behavior is needed. Use case if wildcard operator behavior is needed and Verilog-2001 compatibility is required.</p>
<p>When expressing a wildcard in a case item, use the ? character since it more clearly expresses the intent.</p>
<p>case should not be used. casex implements a symmetric wildcard operator such that an X in the case expression may match one or more case items. case only treats high-impedance states (Z or ?) { as a wildcard, and performs exact matches for undriven X inputs. While this does not completely fix the problems with symmetric wildcard matching, it is harder to accidentally produce a Z input than an X input, so this form is preferred. case inside does not treat either X or Z in the case expression as a wildcard, so this form is preferred over case.</p>
<p>References:</p>
<ul>
<li>Don Mills, <a href="http://www.lcdm-eng.com/papers/snug12_Paper_final.pdf">Yet Another Latch and Gotchas Paper</a></li>
<li>Clifford Cummings, <a href="http://www.sunburst-design.com/papers/CummingsSNUG1999Boston_FullParallelCase_rev1_1.pdf">full_case parallel_case, the Evil Twins of Verilog Synthesis</a></li>
<li>Clifford Cummings, <a href="http://www.sunburst-design.com/papers/CummingsSNUG2005Israel_SystemVerilog_UniquePriority.pdf">SystemVerilogs priority &amp; unique</a></li>
<li>Sutherland, Mills, and Spear, <a href="http://www.lcdm-eng.com/papers/snug07_Verilog%20Gotchas%20Part2.pdf">Gotcha Again: More Subtleties in the Verilog and SystemVerilog Standards That Every Engineer Should Know</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md406"></a>
Generate Constructs</h2>
<p><em><b>Always name your generated blocks.</b></em></p>
<p>When using a generate construct, always explicitly name each block of generated code. Name each possible outcome of the generating if statement, and name the iterated block of a generating for statement.</p>
<p>This ensures that generated hierarchical signal names are consistent across different tools.</p>
<p>Generate and all named code blocks should use lower_snake_case. A space should be placed between { and the code block name.</p>
<p>Example of a conditional generate construct:</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md407"></a>
systemverilog {.good}</h1>
<p>if (TypeIsPosedge) { always_ff @(posedge clk) foo &lt;= bar; } else { always_ff @(negedge clk) foo &lt;= bar; } </p>
<h1><a class="anchor" id="autotoc_md408"></a>
autotoc_md408</h1>
<p>Example of a loop generate construct:</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md409"></a>
systemverilog {.good}</h1>
<p>for (genvar ii = 0; ii &lt; NumberOfBuses; ii++) { my_bus &lt;.index(ii)&gt; i_my_bus (.foo(foo), .bar(bar[ii])); } </p>
<h1><a class="anchor" id="autotoc_md410"></a>
autotoc_md410</h1>
<p>Do not wrap a generate construct with an additional { block.</p>
<p>Do not use generate regions {generate, endgenerate}.</p>
<h2><a class="anchor" id="autotoc_md411"></a>
Signed Arithmetic</h2>
<p><em><b>Use the available signed arithmetic constructs wherever signed arithmetic is used.</b></em></p>
<p>When its necessary to convert from unsigned to signed, use the signed cast operator ($signed in Verilog-2001).</p>
<p>If any operand in a calculation is unsigned, Verilog implicitly casts all operands to unsigned and generates a warning. There should not be any signed-to-unsigned warnings from either the simulation or synthesis tools if all unsigned variables are properly casted.</p>
<p>Example of implicit signed-to-unsigned casting:</p>
<h1><a class="anchor" id="autotoc_md412"></a>
systemverilog</h1>
<p>logic signed [8] a; logic incr; logic signed [15:0] sum1, sum2, sum3; { a = 8sh80; // a = -128 incr = 0b1; sum1 = a + incr; // bad: sum1 = 16'h0081 ( 129) sum2 = a + signed({0b0, incr}); // good: sum2 = 16'hFF81 (-127) sum3 = a + 8sh01; // good: sum3 = sum2 (more straightforward) } </p>
<h1><a class="anchor" id="autotoc_md413"></a>
autotoc_md413</h1>
<p>In the above example, the fact that incr is unsigned causes a to be evaluated as unsigned as well. The sum1 evaluation is surprising and is flagged by a warning that should not be ignored.</p>
<h2><a class="anchor" id="autotoc_md414"></a>
Number Formatting</h2>
<p><em><b>Prefix printed binary numbers with 0b. Prefix printed hexadecimal numbers with 0x. Do not use prefixes for decimal numbers.</b></em></p>
<p>When formatting text representations of numbers for log files, make it clear what data you are including.</p>
<p>Make the base of a printed number clear. Only print decimal numbers without modifiers. Use a 0x prefix for hexadecimal and 0b prefix for binary.</p>
<p>Decode individual fields of large structures individually, instead of expecting the user to manually decode raw values.</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md415"></a>
systemverilog {.good}</h1>
<p>$display("0x%0x", some_hex_value); $display("0b%0b", some_binary_value); $display("%0d", some_decimal_value); </p>
<h1><a class="anchor" id="autotoc_md416"></a>
autotoc_md416</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md417"></a>
systemverilog {.bad}</h1>
<p>$display("%0x", some_hex_value); $display("%0b", some_binary_value); $display("0d%0d", some_decimal_value); </p>
<h1><a class="anchor" id="autotoc_md418"></a>
autotoc_md418</h1>
<p>When assigning constant values, it is preferred to use underscore notation for hex or binary bit strengths of length beyond 8 for better readability. Zero prepending is not required unless it improves readability. Declare constants in the format (binary, hex, decimal) they are typically displayed in.</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md419"></a>
systemverilog {.good}</h1>
<p>logic &lt;15:0&gt; val0, val1, val2; logic &lt;39:0&gt; addr0, addr1;</p>
<p>always_comb { val0 = 0x0; if (condition1) { val1 = 0b0010_0011_0000_1101; val2 = 0b0010_1100_0000_0000; addr1 = 0x00_1fc0_0000; addr2 = 0x00_efc0_0000; } else { val0 = 0xffff; val1 = 0b1010_0011_0110_1001; val2 = 0b1110_1100_1111_0110; addr1 = 0x40_8000_0000; addr2 = 0x41_c000_0000; } } </p>
<h1><a class="anchor" id="autotoc_md420"></a>
autotoc_md420</h1>
<h2><a class="anchor" id="autotoc_md421"></a>
Functions and Tasks</h2>
<p>The following section applies to synthesizable RTL only. See the <a class="el" href="group__SVmodule.html">Coding Style</a>Guide for Design Verification" for DV usage.</p>
<p><em><b>In synthesizable RTL the use of functions is allowed, provided they are declared automatic. Tasks should not be used.</b></em></p>
<p>Functions must be declared in either a package or inside a module. A package is appropriate where the relates to other definitions in the package and could be useful to multiple modules (even if its currently only used by one). A /** */ of that module.</p>
<p>Functions should aim to conceptually represent a reusable block of combinational logic.</p>
<p>Storage types must be explicitly declared for all arguments and the return value. All types must be 4-state data types, either logic or types derived from logic (such as appropriate struct, enum or typedef types).</p>
<p>Do not use output, inout, or ref on arguments. All functions should only consume inputs and produce one output. input is the default and is not required on the arguments.</p>
<p>&amp;#x1f44e() { </p>
<h1><a class="anchor" id="autotoc_md422"></a>
systemverilog {.bad}</h1>
<p>// - Doesn't have explicit storage type on <code>a</code> or <code>b</code> or return type // - <code>b</code> being used as <code>output</code> argument // - <code>input</code> not required on <code>a</code> automatic [3] foo(input [2:0] a, [2:0] b) { b = b + 1; return a + b; } </p>
<h1><a class="anchor" id="autotoc_md423"></a>
autotoc_md423</h1>
<p>public: &amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md424"></a>
systemverilog {.bad}</h1>
<p>// - Doesn't have explicit storage type on <code>a</code>, <code>b</code> or <code>c</code> // - Uses <code>output</code> on <code>c</code> // - <code>input</code> not required on <code>a</code> and <code>b</code> automatic logic &lt;2:0&gt; foo(input [3] a, input [2:0] b, output [2:0] c) { c = a - b; return a + b; } </p>
<h1><a class="anchor" id="autotoc_md425"></a>
autotoc_md425</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md426"></a>
systemverilog {.bad}</h1>
<p>// - Uses 2-state data type <code>int</code> for <code>a</code> automatic logic &lt;2:0&gt; foo(int a, logic &lt;2:0&gt;  b) { return a + b; } </p>
<h1><a class="anchor" id="autotoc_md427"></a>
autotoc_md427</h1>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md428"></a>
systemverilog {.good}</h1>
<p>automatic logic &lt;2:0&gt; foo(logic &lt;2:0&gt;  a, logic &lt;2:0&gt;  b) { return a ^ b; } </p>
<h1><a class="anchor" id="autotoc_md429"></a>
autotoc_md429</h1>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md430"></a>
systemverilog {.good}</h1>
<p>typedef logic &lt;2:0&gt; bar_t;</p>
<p>typedef struct packed { logic &lt;2:0&gt; field; } baz_t;</p>
<p>automatic logic &lt;2:0&gt; foo(bar_t a, baz_t b) { return a + b.field; } </p>
<h1><a class="anchor" id="autotoc_md431"></a>
autotoc_md431</h1>
<p>Data should be returned from a using an explicit return result style. Do not use a function_name = result style.</p>
<p>&amp;#x1f44e() { </p>
<h1><a class="anchor" id="autotoc_md432"></a>
systemverilog {.bad}</h1>
<p>automatic logic &lt;2:0&gt; foo(logic &lt;2:0&gt;  a, logic &lt;2:0&gt;  b) { if (a == 0d2) { foo = b; } else { foo = a ^ b; } } </p>
<h1><a class="anchor" id="autotoc_md433"></a>
autotoc_md433</h1>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md434"></a>
systemverilog {.good}</h1>
<p>automatic logic &lt;2:0&gt; foo(logic &lt;2:0&gt;  a, logic &lt;2:0&gt;  b) { logic &lt;2:0&gt; result;</p>
<p>if (a == 0d2) { result = b; } else { result = a ^ b; }</p>
<p>return result; } </p>
<h1><a class="anchor" id="autotoc_md435"></a>
autotoc_md435</h1>
<p>private: All variables must be assigned in all code paths, either through an public: assignment or through the use of else and default: for if and case statements.</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md436"></a>
systemverilog {.good}</h1>
<p>automatic logic &lt;2:0&gt; foo(logic &lt;2:0&gt;  a, logic &lt;2:0&gt;  b) { logic &lt;2:0&gt; local_var_1; logic &lt;2:0&gt; local_var_2;</p>
<p>local_var_1 = 0d0;</p>
<p>if (a == 0) { local_var_1 = 0d2; }</p>
<p>unique case (b) { 0d0: local_var_2 = 30d1; 0d1: local_var_2 = 30d3; default: local_var_2 = 0d0; }</p>
<p>return local_var_1 + local_var_2; } </p>
<h1><a class="anchor" id="autotoc_md437"></a>
autotoc_md437</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md438"></a>
systemverilog {.bad}</h1>
<p>automatic logic &lt;2:0&gt; foo(logic &lt;2:0&gt;  a, logic &lt;2:0&gt;  b) { logic &lt;2:0&gt; local_var_1; logic &lt;2:0&gt; local_var_2;</p>
<p>if (a == 0) { local_var_1 = 0d2; }</p>
<p>unique case (b) { 0d0: local_var_2 = 30d1; 0d1: local_var_2 = 30d3; }</p>
<p>return local_var_1 + local_var_2; } </p>
<h1><a class="anchor" id="autotoc_md439"></a>
autotoc_md439</h1>
<p>private: Functions should not reference any non- signals or variables outside their scope. Avoiding non- references improves readability and helps reduce simulation/synthesis mismatches. Accessing non- parameters and constants public: is allowed.</p>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md440"></a>
systemverilog {.bad}</h1>
<p>// - Incorrect because <code>mem</code> is not local to get_mem() // - Incorrect because <code>in_i</code> is not local to get_mem() /** */ ( input logic &lt;7:0&gt; in_i, output logic &lt;7:0&gt; out_o ) {</p>
<p>logic &lt;7:0&gt; mem[256];</p>
<p>automatic logic &lt;7:0&gt; get_mem() { return mem[in_i]; }</p>
<p>assign out_o = get_mem();</p>
<p>} </p>
<h1><a class="anchor" id="autotoc_md441"></a>
autotoc_md441</h1>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md442"></a>
systemverilog {.good}</h1>
<p>// - Correct because <code>MagicValue</code> is a parameter // - Correct because <code>my_pkg::OtherMagicValue</code> is a parameter // - Correct because <code>in_i</code> passed as an argument /** */ ( input logic &lt;7:0&gt; in_i, output logic &lt;7:0&gt; out_o ) {</p>
<p>localparam [8] MagicValue = 1;</p>
<p>automatic logic is_magic(logic &lt;7:0&gt;  v) { return (v == MagicValue) || (v == my_pkg::OtherMagicValue); }</p>
<p>assign out_o = is_magic(in_i);</p>
<p>} </p>
<h1><a class="anchor" id="autotoc_md443"></a>
autotoc_md443</h1>
<h2><a class="anchor" id="autotoc_md444"></a>
Problematic Language Features and Constructs</h2>
<p>These language features are considered problematic and their use is discouraged unless otherwise noted:</p>
<ul>
<li>Interfaces.</li>
<li>The alias statement.</li>
</ul>
<h3><a class="anchor" id="autotoc_md445"></a>
Floating {-} blocks</h3>
<p>The use of generate blocks other than for loop, if, or case generate constructs is not LRM compliant. While such usage might be accepted by some tools, this guide prohibits such "bare" generate blocks. Note that the similar "sequential block" construct is LRM compliant and allowed.</p>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md446"></a>
systemverilog {.bad}</h1>
<p>/** */ ( input bar, output foo ) { { // illegal generate block assign foo = bar; } } </p>
<h1><a class="anchor" id="autotoc_md447"></a>
autotoc_md447</h1>
<h3><a class="anchor" id="autotoc_md448"></a>
Hierarchical references</h3>
<p>The use of hierarchical references in synthesizable RTL code is prohibited. Certain synthesis tools indeed support hierarchical references, while some tools error out and others may silently ignore them potentially leading to simulation/synthesis mismatches.</p>
<p>An exemption to this is the case where the hierarchical references are guarded by macros to remove them for synthesis, e.g., as part of SystemVerilog assertions (SVAs).</p>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md449"></a>
systemverilog {.bad}</h1>
<p>/** */ ( input in0_i, input in1_i, input in2_i, output logic out_o ) {</p>
<p>logic int; assign int = in0_i &amp; in1_i; assign out_o = in2_i | int;</p>
<p>}</p>
<p>/** */ ( ... ) {</p>
<p>mymod_int u_mymod_int ( .in0_i, .in1_i, .in2_i, .out_o );</p>
<p>// Hierarchical references are prohibited in synthesizable RTL code. assign int_o = u_mymod_int.int;</p>
<p>} </p>
<h1><a class="anchor" id="autotoc_md450"></a>
autotoc_md450</h1>
<h1><a class="anchor" id="autotoc_md451"></a>
Design Conventions</h1>
<h2><a class="anchor" id="autotoc_md452"></a>
Summary</h2>
<p>The key ideas in this section include:</p>
<ul>
<li>Declare all signals and use logic: logic foo;</li>
<li>Packed arrays are little-endian: logic &lt;7:0&gt; byte;</li>
<li>Unpacked arrays are big-endian: byte_t arr[0:N-1];</li>
<li>Prefer to register /** */ .</li>
<li>Declare FSMs consistently.</li>
</ul>
<h2><a class="anchor" id="autotoc_md453"></a>
Declare all signals</h2>
<p><em><b>Do not rely on inferred nets.</b></em></p>
<p>All signals <b>must</b> be explicitly declared before use. All declared signals must specify a data type. A correct design contains no inferred nets.</p>
<h2><a class="anchor" id="autotoc_md454"></a>
Use logic for synthesis</h2>
<p><em><b>Use logic for synthesis. wire is allowed when necessary.</b></em></p>
<p>All signals in synthesizable RTL must be implemented in terms of 4-state data types. This means that all signals must ultimately be constructed of nets with the storage type of logic. While SystemVerilog does provide other data primitives with 4-state storage (ie. integer), those primitives are prone to misunderstandings and misuse.</p>
<p>For example:</p>
<p>&amp;#x1f44d() { </p>
<h1><a class="anchor" id="autotoc_md455"></a>
systemverilog {.good}</h1>
<p>logic signed [31:0] x_velocity; // say what you mean: a signed 32-bit integer. typedef logic &lt;7:0&gt; byte_t; </p>
<h1><a class="anchor" id="autotoc_md456"></a>
autotoc_md456</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md457"></a>
systemverilog {.bad}</h1>
<p>bit signed [63:0] stars_in_the_sky; // 2-state logic doesn't belong in RTL int grains_of_sand; // Or wait, did I mean integer? Easy to confuse! </p>
<h1><a class="anchor" id="autotoc_md458"></a>
autotoc_md458</h1>
<p>It is permissible to use wire as a short-hand to both declare a net and perform continuous assignment. Take care not to confuse continuous assignment with initialization. For example:</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md459"></a>
systemverilog {.good}</h1>
<p>wire &lt;7:0&gt; sum = a + b; // Continuous assignment </p>
<h1><a class="anchor" id="autotoc_md460"></a>
autotoc_md460</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md461"></a>
systemverilog {.bad}</h1>
<p>logic &lt;7:0&gt; sum = a + b; // Initialization (not synthesizable) </p>
<h1><a class="anchor" id="autotoc_md462"></a>
autotoc_md462</h1>
<p>sum is initialized to sum of values of a and b.</p>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md463"></a>
systemverilog {.good}</h1>
<p>logic &lt;7:0&gt; acc = 0; // Initialization (synthesizable on some FPGA tools) </p>
<h1><a class="anchor" id="autotoc_md464"></a>
autotoc_md464</h1>
<p>There are exceptions for places where logic is inappropriate. For example, nets that connect to bidirectional (inout) ports must be declared with wire. These exceptions should be justified with a short comment.</p>
<p>It is permissible for DV (Design Verification) to make use of 2-state logic, but all interfaces between 4-state and 2-state signals must assert a check for X on the 4-state net before resolving to a 2-state variable.</p>
<h2><a class="anchor" id="autotoc_md465"></a>
Logical vs. Bitwise</h2>
<p><em><b>Prefer logical constructs for logical comparisons, bit-wise for data.</b></em></p>
<p>Logical operators (!, ||, &amp;&amp;, ==, !=) should be used for all constructs that are evaluating logic (true or false) values, such as if clauses and ternary assignments. Prefer bit-wise operators (~, |, &amp;, ^) for all data constructs, even if scalar. Exceptions can be made where it is clear that the evaluated expression is to be used in a logical context.</p>
<p>:+1: </p>
<h1><a class="anchor" id="autotoc_md466"></a>
systemverilog {.good}</h1>
<p>always_ff @(posedge clk_i or negedge rst_ni) { if (!rst_ni) { reg_q &lt;= 0; } else { reg_q &lt;= reg_d; } }</p>
<p>always_comb { if (bool_a || (bool_b &amp;&amp; !bool_c) { x = 0b1; } else { x = 0b0; }</p>
<p>assign z = ((bool_a != bool_b) || bool_c) ? a : b; assign y = (a &amp; ~b) | c; </p>
<h1><a class="anchor" id="autotoc_md467"></a>
autotoc_md467</h1>
<p>:-1: </p>
<h1><a class="anchor" id="autotoc_md468"></a>
systemverilog {.bad}</h1>
<p>always_ff @(posedge clk_i or negedge rst_ni) { if (~rst_ni) { reg_q &lt;= 0; } else { reg_q &lt;= reg_d; } }</p>
<p>always_comb { if (bool_a | (bool_b &amp; ~bool_c) { x = 0b1; } else { x = 0b0; }</p>
<p>assign z = ((bool_a ^ bool_b) | bool_c) ? a : b; assign y = (a &amp;&amp; !b) || c; </p>
<h1><a class="anchor" id="autotoc_md469"></a>
autotoc_md469</h1>
<p>:+1: </p>
<h1><a class="anchor" id="autotoc_md470"></a>
systemverilog</h1>
<p>// allowed logical assignment for boolean test assign request_valid = !fifo_empty &amp;&amp; data_available;</p>
<p>always_comb { if (request_valid) { output_valid = 0b1; } else { output_valid = 0b0; } } </p>
<h1><a class="anchor" id="autotoc_md471"></a>
autotoc_md471</h1>
<h2><a class="anchor" id="autotoc_md472"></a>
Packed Ordering</h2>
<p><em><b>Bit vectors and packed arrays must be little-endian.</b></em></p>
<p>When declaring bit vectors and packed arrays, the index of the most-significant bound (left of the colon) must be greater than or equal to the least-significant bound (right of the colon).</p>
<p>This style of bit vector declaration keeps packed variables little-endian.</p>
<p>For example:</p>
<h1><a class="anchor" id="autotoc_md473"></a>
systemverilog</h1>
<p>typedef logic &lt;7:0&gt; u8_t; logic &lt;31:0&gt; u32_word; u8_t [2] u16_word; u8_t byte3, byte2, byte1, byte0; assign u16_word = {byte1, byte0}; assign u32_word = {byte3, byte2, u16_word}; </p>
<h1><a class="anchor" id="autotoc_md474"></a>
autotoc_md474</h1>
<h2><a class="anchor" id="autotoc_md475"></a>
Unpacked Ordering</h2>
<p><em><b>Unpacked arrays must be big-endian.</b></em></p>
<p>Declare unpacked arrays in big-endian fashion (for instance, [n:m] where n &lt;= m). Never declare an unpacked array in little-endian order, such as [size-1:0].</p>
<p>Declare zero-based unpacked arrays using the shorter notation [size]. It is understood that [size] is equivalent to the big-endian declaration [0:size-1].</p>
<h1><a class="anchor" id="autotoc_md476"></a>
systemverilog</h1>
<p>logic &lt;15:0&gt; word_array[3] = (word0, word1, word2); </p>
<h1><a class="anchor" id="autotoc_md477"></a>
autotoc_md477</h1>
<h2><a class="anchor" id="autotoc_md478"></a>
Finite State Machines</h2>
<p><em><b>State machines use an enum to define states, and be implemented with two process blocks: a combinational block and a clocked block.</b></em></p>
<p>Every state machine description has three parts:</p>
<ol type="1">
<li>An enum that declares and describes the states.</li>
</ol>
<ol type="1">
<li>A combinational process block that decodes state to produce next state and other combinational outputs.</li>
</ol>
<ol type="1">
<li>A clocked process block that updates state from next state.</li>
</ol>
<p><em>Enumerating States</em></p>
<p>The enum statement for the state machine should list each state in the state machine. Comments describing the states should be deferred to case statement in the combinational process block, below.</p>
<p>States should be named in UpperCamelCase, like other <a href="#enumerations">enumeration constants</a>.</p>
<p>Barring special circumstances, the idle state of the state machines will be named Idle or StIdle. (Alternate names are acceptable if they improve clarity.)</p>
<p>Ideally, each /** */ . more than one state machine, you will need to add a unique prefix (or suffix) to the states of each state machine, to distinguish which state is associated with which state machine. For example, a /** */ "" "writer" machine might have a StRdIdle state and a StWrIdle state.</p>
<p><em>Combinational Decode of State</em></p>
<p>The combinational process block should contain:</p>
<ul>
<li>A case statement that decodes state to produce next state and combinational outputs. For clarity, only cases where the output value deviates from the default should be coded.</li>
<li>Before the case statement should be a block of code that defines default values for every combinational output, including "next state."</li>
<li>The default value for the "next state" variable should be the current state. The case statement that decodes state will then only assign to "next state" when transitioning between states.</li>
<li>Within the case statement, each state alternative should be preceded with a comment that describes the of that state within the state machine.</li>
</ul>
<p><em>The State Register</em></p>
<p>No logic except for reset should be performed in this process. The state variable should latch the value of the "next state" variable.</p>
<p><em>Other Guidelines</em></p>
<p>When possible, try to choose state names that differ near the beginning of their name, to make them more readable when viewing waveform traces.</p>
<p><em>Example</em></p>
<p>&amp;#x1f44d() { </p>
<h1><a class="anchor" id="autotoc_md479"></a>
systemverilog {.good}</h1>
<p>// Define the states typedef enum { StIdle, StFrameStart, StDynInstrRead, StBandCorr, StAccStoreWrite, StBandEnd } alcor_state_e() {</p>
<p>alcor_state_e alcor_state_d, alcor_state_q;</p>
<p>// Combinational decode of the state always_comb { alcor_state_d = alcor_state_q; foo = 0b0; bar = 0b0; bum = 0b0; unique case (alcor_state_q) { // StIdle: waiting for frame_start StIdle: if (frame_start) { foo = 0b1; alcor_state_d = StFrameStart; } // StFrameStart: Reset accumulators StFrameStart: { // ... etc ... } // may be empty or used to catch parasitic states default: alcor_state_d = StIdle; } }</p>
<p>// Register the state always_ff @(posedge clk or negedge rst_n) { if (!rst_n) { alcor_state_q &lt;= StIdle; } else { alcor_state_q &lt;= alcor_state_d; } } </p>
<h1><a class="anchor" id="autotoc_md480"></a>
autotoc_md480</h1>
<h2><a class="anchor" id="autotoc_md481"></a>
Active-Low Signals</h2>
<p><em><b>The _n suffix indicates an active-low signal.</b></em></p>
<p>If active-low signals are used, they must have the _n suffix in their name. Otherwise, all signals are assumed to be active-high.</p>
<h2><a class="anchor" id="autotoc_md482"></a>
Differential Pairs</h2>
<p><em><b>Use the _p and _n suffixes to indicate a differential pair.</b></em></p>
<p>For example, in_p and in_n comprise a differential pair set.</p>
<h2><a class="anchor" id="autotoc_md483"></a>
Delays</h2>
<p><em><b>Signals delayed by a single clock cycle should } in a _q suffix.</b></em></p>
<p>If one signal is only a delayed version of another signal, the _q suffix should be used to indicate this relationship.</p>
<p>If another signal is then delayed by another clock cycle, the next signal should be identifed with the _q2 suffix, and then _q3 and so on.</p>
<p>Example:</p>
<h1><a class="anchor" id="autotoc_md484"></a>
systemverilog</h1>
<p>always_ff @(posedge clk) { data_valid_q &lt;= data_valid_d; data_valid_q2 &lt;= data_valid_q; data_valid_q3 &lt;= data_valid_q2; } </p>
<h1><a class="anchor" id="autotoc_md485"></a>
autotoc_md485</h1>
<h2><a class="anchor" id="autotoc_md486"></a>
Wildcard import of packages</h2>
<p>The wildcard import syntax, e.g. is only allowed where the package is part of the same IP as the /** */ . import statement must be placed in the /** */ .</p>
<p>&amp;#x1f44d() { </p>
<h1><a class="anchor" id="autotoc_md487"></a>
systemverilog {.good}</h1>
<p>// mod_a_pkg.sv and mod_a.sv are in the same IP. // Packages can be imported in the module declaration if access to // unqualified types is needed in the port list.</p>
<p>// mod_a_pkg.sv</p>
<p>typedef struct packed { ... } a_req_t;</p>
<p>// mod_a.sv /** */ import mod_a_pkg::*() { ( ... a_req_t a_req, ... );</p>
<p>} </p>
<h1><a class="anchor" id="autotoc_md488"></a>
autotoc_md488</h1>
<p>&amp;#x1f44d; </p>
<h1><a class="anchor" id="autotoc_md489"></a>
systemverilog {.good}</h1>
<p>// mod_a /** */ () {</p>
<p>// mod_a_pkg.sv and mod_a.sv are in the same IP.</p>
<p>...</p>
<p>a_req_t a_req;</p>
<p>} </p>
<h1><a class="anchor" id="autotoc_md490"></a>
autotoc_md490</h1>
<p>Other than the cases above, wildcard imports are not allowed. For instance, the example below may create a name collision in the /** */ in the source list.</p>
<p>&amp;#x1f44e() { </p>
<h1><a class="anchor" id="autotoc_md491"></a>
systemverilog {.bad}</h1>
<p>// mod_a.sv // not allowed: imported to $root scope.</p>
<p>/** */ () {</p>
<p>} </p>
<h1><a class="anchor" id="autotoc_md492"></a>
autotoc_md492</h1>
<p>Other bad examples:</p>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md493"></a>
systemverilog {.bad}</h1>
<p>// wildcard import for other packages outside of the IP /** */ () { </p>
<h1><a class="anchor" id="autotoc_md494"></a>
autotoc_md494</h1>
<p>&amp;#x1f44e; </p>
<h1><a class="anchor" id="autotoc_md495"></a>
systemverilog {.bad}</h1>
<p>/** */ () {</p>
<p>// not allowed: wildcard import of a package from a different IP</p>
<p>} </p>
<h1><a class="anchor" id="autotoc_md496"></a>
autotoc_md496</h1>
<h2><a class="anchor" id="autotoc_md497"></a>
Assertion Macros</h2>
<p>It is encouraged to use SystemVerilog assertions (SVAs) throughout the design to check functional correctness and flag invalid conditions. In order to increase productivity and keep the assertions short and concise, the following assertion macros can be used:</p>
<h1><a class="anchor" id="autotoc_md498"></a>
systemverilog</h1>
<p>// immediate assertion, to be placed within a process. ASSERT_I(&lt;name&gt;, &lt;property&gt;) // immediate assertion wrapped within an initial block. can be used for things // like parameter checking. ASSERT_INIT(&lt;name&gt;, &lt;property&gt;) // concurrent assertion to be used for functional assertions. ASSERT(&lt;name&gt;, &lt;property&gt;, &lt;clk&gt;, &lt;reset condition&gt;) // concurrent assertion that checks that a signal has a known value after reset // (i.e. that the signal is not <code>X</code>). ASSERT_KNOWN(&lt;name&gt;, &lt;signal&gt;, &lt;clk&gt;, &lt;reset condition&gt;) </p>
<h1><a class="anchor" id="autotoc_md499"></a>
autotoc_md499</h1>
<p>An implementation of these macros (including other useful variations thereof) can be found here: <a href="https://github.com/lowRISC/opentitan/blob/master/hw/ip/prim/rtl/prim_assert.sv">https://github.com/lowRISC/opentitan/blob/master/hw/ip/prim/rtl/prim_assert.sv</a></p>
<h3><a class="anchor" id="autotoc_md500"></a>
A Note on Security Critical Applications</h3>
<p>For security critical applications, the names of the assertion macros involved in guarding case statements and ternaries shall be postfixed with _SEC. This enables security-specific post-processing of these statements at a later stage in the design process. In terms of functionality these macros should be identical to the original assertions, i.e.,</p>
<h1><a class="anchor" id="autotoc_md501"></a>
systemverilog</h1>
<p>#define ASSERT_SEC ASSERT #define ASSERT_I_SEC ASSERT_I #define ASSERT_KNOWN_SEC ASSERT_KNOWN </p>
<h1><a class="anchor" id="autotoc_md502"></a>
autotoc_md502</h1>
<p>More security assertion and coding style guidance will be given in a separate document, soon.</p>
<h1><a class="anchor" id="autotoc_md503"></a>
Appendix - Condensed Style Guide</h1>
<p>This is a short summary of the Comportable style guide. Refer to the main text body for explanations examples, and exceptions.</p>
<h2><a class="anchor" id="autotoc_md504"></a>
Basic Style Elements</h2>
<ul>
<li>Use SystemVerilog-2012 conventions, files named as module.sv, one file per /** */</li>
<li>Only ASCII, <b>100</b> chars per line, <b>no</b> tabs, <b>two</b> spaces per indent for all paired keywords.</li>
<li>C++ style comments //`</li>
<li>For multiple items on a line, <b>one</b> space must separate the comma and the next character</li>
<li>Include <b>whitespace</b> around keywords and binary operators</li>
<li><b>No</b> space between case item and colon, /task/macro call and open parenthesis</li>
<li>Line wraps should indent by <b>four</b> spaces</li>
<li>{ must be on the same line as the preceding keyword and } the line</li>
<li>} must start a new line</li>
</ul>
<h2><a class="anchor" id="autotoc_md505"></a>
Construct Naming</h2>
<ul>
<li>Use <b>lower_snake_case</b> for instance names, signals, declarations, variables, types</li>
<li>Use <b>UpperCamelCase</b> for tunable parameters, enumerated value names</li>
<li>Use <b>ALL_CAPS</b> for constants and define macros</li>
<li>Main clock signal is named clk. All clock signals must start with clk_</li>
<li>Reset signals are <b>active-low</b> and <b>asynchronous</b>, default name is rst_n</li>
<li>Signal names should be descriptive and be consistent throughout the hierarchy</li>
</ul>
<h2><a class="anchor" id="autotoc_md506"></a>
Suffixes for signals and types</h2>
<ul>
<li>Add _i to /** */ , bi-directional /** */</li>
<li>The input (next state) of a registered signal should have _d and the output _q as suffix</li>
<li>Pipelined versions of signals should be named _q2, _q3, etc. to reflect their latency</li>
<li>Active low signals should use _n. When using differential signals use _p for active high</li>
<li>Enumerated types should be suffixed with _e</li>
<li>Multiple suffixes will not be separated with _. n should come first i, o, or io last</li>
</ul>
<h2><a class="anchor" id="autotoc_md507"></a>
Language features</h2>
<ul>
<li>Use <b>full port declaration style</b> for modules, any clock and reset declared first</li>
<li>Use <b>named parameters</b> for instantiation, all declared ports must be present, no .*</li>
<li>Top-level parameters is preferred over define globals</li>
<li>Use <b>symbolically named constants</b> instead of raw numbers</li>
<li>Local constants should be declared localparam, globals in a separate **.svh** file.</li>
<li>logic is preferred over reg and wire, declare all signals explicitly</li>
<li>always_comb, always_ff and always_latch are preferred over always</li>
<li>Interfaces are discouraged</li>
<li>Sequential logic must use <b>non-blocking</b> assignments</li>
<li>Combinational blocks must use <b>blocking</b> assignments</li>
<li>Use of latches is discouraged, use flip-flops when possible</li>
<li>The use of X assignments in RTL is strongly discouraged, make use of SVAs to check invalid behavior instead.</li>
<li>Prefer assign statements wherever practical.</li>
<li>Use unique case and always define a default case</li>
<li>Use available signed arithmetic constructs wherever signed arithmetic is used</li>
<li>When printing use 0b and 0x as a prefix for binary and hex. Use _ for clarity</li>
<li>Use logical constructs (i.e ||) for logical comparison, bit-wise (i.e |) for data comparison</li>
<li>Bit vectors and packed arrays must be little-endian, unpacked arrays must be big-endian</li>
<li>FSMs: <b>no logic</b> except for reset should be performed in the process for the state register</li>
<li>A combinational process should first define <b>default value</b> of all outputs in the process</li>
<li>Default value for next state variable should be the current state /** </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
