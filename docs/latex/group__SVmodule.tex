\hypertarget{group__SVmodule}{}\doxysection{Modules $\ast$/}
\label{group__SVmodule}\index{Modules $\ast$/@{Modules $\ast$/}}
\hypertarget{md_docs_style_guides_DVCodingStyle}{}\doxysubsubsection{low\+RISC System\+Verilog Coding Style Guide for Design Verification}\label{md_docs_style_guides_DVCodingStyle}
This document is a supplemental Style Guide to the \href{https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md}{\texttt{ low\+RISC Verilog style guide}}, with emphasis on writing code for Design Verification (DV) in System\+Verilog, following the \href{https://www.accellera.org/images//downloads/standards/uvm/uvm_users_guide_1.2.pdf}{\texttt{ UVM methodology}}.\hypertarget{group__SVmodule_autotoc_md1}{}\doxysubsection{Table of Contents}\label{group__SVmodule_autotoc_md1}

\begin{DoxyItemize}
\item \href{\#introduction}{\texttt{ Introduction}}
\item \href{\#naming-and-style}{\texttt{ Naming and Style}}
\item \href{\#directory-structure-and-packages}{\texttt{ Directory Structure and Packages}}
\begin{DoxyItemize}
\item \href{\#uvm_agent-directory-structure}{\texttt{ UVM Agent Directory Structure}}
\item \href{\#uvm_env-directory-structure}{\texttt{ UVM Env Directory Structure}}
\end{DoxyItemize}
\item \href{\#uvm-guidelines}{\texttt{ UVM Guidelines}}
\begin{DoxyItemize}
\item \href{\#class-definitions}{\texttt{ Class Definitions}}
\item \href{\#uvm-new-functions}{\texttt{ UVM new functions}}
\item \href{\#uvm_scoreboard-usage}{\texttt{ uvm\+\_\+scoreboard usage}}
\item \href{\#uvm_agent-usage}{\texttt{ uvm\+\_\+agent usage}}
\item \href{\#uvm_driver-usage}{\texttt{ uvm\+\_\+driver usage}}
\item \href{\#macro-usage}{\texttt{ Macro Usage}}
\begin{DoxyItemize}
\item \href{\#guidelines-for-uvm-library-macros}{\texttt{ Guidelines for UVM library macros}}
\item \href{\#guidelines-for-macros-within-dv_macrossvh}{\texttt{ Guidelines for macros within dv\+\_\+macros.\+svh}}
\item \href{\#general-macro-use-guidelines}{\texttt{ General macro use guidelines}}
\item \href{\#typical-gotchas-with-macro-usage}{\texttt{ Typical gotchas with macro usage}}
\end{DoxyItemize}
\item \href{\#factory}{\texttt{ Factory}}
\item \href{\#configuration-mechanism}{\texttt{ Configuration Mechanism}}
\item \href{\#sequences}{\texttt{ Sequences}}
\item \href{\#sequence-items}{\texttt{ Sequence Items}}
\item \href{\#ral-usage}{\texttt{ RAL Usage}}
\item \href{\#objections-and-coordinating-}-of-test}{\texttt{ Objections and Coordinating End of Test}}
\item \href{\#logging-and-print-messages}{\texttt{ Logging and Print Messages}}
\item \href{\#dpi-and-c-connections}{\texttt{ DPI and C Connections}}
\end{DoxyItemize}
\item \href{\#systemverilog-language-features}{\texttt{ System\+Verilog Language Features}}
\begin{DoxyItemize}
\item \href{\#-declarations}{\texttt{ Function Declarations}}
\item \href{\#randomization}{\texttt{ Randomization}}
\item \href{\#enums}{\texttt{ Enums}}
\item \href{\#interfaces,-clocking-blocks,-modports}{\texttt{ Interfaces, Clocking Blocks, Modports}}
\item \href{\#loop-operators}{\texttt{ Loop Operators}}
\item \href{\#code-within-asserts}{\texttt{ Code Within Asserts}}
\item \href{\#wait-and-fork}{\texttt{ Wait and Fork}}
\item \href{\#wait-and-non-forever-loop}{\texttt{ Wait And Non-\/\+Forever Loop}}
\item \href{\#void-casts}{\texttt{ Void Casts}}
\item \href{\#associative-arrays}{\texttt{ Associative Arrays}}
\item \href{\#bind-statements}{\texttt{ Bind Statements}}
\item \href{\#simulator-specific-code}{\texttt{ Simulator Specific Code}}
\item \href{\#forbidden-system-tasks-and-functions}{\texttt{ Forbidden System Tasks and Functions}}
\item \href{\#Backdoor Force and Probe in Chip-level}{\texttt{ Backdoor Force and Probe in Chip-\/level}}
\end{DoxyItemize}
\item \href{\#systemverilog-assertions}{\texttt{ System\+Verilog Assertions}}
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md2}{}\doxysubsection{Introduction}\label{group__SVmodule_autotoc_md2}
This guide defines the Comportable style for DV-\/specific System\+Verilog code. The goal is to use this common set of guidelines when implementing testbenches using the UVM methodology to allow all developed Comportable DV code to be uniform, reusable, and portable. This document assumes previous experience and working knowledge of UVM, and as such all included code snippets will be fairly concise.\hypertarget{group__SVmodule_autotoc_md3}{}\doxysubsection{Naming and Style}\label{group__SVmodule_autotoc_md3}
Refer to \href{https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md\#naming}{\texttt{ low\+RISC Verilog naming conventions}} for any general naming style guidelines. In general, common UVM testbench components must be declared and assigned handles as follows\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Testbench component   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Style    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Testbench component   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Style    }\\\cline{1-2}
\endhead
Virtual interfaces   &virtual $<$if\+\_\+name$>$\+\_\+if $<$if\+\_\+name$>$\+\_\+vif() \{    \\\cline{1-2}
Environment   &$<$dut$>$\+\_\+env env;    \\\cline{1-2}
Env level config object   &rand $<$dut$>$\+\_\+env\+\_\+cfg cfg;    \\\cline{1-2}
Env coverage collection object   &$<$dut$>$\+\_\+env\+\_\+cov cov;    \\\cline{1-2}
Agent   &$<$dut$>${\itshape agent m} $<$dut$>$\+\_\+agent;    \\\cline{1-2}
Agent level config object   &rand $<$dut$>${\itshape agent\+\_\+cfg m} $<$dut$>$\+\_\+agent\+\_\+cfg;    \\\cline{1-2}
Agent coverage collection object   &$<$dut$>$\+\_\+agent\+\_\+cov cov;    \\\cline{1-2}
Driver   &$<$dut$>$\+\_\+driver driver;    \\\cline{1-2}
Monitor   &$<$dut$>$\+\_\+monitor monitor;    \\\cline{1-2}
Scoreboard   &$<$dut$>$\+\_\+scoreboard scoreboard;    \\\cline{1-2}
Virtual sequencer   &$<$dut$>$\+\_\+virtual\+\_\+sequencer virtual\+\_\+sequencer;    \\\cline{1-2}
Sequencer   &$<$dut$>$\+\_\+sequencer $<$dut$>$\+\_\+sequencer;   \\\cline{1-2}
\end{longtabu}


Additional naming guidelines\+:


\begin{DoxyEnumerate}
\item The top level testbench file that instantiates the DUT must be named tb.\+sv. The testbench /$\ast$$\ast$ $\ast$/ , tb.\+sv must be dut. Using this standardized naming allows universal usage of any supporting DV sources (coverage cfg files, and so on).
\item When instantiating any objects, the name argument to type\+\_\+id\+::create() must match the name of the variable being assigned to. This ensures that any reporting messages refer to the right objects.
\item To avoid name collisions, it is recommended that global types and types defined within a package have unique prefixes. This includes typedefs, enumerated types/values, package parameters, package localparams, any functions/tasks, and macros. This prefixing is not necessary for any types defined within a class, module, or interface, as they will be scoped by the parent entity.
\item Note that all package variables (parameters, etc.) must have a specified type.
\item When instantiating a user-\/defined class member variable that is a class object, it is recommended (but not necessary) to follow this prefixing scheme\+:
\begin{DoxyItemize}
\item Prefix the instance name of the class object with m\+\_\+, as such\+:
\end{DoxyItemize}
\end{DoxyEnumerate}\hypertarget{group__SVmodule_autotoc_md4}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md4}
my\+\_\+animal m\+\_\+my\+\_\+animal() \{ \hypertarget{group__SVmodule_autotoc_md5}{}\doxysubsection{autotoc\+\_\+md5}\label{group__SVmodule_autotoc_md5}
This scheme does not apply to any class member variables that are not themselves class objects.


\begin{DoxyItemize}
\item If multiple instantiations of the class are desired without an array to store them, use $<$class\+\_\+name$>$ m\+\_\+ $<$instance\+\_\+name$>$ to declare a variable, and use an informative instance name.
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md6}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md6}
my\+\_\+animal m\+\_\+my\+\_\+cat \{ public\+: my\+\_\+animal m\+\_\+my\+\_\+dog; my\+\_\+animal m\+\_\+my\+\_\+fish; \hypertarget{group__SVmodule_autotoc_md7}{}\doxysubsection{autotoc\+\_\+md7}\label{group__SVmodule_autotoc_md7}

\begin{DoxyItemize}
\item If an array of class handles or logic is desired, choose a name such that it follows one of the following schemes\+:
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md8}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md8}
int NUM\+\_\+\+ANIMALS = 10 \{ public\+: // This plural convention is recommended, but both are equally acceptable my\+\_\+animal m\+\_\+my\+\_\+animals\mbox{[}NUM\+\_\+\+ANIMALS\mbox{]}; my\+\_\+animal m\+\_\+my\+\_\+animal\+\_\+array\mbox{[}NUM\+\_\+\+ANIMALS\mbox{]}; \hypertarget{group__SVmodule_autotoc_md9}{}\doxysubsection{autotoc\+\_\+md9}\label{group__SVmodule_autotoc_md9}
\hypertarget{group__SVmodule_autotoc_md10}{}\doxysubsection{Directory Structure and Packages}\label{group__SVmodule_autotoc_md10}
Define one class per file, and the filename should match the name of the class. The class files must be include-\/ed into the package file. Directory structure of the UVM agent and UVM environment testbench components along with their related files are shown below, with some additional guidance on declaring functions from a package context.\hypertarget{group__SVmodule_autotoc_md11}{}\doxysubsubsection{uvm\+\_\+agent directory structure}\label{group__SVmodule_autotoc_md11}

\begin{DoxyItemize}
\item All DV code for a particular agent will be placed under a single directory $<$block$>$\+\_\+agent/ separate from the DV code for the corresponding environment.
\item It is highly recommended that all agent directories be placed in a common area to create a repository of UVM agents that allows for more vertical reuse.
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md12}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md12}
$<$block$>$ class files \+\_\+agent/ $<$block$>$\+\_\+if.\+sv $<$block$>$\+\_\+item.\+sv $<$block$>$\+\_\+agent.\+sv $<$block$>$\+\_\+agent\+\_\+pkg.\+sv $<$block$>$\+\_\+agent\+\_\+cfg.\+sv $<$block$>$\+\_\+agent\+\_\+cov.\+sv $<$block$>$\+\_\+driver.\+sv $<$block$>$\+\_\+host\+\_\+driver.\+sv (Only if block requires a separate driver for host mode) $<$block$>$\+\_\+device\+\_\+driver.\+sv (Only if block requires a separate driver for device mode) $<$block$>$\+\_\+monitor.\+sv $<$block$>$\+\_\+sequencer.\+sv seq\+\_\+lib/ $<$block$>$\+\_\+base\+\_\+seq.\+sv \hypertarget{group__SVmodule_autotoc_md13}{}\doxysubsection{autotoc\+\_\+md13}\label{group__SVmodule_autotoc_md13}
\hypertarget{group__SVmodule_autotoc_md14}{}\doxysubsubsection{uvm\+\_\+env directory structure}\label{group__SVmodule_autotoc_md14}

\begin{DoxyItemize}
\item All DV code for the UVM environment, UVM tests, and top level block testbench will be placed in a directory $<$dut$>$/dv/ in three corresponding subdirectories $<$dut$>$/dv/env/, $<$dut$>$/dv/tests/, $<$dut$>$/dv/tb/.
\item The $<$dut$>$\+\_\+env\+\_\+pkg should import the $<$dut$>$\+\_\+agent\+\_\+pkg.
\item All UVM virtual sequences for a given DUT will be placed under env/seq\+\_\+lib/, along with a $<$dut$>$\+\_\+vseq\+\_\+list.\+sv file that include-\/es all of the virtual sequence files. This virtual sequence list file must be include-\/ed by env/$<$dut$>$\+\_\+env\+\_\+pkg.\+sv.
\item If applicable, env/$<$dut$>$\+\_\+env\+\_\+pkg.\+sv must import the $<$dut$>$\+\_\+agent\+\_\+pkg.
\item tests/$<$dut$>$\+\_\+test\+\_\+pkg.\+sv must import the $<$dut$>$\+\_\+env\+\_\+pkg package.
\item All files include-\/ed into a single package must be in the same single directory.
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md15}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md15}
$<$dut$>$/dv/ env/ $<$dut$>$\+\_\+env.\+sv $<$dut$>$\+\_\+env\+\_\+pkg.\+sv $<$dut$>$\+\_\+env\+\_\+cfg.\+sv $<$dut$>$\+\_\+env\+\_\+cov.\+sv $<$dut$>$\+\_\+scoreboard.\+sv $<$dut$>$\+\_\+virtual\+\_\+sequencer.\+sv seq\+\_\+lib/ // These allow basic functionality to be added to the environment $<$dut$>$\+\_\+base\+\_\+vseq.\+sv $<$dut$>$\+\_\+sanity\+\_\+vseq.\+sv tb/ tb.\+sv tests/ $<$dut$>$\+\_\+base\+\_\+test.\+sv $<$dut$>$\+\_\+test\+\_\+pkg.\+sv \hypertarget{group__SVmodule_autotoc_md16}{}\doxysubsection{autotoc\+\_\+md16}\label{group__SVmodule_autotoc_md16}
$<$block$>$\+\_\+agent\+\_\+pkg.\+sv, $<$dut$>$\+\_\+env\+\_\+pkg.\+sv, $<$dut$>$\+\_\+test\+\_\+pkg.\+sv, and tb/tb.\+sv must include these include-\/es and imports\+:\hypertarget{group__SVmodule_autotoc_md17}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md17}
\#include \char`\"{}dv\+\_\+macros.\+svh\char`\"{} \#include \char`\"{}uvm\+\_\+macros.\+svh\char`\"{}\hypertarget{group__SVmodule_autotoc_md18}{}\doxysubsection{autotoc\+\_\+md18}\label{group__SVmodule_autotoc_md18}
An example environment level package file for an arbitrary block newblock should look similar to this\+:\hypertarget{group__SVmodule_autotoc_md19}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md19}
// dep packages

// macro includes \#include \char`\"{}uvm\+\_\+macros.\+svh\char`\"{} \#include \char`\"{}dv\+\_\+macros.\+svh\char`\"{}

// define any parameters parameter int NEW\+\_\+\+BLOCK\+\_\+\+PARAMETER = 10 \{ public\+:

// define any local types/functions/tasks typedef enum \{ Newblock\+Boolean\+Zero, Newblock\+Boolean\+True \} newblock\+\_\+boolean\+\_\+e;

// Functions declared within packages must be automatic automatic bit newblock\+\_\+test\+\_\+function(newblock\+\_\+boolean\+\_\+e test\+\_\+boolean) \{ //function definition \}\hypertarget{group__SVmodule_autotoc_md20}{}\doxysubsection{autotoc\+\_\+md20}\label{group__SVmodule_autotoc_md20}
\hypertarget{group__SVmodule_autotoc_md21}{}\doxysubsection{UVM Guidelines}\label{group__SVmodule_autotoc_md21}
Always call run\+\_\+test() without the test name argument. This allows command line test overrides to be performed using +UVM\+\_\+\+TESTNAME=$<$testname$>$ without having to recompile and allows testlists to be created for regression runs.\hypertarget{group__SVmodule_autotoc_md22}{}\doxysubsubsection{Class Definitions}\label{group__SVmodule_autotoc_md22}

\begin{DoxyEnumerate}
\item After variable declarations, register any objects and components with the factory using the uvm\+\_\+component\+\_\+utils and uvm\+\_\+object\+\_\+utils macros.
\begin{DoxyItemize}
\item Declare any member variables to be registered with the UVM factory field automation macros uvm\+\_\+field\+\_\+int, uvm\+\_\+field\+\_\+enum, uvm\+\_\+field\+\_\+object, uvm\+\_\+field\+\_\+array\+\_\+int, etc. within uvm\+\_\+object/component\+\_\+utils\+\_\+begin and uvm\+\_\+object/component\+\_\+utils\+\_\+end.
\end{DoxyItemize}
\item For all field automation macros, use UVM\+\_\+\+DEFAULT as the flag argument. For example, if it is desired that everything except comparing and printing be enabled for some rx\+\_\+delay field, the macro would look like this\+:
\end{DoxyEnumerate}\hypertarget{group__SVmodule_autotoc_md23}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md23}
uvm\+\_\+field\+\_\+int(rx\+\_\+delay, UVM\+\_\+\+DEFAULT $\vert$ UVM\+\_\+\+NOCOMPARE $\vert$ UVM\+\_\+\+NOPRINT) \hypertarget{group__SVmodule_autotoc_md24}{}\doxysubsection{autotoc\+\_\+md24}\label{group__SVmodule_autotoc_md24}

\begin{DoxyEnumerate}
\item After factory registration, a constructor must be defined. Use the uvm\+\_\+object\+\_\+new macro for UVM objects and the uvm\+\_\+component\+\_\+new macro for UVM components. Both of these macros are defined in \mbox{\hyperlink{dv__macros_8svh}{dv\+\_\+macros.\+svh}}.
\item Any constructors written manually should contain a call to super.\+new(name \mbox{[},parent\mbox{]}) as the first line. Any other lines in the constructor are optional.
\item Do not add any extra arguments to the constructor other than name and parent.
\item All objects should generally be instantiated in the build\+\_\+phase() for components, or in the beginning of the body() task for sequences, unless there is a good reason not to. This is to enable proper usage of uvm\+\_\+factory overrides.
\item When extending any user-\/defined component class, super.$<$phase\+\_\+name$>$\+\_\+phase must be called for every phase method that is being overridden.
\item Transaction classes are usually logical representations of the data communicated over one or more interfaces executing a particular protocol. These classes\+:
\begin{DoxyItemize}
\item Should extend uvm\+\_\+sequence\+\_\+item.
\item Should contain only information that is relevant to the data being transmitted over an interface, and not to the means of transmit.
\item Should result in a legal transaction when randomized.
\end{DoxyItemize}
\end{DoxyEnumerate}\hypertarget{group__SVmodule_autotoc_md25}{}\doxysubsubsection{UVM new() functions}\label{group__SVmodule_autotoc_md25}
The new() of any class derived from uvm\+\_\+object must have the default value of its name argument set to \char`\"{}\char`\"{}, since the default name argument will be set by type\+\_\+id\+::create(). The new() of any class not derived from uvm\+\_\+object must not have default values set for its arguments. Examples\+:

\+:+1\+: \hypertarget{group__SVmodule_autotoc_md26}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md26}
// class derived from uvm\+\_\+object with correct default value new (string name = \char`\"{}\char`\"{}) \{ public\+: super.\+new(name) \{ \}

// class derived from uvm\+\_\+component with no default values new(string name, uvm\+\_\+component parent) \{ super.\+new(name, parent); \} \hypertarget{group__SVmodule_autotoc_md27}{}\doxysubsection{autotoc\+\_\+md27}\label{group__SVmodule_autotoc_md27}
\+:-\/1\+: \hypertarget{group__SVmodule_autotoc_md28}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md28}
// Incorrect default value used for class derived from uvm\+\_\+object new(string name = \char`\"{}my\+\_\+rand\+\_\+seq\char`\"{}) \{ super.\+new(name); \}

// Incorrect because default values for class derived from uvm\+\_\+component are provided new(string name = \char`\"{}\char`\"{}, uvm\+\_\+component parent) \{ super.\+new(name, parent); \} \hypertarget{group__SVmodule_autotoc_md29}{}\doxysubsection{autotoc\+\_\+md29}\label{group__SVmodule_autotoc_md29}
\hypertarget{group__SVmodule_autotoc_md30}{}\doxysubsubsection{uvm\+\_\+scoreboard usage}\label{group__SVmodule_autotoc_md30}
Use uvm\+\_\+tlm\+\_\+analysis\+\_\+fifo -\/ can be directly connected to analysis ports, and has an unbounded size so that writes will always succeed without blocking, in situations where transactions need to be stored for some time before being consumed by the scoreboard for processing.\hypertarget{group__SVmodule_autotoc_md31}{}\doxysubsubsection{uvm\+\_\+agent usage}\label{group__SVmodule_autotoc_md31}

\begin{DoxyEnumerate}
\item Interface agents should contain only a sequencer, driver, monitor, and config object.
\item Use one agent for every /$\ast$$\ast$ $\ast$/ , driver whose instantiation is determined by the value of $<$agent\+\_\+cfg$>$.is\+\_\+active. This is placed in the agent config object to allow for better access throughout the testbench.
\item For any DUT interfaces that have multiple operation modes (such as host and device modes), two drivers should be created, one for each mode, and arbitration done in the uvm\+\_\+agent\+::build\+\_\+phase to determine which driver to instantiate. Each driver should have different sequences that correspond to it.
\end{DoxyEnumerate}\hypertarget{group__SVmodule_autotoc_md32}{}\doxysubsubsection{uvm\+\_\+driver usage}\label{group__SVmodule_autotoc_md32}

\begin{DoxyEnumerate}
\item A driver must only communicate with one sequencer on one System\+Verilog interface, and should not have any analysis ports.
\item A driver should not randomize any data received from transaction items sent through analysis ports.
\item A driver must assign X to any buses it controls during \char`\"{}don\textquotesingle{}t-\/care\char`\"{} clock cycles in which no valid transaction is present.
\end{DoxyEnumerate}\hypertarget{group__SVmodule_autotoc_md33}{}\doxysubsubsection{Macro Usage}\label{group__SVmodule_autotoc_md33}
The UVM library provides several macros as shortcuts for commonly used sequences of code. In addition to this, the provided \mbox{\hyperlink{dv__macros_8svh}{dv\+\_\+macros.\+svh}} file defines other utility macros for even more common code sequences.\hypertarget{group__SVmodule_autotoc_md34}{}\doxyparagraph{Guidelines for UVM library macros}\label{group__SVmodule_autotoc_md34}

\begin{DoxyEnumerate}
\item All lowercase uvm\+\_\+... expressions denote library macros, and do not require trailing semicolons.
\item uvm\+\_\+object\+\_\+$\ast$ and uvm\+\_\+component\+\_\+$\ast$ macros
\begin{DoxyItemize}
\item Use these macros to register classes with the uvm\+\_\+factory.
\end{DoxyItemize}
\item uvm\+\_\+field\+\_\+$\ast$ macros
\begin{DoxyItemize}
\item Use these macros for members of sequence items. While these macros implement expensive versions of common functions required for sequence items, the overhead is generally not worth implementing custom versions for every sequence item. Additionally, these macros add a great deal of readability and help avoid coding mistakes with custom implementations. Only implement custom versions of these macros if performance becomes a very noticeable issue. Do not use these macros with classes derived from uvm\+\_\+component.
\end{DoxyItemize}
\item Do not use uvm\+\_\+do macros. Instead, start sequence items on a sequencer using the following high level steps\+:
\begin{DoxyItemize}
\item start\+\_\+item($<$sequence\+\_\+item$>$, $<$priority$>$).
\item Randomize the sequence item.
\item finish\+\_\+item($<$sequence\+\_\+item$>$, $<$priority$>$).
\item get\+\_\+response($<$response$>$).
\end{DoxyItemize}
\end{DoxyEnumerate}\hypertarget{group__SVmodule_autotoc_md35}{}\doxyparagraph{Guidelines for macros within dv\+\_\+macros.\+svh}\label{group__SVmodule_autotoc_md35}

\begin{DoxyEnumerate}
\item UVM print macros -\/ gfn, gtn, gn, gmv
\begin{DoxyItemize}
\item These macros provide a concise wrapper for get\+\_\+full\+\_\+name(), get\+\_\+type\+\_\+name(), get\+\_\+name(), and uvm\+\_\+reg.\+get\+\_\+mirrored\+\_\+value(), respectively. By using these it is possible to drastically reduce line length and improve readability.
\end{DoxyItemize}
\item \mbox{\hyperlink{dv__macros_8svh_a45c58ac39ea4e044893b8f611f335723}{downcast($<$extended\+\_\+class\+\_\+handle$>$, $<$base\+\_\+class\+\_\+handle$>$)}}
\begin{DoxyItemize}
\item Use this macro to cast a handle for any base class object that contains a handle to an extended class to the extended class type, useful for situations that require polymorphism.
\end{DoxyItemize}
\item uvm\+\_\+object\+\_\+new and uvm\+\_\+component\+\_\+new
\begin{DoxyItemize}
\item Use these macros to include the new() constructor for classes derived from uvm\+\_\+object and uvm\+\_\+component, respectively. If any additional logic must be included in the constructor, these macros must not be used, and a constructor must be written manually.
\end{DoxyItemize}
\item uvm\+\_\+create\+\_\+obj and uvm\+\_\+create\+\_\+comp
\begin{DoxyItemize}
\item Use these macros to call create($<$instance\+\_\+name$>$) and create($<$instance\+\_\+name$>$, this), respectively.
\end{DoxyItemize}
\item DV\+\_\+\+CHECK\+\_\+$\ast$ comparison checking macros
\begin{DoxyItemize}
\item These macros must be used to perform checks on the input arguments and invoke one of the uvm\+\_\+info, uvm\+\_\+error, or uvm\+\_\+fatal reporting macros if the check fails. These are much more concise than hand-\/writing the comparison checks and the corresponding UVM report macro and provide efficient readability.
\item The severity of the invoked report macro can be specified with the $<$uvm\+\_\+severity$>$ argument, the default reporting macro is uvm\+\_\+error.
\item Append {\itshape FATAL to the \} of these macro names to invoke variants of these macros that will automatically throw fatal errors upon check failure (e.\+g. DV\+\_\+\+CHECK\+\_\+\+EQ\+\_\+\+FATAL, DV\+\_\+\+CHECK\+\_\+\+LE\+\_\+\+FATAL, etc..).}
\end{DoxyItemize}
\item {\itshape  Randomization macros
\begin{DoxyItemize}
\item \mbox{\hyperlink{dv__macros_8svh}{dv\+\_\+macros.\+svh}} provides three sets of macros which must be used for all randomization functionality\+:
\begin{DoxyItemize}
\item DV\+\_\+\+CHECK\+\_\+\+RANDOMIZE\+\_\+\+FATAL -\/ Shorthand for foo.\+randomize() with a uvm\+\_\+fatal check.
\item DV\+\_\+\+CHECK\+\_\+\+STD\+\_\+\+RANDOMIZE\+\_\+\+FATAL -\/ Shorthand for std\+::randomize(foo) with a uvm\+\_\+fatal check.
\item DV\+\_\+\+CHECK\+\_\+\+MEMBER\+\_\+\+RANDOMIZE\+\_\+\+FATAL -\/ Shorthand for this.\+randomize(foo) with a uvm\+\_\+fatal check.
\end{DoxyItemize}
\item Variants of all three macros that allow constraints to be specified also exist, these macros are invoked by inserting WITH into the macro name\+: DV...\+\_\+\+RANDOMIZE\+\_\+\+WITH\+\_\+\+FATAL.
\end{DoxyItemize}}
\item {\itshape  DV\+\_\+\+EOT\+\_\+\+PRINT\+\_\+...\+\_\+\+CONTENTS TLM fifo display macros
\begin{DoxyItemize}
\item It is recommended to use these macros to display the status of the various TLM fifos and queues in the scoreboard at the \} of the test to ensure that those data structures have been emptied. There should be no pending transactions that have not yet been compared before the simulation ends. If used, these macros must be used during the check\+\_\+phase.
\end{DoxyItemize}}
\item {\itshape  DV\+\_\+\+SPINWAIT
\begin{DoxyItemize}
\item It is recommended to use this macro in situations that require an isolation fork to disable some process after waiting for a specified amount of time, as it provides proper process isolation such as the example below\+:
\end{DoxyItemize}}
\end{DoxyEnumerate}

{\itshape }\hypertarget{group__SVmodule_autotoc_md36}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md36}
{\itshape  // forked threads should be labeled if they serve a specific purpose, // like the isolation thread below fork \+: isolation\+\_\+fork \{ fork \{ $<$specified code to execute$>$ \} \{ $<$watchdog timer logic with error reporting$>$ \} join\+\_\+any disable fork() \{ \} join }\hypertarget{group__SVmodule_autotoc_md37}{}\doxysubsection{autotoc\+\_\+md37}\label{group__SVmodule_autotoc_md37}
{\itshape  }\hypertarget{group__SVmodule_autotoc_md38}{}\doxyparagraph{General macro use guidelines}\label{group__SVmodule_autotoc_md38}
{\itshape 
\begin{DoxyEnumerate}
\item Macro Naming\+:
\begin{DoxyItemize}
\item If the macro wraps some fundamental UVM functionality and deals directly with UVM functions, like uvm\+\_\+component\+\_\+new, and so on, the macro must be named all in lower\+\_\+snake\+\_\+case.
\item If the macro expands into a block of code that does not deal directly with UVM functionality, and is for convenience, like the DV\+\_\+\+CHECK\+\_\+$\ast$ macros, the macro must be named in UPPER\+\_\+\+SNAKE\+\_\+\+CASE.
\end{DoxyItemize}
\item Macro vs. Parameters\+:
\begin{DoxyItemize}
\item If the intent is to define a constant that is a basic data typename or that is the result of an expression involving basic data types, a parameter (or localparam) must be used, depending on where the constants are being defined.
\item If the intent is to abstract away a code snippet or to represent a slice of an array, a macro must be used. If the macro is defined in a local perspective, it must be undefined at the \} of the file, otherwise it will pollute the global namespace.
\end{DoxyItemize}
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md39}{}\doxyparagraph{Typical gotchas with macro usage\+:}\label{group__SVmodule_autotoc_md39}
{\itshape  While it is better to avoid macros altogether, they do make our lives easier by shortening pieces of repeated code, in a manner that cannot be achieved with a or a task. In general, the following describes the best practices to avoid common gotchas with macro usage.}

{\itshape 
\begin{DoxyEnumerate}
\item Always wrap macro arguments in parentheses. If the macro evaluates to an expression, also wrap the whole expansion in parentheses.\+The following example illustrates how failing to do this can cause an unexpected behavior.

\+:-\/1\+: 
\end{DoxyEnumerate}}\hypertarget{group__SVmodule_autotoc_md40}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md40}
{\itshape  \#define AND(a, b) a \&\& b}

{\itshape  assign x = AND(p $\vert$$\vert$ q, r) $\vert$$\vert$ s \{ public\+: // Bad\+: Wrong operator precedence! This results in\+: p $\vert$$\vert$ (q \&\& r) $\vert$$\vert$ s // which is not equal to ((p $\vert$$\vert$ q) \&\& r) $\vert$$\vert$ s. }\hypertarget{group__SVmodule_autotoc_md41}{}\doxysubsection{autotoc\+\_\+md41}\label{group__SVmodule_autotoc_md41}
{\itshape  \+:+1\+: }\hypertarget{group__SVmodule_autotoc_md42}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md42}
{\itshape  \#define AND(a, b) ((a) \&\& (b))}

{\itshape  assign x = AND(p $\vert$$\vert$ q, r) $\vert$$\vert$ s() \{ // Good\+: Output in-\/line with the expectation. }\hypertarget{group__SVmodule_autotoc_md43}{}\doxysubsection{autotoc\+\_\+md43}\label{group__SVmodule_autotoc_md43}
{\itshape 
\begin{DoxyEnumerate}
\item Macro usage scope and avoiding namespace collisions.

Macros have a global scope regardless of where they are defined. Once compiled, they are visible to ALL subsequent sources in the same compilation unit as well as to all subsequent compilation units. Hence, care must be taken to prevent macro re-\/definitions. Some tools do not even warn about name collisions, causing unnecessary debug overhead.
\begin{DoxyItemize}
\item Macro names must be appropriately prefixed with a thematically chosen string. It is typical to use the file name or the package name as the prefix string for all macros defined within that source.

\+:-\/1\+: 
\end{DoxyItemize}
\end{DoxyEnumerate}}\hypertarget{group__SVmodule_autotoc_md44}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md44}
{\itshape  // file\+: dv\+\_\+macros.\+h \#define STRINGIFY(s) \#s // Bad\+: UVM library code also defines a macro with the same name. // Depending on the tool, this may be flagged as an error. }\hypertarget{group__SVmodule_autotoc_md45}{}\doxysubsection{autotoc\+\_\+md45}\label{group__SVmodule_autotoc_md45}
{\itshape  \+:+1\+: }\hypertarget{group__SVmodule_autotoc_md46}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md46}
{\itshape  // file\+: dv\+\_\+macros.\+h \#define \mbox{\hyperlink{dv__macros_8svh_a8a32c3b2aaef1021af8464139b0d1756}{DV\+\_\+\+STRINGIFY(s)}} \#s }\hypertarget{group__SVmodule_autotoc_md47}{}\doxysubsection{autotoc\+\_\+md47}\label{group__SVmodule_autotoc_md47}
{\itshape 
\begin{DoxyItemize}
\item If the scope of the macros defined are global in nature (useful for the entire testbench), then place them in a separate System\+Verilog header file with ifndef guards. It must only contain macro definitions and nothing else. The file name must be suffixed with \+\_\+macros and have the .svh extension to denote that it is a header file.

\+:-\/1\+: 
\end{DoxyItemize}}\hypertarget{group__SVmodule_autotoc_md48}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md48}
{\itshape  // file\+: dv\+\_\+macros.\+h automatic void get\+\_\+nco() \{ ... \} // Bad\+: Putting functions and tasks in a header file that is potentially // included multiple times.}

{\itshape  \#define DV\+\_\+\+FOO(...) ... // Bad\+: No ifndef guard. Macro re-\/definition warnings will be thrown if // this header file is included in multiple sources. }\hypertarget{group__SVmodule_autotoc_md49}{}\doxysubsection{autotoc\+\_\+md49}\label{group__SVmodule_autotoc_md49}
{\itshape  \+:+1\+: }\hypertarget{group__SVmodule_autotoc_md50}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md50}
{\itshape  // file\+: \mbox{\hyperlink{dv__macros_8svh}{dv\+\_\+macros.\+svh}} \#ifndef DV\+\_\+\+FOO \#define DV\+\_\+\+FOO(...) ... \#endif}

{\itshape  \#ifndef DV\+\_\+\+BAR \#define DV\+\_\+\+BAR xyz \#endif }\hypertarget{group__SVmodule_autotoc_md51}{}\doxysubsection{autotoc\+\_\+md51}\label{group__SVmodule_autotoc_md51}
{\itshape 
\begin{DoxyItemize}
\item If the scope of the macros defined is limited to a package or source (individual interface, /$\ast$$\ast$ $\ast$/ ), the file. Always undef them at the \} of the file so that they are no longer visible to subsequent sources during compilation. Do not put ifndef guards on these macros, so that the re-\/definitions if encountered, are flagged.

\+:-\/1\+: 
\end{DoxyItemize}}\hypertarget{group__SVmodule_autotoc_md52}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md52}
{\itshape  // file\+: foo\+\_\+init\+\_\+seq.\+sv \#ifndef GET\+\_\+\+DATA \#define GET\+\_\+\+DATA(baz) ... \#endif // Bad\+: Macro-\/redefinition if encountered, will be ignored due to the // ifndef guard. Previously defined macro is invoked instead. // Bad\+: Macro name is not specific enough.}

{\itshape  class foo\+\_\+init\+\_\+seq() \{ ... \}; // EOF // Bad\+: Macro is not undefined at the end of the file. }\hypertarget{group__SVmodule_autotoc_md53}{}\doxysubsection{autotoc\+\_\+md53}\label{group__SVmodule_autotoc_md53}
{\itshape  \+:+1\+: }\hypertarget{group__SVmodule_autotoc_md54}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md54}
{\itshape  // file\+: foo\+\_\+init\+\_\+seq.\+sv \#define GET\+\_\+\+FOO\+\_\+\+TX\+\_\+\+FIFO\+\_\+\+DATA\+\_\+\+AFTER\+\_\+\+OP(baz) ...}

{\itshape  class foo\+\_\+init\+\_\+seq \{ public\+: ... \};}

{\itshape  \#undef GET\+\_\+\+FOO\+\_\+\+TX\+\_\+\+FIFO\+\_\+\+DATA\+\_\+\+AFTER\+\_\+\+OP }\hypertarget{group__SVmodule_autotoc_md55}{}\doxysubsection{autotoc\+\_\+md55}\label{group__SVmodule_autotoc_md55}
{\itshape  \+:+1\+: }\hypertarget{group__SVmodule_autotoc_md56}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md56}
{\itshape  // file\+: foo\+\_\+env\+\_\+pkg.\+sv \#define GET\+\_\+\+FOO\+\_\+\+TX\+\_\+\+FIFO\+\_\+\+DATA(baz) ...}

{\itshape  ...}

{\itshape  // Package sources \#include \char`\"{}foo\+\_\+env\+\_\+cfg.\+sv\char`\"{} ... \#include \char`\"{}foo\+\_\+scoreboard.\+sv\char`\"{} \#include \char`\"{}foo\+\_\+env.\+sv\char`\"{}}

{\itshape \begin{DoxyVerb}    #undef GET_FOO_TX_FIFO_DATA
    // Good: Only the package sources can invoke this macro. It is not
             visible in any other code.
    ##
\end{DoxyVerb}

\begin{DoxyEnumerate}
\item Wrap macros that resolve to multiple statements within \{ and \}.

Multi-\/statement macros are typically problematic when invoked in a single line conditional expression without \{..\}. It is better to preempt this bug by wrapping the macro definition itself in \{..\}.

\+:-\/1\+: 
\end{DoxyEnumerate}}\hypertarget{group__SVmodule_autotoc_md57}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md57}
{\itshape  \#define UPDATE\+\_\+\+VALUES(a, b) \textbackslash{} a = 88; \textbackslash{} b = 1955;}

{\itshape  if (power\+\_\+gw == 1.\+21) UPDATE\+\_\+\+VALUES(speed, year) // Great Scott! The year is unconditionally set to 1955. }\hypertarget{group__SVmodule_autotoc_md58}{}\doxysubsection{autotoc\+\_\+md58}\label{group__SVmodule_autotoc_md58}
{\itshape  \+:+1\+: }\hypertarget{group__SVmodule_autotoc_md59}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md59}
{\itshape  \#define UPDATE\+\_\+\+VALUES(a, b) \textbackslash{} \{ \textbackslash{} a = 88; \textbackslash{} b = 1955; \textbackslash{} \}}

{\itshape  if (power\+\_\+gw == 1.\+21) UPDATE\+\_\+\+VALUES(speed, year) // Good\+: Both values are set only if the condition is met. }\hypertarget{group__SVmodule_autotoc_md60}{}\doxysubsection{autotoc\+\_\+md60}\label{group__SVmodule_autotoc_md60}
{\itshape  Please see this \href{https://www.veripool.org/papers/Preproc_Good_Evil_SNUGBos10_pres.pdf}{\texttt{ paper}} for more details and examples.}

{\itshape }\hypertarget{group__SVmodule_autotoc_md61}{}\doxysubsubsection{Factory}\label{group__SVmodule_autotoc_md61}
{\itshape  To use the UVM factory, these guidelines should be followed\+:}

{\itshape 
\begin{DoxyEnumerate}
\item All classes must be registered with the factory. Use the uvm\+\_\+object\+\_\+utils and uvm\+\_\+component\+\_\+utils macros to register all non-\/parameterized classes, and use uvm\+\_\+object\+\_\+param\+\_\+utils and uvm\+\_\+component\+\_\+param\+\_\+utils to register all parameterized classes.
\item The create() API must be used to create all objects and components. Exceptions for this rule are any TLM related objects and covergroup objects, which should be created by directly calling new(), as they should not be registered with the factory.
\item When using the factory to create objects with $<$type\+\_\+name$>$\+::type\+\_\+id\+::create(), the $<$type\+\_\+name$>$ must be explicitly declared, parameters representing types must not be used here.
\item When using the factory to create objects, it is recommended to use the same name for both the name of the object and the variable used as a handle to the object to prevent unnecessary confusion from error messages.
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md62}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md62}
{\itshape  // create a single agent m\+\_\+myblock\+\_\+agent = myblock\+\_\+agent\+::type\+\_\+id\+::create(\char`\"{}m\+\_\+myblock\+\_\+agent\char`\"{}, this) \{ }\hypertarget{group__SVmodule_autotoc_md63}{}\doxysubsection{autotoc\+\_\+md63}\label{group__SVmodule_autotoc_md63}
{\itshape 
\begin{DoxyEnumerate}
\item When using the factory to create an array of objects, decorate the name of the object in the create() call with the index of the object in the array.
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md64}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md64}
{\itshape  // create an array of objects foreach (myobject\+\_\+array\mbox{[}i\mbox{]}) \{ myobject\+\_\+array\mbox{[}i\mbox{]} = myobject\+::type\+\_\+id\+::create(\$sformatf(\char`\"{}myobject\+\_\+array\mbox{[}\%0d\mbox{]}\char`\"{}, i), this); \} }\hypertarget{group__SVmodule_autotoc_md65}{}\doxysubsection{autotoc\+\_\+md65}\label{group__SVmodule_autotoc_md65}
{\itshape 
\begin{DoxyEnumerate}
\item For classes derived from uvm\+\_\+component, the parent argument should be the keyword this, so that the object hierarchy can be built correctly.
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md66}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md66}
{\itshape  m\+\_\+axi\+\_\+driver = axi\+\_\+driver\+::type\+\_\+id\+::create(\char`\"{}m\+\_\+axi\+\_\+driver\char`\"{}, this); }\hypertarget{group__SVmodule_autotoc_md67}{}\doxysubsection{autotoc\+\_\+md67}\label{group__SVmodule_autotoc_md67}
{\itshape 
\begin{DoxyEnumerate}
\item For classes derived from uvm\+\_\+object, use gfn as part of the name argument to append the full hierachy name, since uvm\+\_\+object hierarchies are not automatically built. Note that this only applies to class instances that are not instantiated within a uvm\+\_\+component in the test hierarchy, as in this case the full hierarchy name will already be provided.
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md68}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md68}
{\itshape  m\+\_\+my\+\_\+txn = my\+\_\+txn\+::type\+\_\+id\+::create(\{gfn, \char`\"{}.\+m\+\_\+my\+\_\+txn\char`\"{}\}) \{ public\+: }\hypertarget{group__SVmodule_autotoc_md69}{}\doxysubsection{autotoc\+\_\+md69}\label{group__SVmodule_autotoc_md69}
{\itshape 
\begin{DoxyEnumerate}
\item All typename or instance overrides must be in place before creating the class instance. Factory usage examples\+:
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md70}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md70}
{\itshape  // Override all drivers in testbench with my\+\_\+driver factory.\+set\+\_\+type\+\_\+override\+\_\+by\+\_\+type(current\+\_\+driver\+::get\+\_\+type(), my\+\_\+driver\+::get\+\_\+type()) \{ public\+:}

{\itshape  // Override all drivers in testbench with my\+\_\+driver -\/ alternative syntax current\+\_\+driver\+::type\+\_\+id\+::set\+\_\+type\+\_\+override(my\+\_\+driver\+::get\+\_\+type());}

{\itshape  // Override specific instance of current\+\_\+driver with my\+\_\+driver factory.\+set\+\_\+inst\+\_\+override\+\_\+by\+\_\+type(\char`\"{}env1.\+m\+\_\+agent1.\+driver\char`\"{}, current\+\_\+driver\+::get\+\_\+type(), my\+\_\+driver\+::get\+\_\+type());}

{\itshape  // Override specific instance of current driver -\/ alternative syntax current\+\_\+driver\+::type\+\_\+id\+::set\+\_\+inst\+\_\+override(my\+\_\+driver\+::get\+\_\+type(), \char`\"{}env.\+m\+\_\+agent1.\+driver\char`\"{}); }\hypertarget{group__SVmodule_autotoc_md71}{}\doxysubsection{autotoc\+\_\+md71}\label{group__SVmodule_autotoc_md71}
{\itshape }

{\itshape }\hypertarget{group__SVmodule_autotoc_md72}{}\doxysubsubsection{Configuration Mechanism}\label{group__SVmodule_autotoc_md72}
{\itshape  When using the UVM configuration database, these guidelines should be followed\+:}

{\itshape 
\begin{DoxyEnumerate}
\item The uvm\+\_\+config\+\_\+db API must be used. Do not use uvm\+\_\+resource\+\_\+db. Do not use set/get\+\_\+config\+\_\+object(), set/get\+\_\+config\+\_\+string(), or set/get\+\_\+config\+\_\+int(), these have been deprecated.
\item In general, a designated configuration object extended from uvm\+\_\+object should be used for every uvm\+\_\+env and uvm\+\_\+agent component in the testbench.
\item It is recommended that the environments configuration object contain the agents configuration object.
\item The uvm\+\_\+config\+\_\+db API should be used to pass configuration objects to locations where they are needed. It should not be used to pass integers, strings, or other basic data types, since it is much easier for namespace collisions to occur when using lower level types.
\item Checks for success must always be performed when using the uvm\+\_\+config\+\_\+db. If the lookup fails, issue a uvm\+\_\+fatal to terminate the simulation. This should be done as follows\+:
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md73}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md73}
{\itshape  if (!uvm\+\_\+config\+\_\+db $<$...$>$ \+::get(...)) \{ uvm\+\_\+fatal(...) \} }\hypertarget{group__SVmodule_autotoc_md74}{}\doxysubsection{autotoc\+\_\+md74}\label{group__SVmodule_autotoc_md74}
{\itshape 
\begin{DoxyEnumerate}
\item Wildcards must not be used in the field argument of uvm\+\_\+config\+\_\+db\+::set(...) calls. It is allowed to use wildcards in the inst\+\_\+name argument of these calls, with proper precautions.
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md75}{}\doxysubsubsection{Sequences}\label{group__SVmodule_autotoc_md75}
{\itshape 
\begin{DoxyEnumerate}
\item It is recommended to keep sequences as generic as possible and to avoid writing directed sequences unless absolutely necessary.
\item It is recommended to avoid explicit delays in terms of absolute time to make code emulation friendly. Delays in terms of clock cycles are allowed.
\item The body() method should only execute the raw functional behavior of the sequence. Any associated housekeeping code should be placed elsewhere, such as in the pre\+\_\+start() and post\+\_\+start() methods.
\begin{DoxyItemize}
\item pre\+\_\+start() and post\+\_\+start() must be used instead of pre\+\_\+body() and post\+\_\+body(), as these will always be called, even for subsequences called from a parent sequence.
\end{DoxyItemize}
\item When creating a sequence object, always randomize the sequence before starting it.
\item Virtual sequences must be used to coordinate the behavior of multiple agents and multiple sequences.
\item Virtual sequences must be started on the null sequencer or on a valid virtual sequencer.
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md76}{}\doxysubsubsection{Sequence Items}\label{group__SVmodule_autotoc_md76}
{\itshape  It is recommended, but not necessary, to create small \char`\"{}unit tests\char`\"{} for transactions objects to ensure the randomization constraints are working as intended.}

{\itshape }\hypertarget{group__SVmodule_autotoc_md77}{}\doxysubsubsection{RAL Usage}\label{group__SVmodule_autotoc_md77}
{\itshape  When using the UVM RAL model, care must be taken when using uvm\+\_\+reg\+::set() and uvm\+\_\+reg\+::update(), as these are both non-\/atomic operations that can easily cause race conditions if there are any parallel threads.}

{\itshape }\hypertarget{group__SVmodule_autotoc_md78}{}\doxysubsubsection{Objections and Coordinating End of Test}\label{group__SVmodule_autotoc_md78}
{\itshape }

{\itshape As a general principle, a phase should not \} when either there is more stimulus to send during that phase or the DUT has yet to respond to some stimulus that has been sent.}

{\itshape To prevent a phase from ending when there is more stimulus to send, a test class must raise and lower objections.}

{\itshape To prevent a phase from ending before the DUT has responded to some stimulus, classes derived from uvm\+\_\+component should raise and lower objections in their phases\+\_\+ready\+\_\+to\+\_\+end() method.}

{\itshape It is also recommended to only include objections in the monitor component. When using this approach, these guidelines should be followed\+:}

{\itshape 
\begin{DoxyEnumerate}
\item The monitors phase\+\_\+ready\+\_\+to\+\_\+end() method should implement a watchdog timer that raises an objection if any traffic is seen on the bus and lowers it once no traffic is seen within the timeout period. If traffic is seen, the watchdog resets its timer. Refer to the example below\+:
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md79}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md79}
{\itshape  // Example code for the monitor class. // This code assumes that the associated configuration object has an integer // property \char`\"{}ok\+\_\+to\+\_\+end\+\_\+delay\+\_\+ns\char`\"{}, which gives the window timeout in // nanoseconds.}

{\itshape protected\+: bit ok\+\_\+to\+\_\+end = 0b1; bit watchdog\+\_\+done = 0b0;}

{\itshape  void phase\+\_\+ready\+\_\+to\+\_\+end(uvm\+\_\+phase phase) \{ if (phase.\+is(uvm\+\_\+run\+\_\+phase\+::get())) \{ if (watchdog\+\_\+done) fork monitor\+\_\+ready\+\_\+to\+\_\+end(); join\+\_\+none if (!ok\+\_\+to\+\_\+end $\vert$$\vert$ !watchdog\+\_\+done) \{ phase.\+raise\+\_\+objection(this, \$sformatf(\char`\"{}\%s objection raised\char`\"{}, gfn)); fork \{ // wait until ok\+\_\+to\+\_\+end is set watchdog\+\_\+ok\+\_\+to\+\_\+end(); phase.\+drop\+\_\+objection(this, \$sformatf(\char`\"{}\%s, objection dropped\char`\"{}, gfn)); \} join\+\_\+none \} \}}

{\itshape  \} public\+: // This watchdog waits for ok\+\_\+to\+\_\+end\+\_\+delay\+\_\+ns nanoseconds while checking for // any traffic seen on the bus during this period. // If traffic is seen, the watchdog will restart until it sees no traffic. task watchdog\+\_\+ok\+\_\+to\+\_\+end() \{ fork \{ bit watchdog\+\_\+reset; fork forever \{ // check bus interface for traffic ; if (!ok\+\_\+to\+\_\+end \&\& !watchdog\+\_\+reset) watchdog\+\_\+reset = 1; \} forever \{ $<$cfg.\+ok\+\_\+to\+\_\+end\+\_\+delay\+\_\+ns $\ast$ 1ns$>$ ; if (!watchdog\+\_\+reset) \{ break; \} else \{ watchdog\+\_\+reset = 0; \} \} join\+\_\+any; disable fork;}

{\itshape  watchdog\+\_\+done = 1; \} join \}}

{\itshape  // This task is invoked as a non-\/blocking thread when phase\+\_\+ready\+\_\+to\+\_\+end() // is first entered. // // This task should monitor the DUT\textquotesingle{}s interface and control ok\+\_\+to\+\_\+end\+: it // should be cleared whenever there are any pending transactions and // set to 1 if there are no pending transactions. virtual task monitor\+\_\+ready\+\_\+to\+\_\+end() \{ \} }\hypertarget{group__SVmodule_autotoc_md80}{}\doxysubsection{autotoc\+\_\+md80}\label{group__SVmodule_autotoc_md80}
{\itshape 
\begin{DoxyEnumerate}
\item It is recommended not to use other objections in the scoreboard; the scoreboard should just make use of information already available to it (like fifo size, etc...) to determine when it is ready to \}, as the monitor has already guaranteed that no more traffic is seen on the bus. These fifo checks should be checked during its check\+\_\+phase().
\end{DoxyEnumerate}}

{\itshape The more general guidelines below should be followed when dealing with \}-\/of-\/test timeouts or objections\+:}

{\itshape 
\begin{DoxyEnumerate}
\item When calling raise\+\_\+objection or drop\+\_\+objection, a string must be passed as a second argument to describe the objection to help with debugging.
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md81}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md81}
{\itshape  phase.\+raise\+\_\+objection(this, \$sformatf(\char`\"{}\%s objection raised\char`\"{}, gfn)); ... phase.\+drop\+\_\+objection(this, \$sformatf(\char`\"{}\%s objection dropped\char`\"{}, gfn)); }\hypertarget{group__SVmodule_autotoc_md82}{}\doxysubsection{autotoc\+\_\+md82}\label{group__SVmodule_autotoc_md82}
{\itshape 
\begin{DoxyEnumerate}
\item It is recommended to use the built-\/in UVM timeout mechanism, uvm\+\_\+root\+::set\+\_\+timeout($<$time\+\_\+limit$>$, 1). The base test in every testbench should specify a default timeout limit, which can be overridden by every derivative test. A standard plusarg +UVM\+\_\+\+TIMEOUT=... is recommended to be used for this override mechanism.
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md83}{}\doxysubsubsection{Logging and Print Messages}\label{group__SVmodule_autotoc_md83}
{\itshape 
\begin{DoxyEnumerate}
\item Print messages sent to the console should be kept to a minimum. Logs should be as concise as possible, by only writing key information when activity is present.
\item Whenever possible, log any data directly to log files instead of the console. It is recommended that only critical information/errors be sent to both the console and the log files.
\item Logging messages should be architected to be parsing \char`\"{}friendly\char`\"{}
\begin{DoxyItemize}
\item All related information should be kept on a single line.
\item Only the relevant data should be logged, for example, there is no need to log all fields of a transaction object when only a small subset is valid and relevant to the transaction being performed.
\item Log files should format lines consistently, starting with the simulation time that the logging event occurs, enabling easier post-\/processing.
\item The build in print() of uvm\+\_\+object classes is not parsing \char`\"{}friendly\char`\"{}, it is recommended not to use this .
\end{DoxyItemize}
\item Do not use the uvm\+\_\+report\+\_\+$\ast$ messaging functionality, or \$display to print any messages. The uvm\+\_\+\{info/error/fatal\} macros must be used instead.
\item Do not use the uvm\+\_\+warning macro, use uvm\+\_\+error or uvm\+\_\+fatal instead.
\item The first argument to these report macros must be one of the gfn or gtn shorthand macros used in place of get\+\_\+full\+\_\+name() and get\+\_\+type\+\_\+name(). This will allow for easier debugging should something go wrong.
\item The UVM\+\_\+\+NONE and UVM\+\_\+\+FULL verbosity levels must not be used for any report messages. Recommended criteria for the choice of VERBOSITY value for uvm\+\_\+info messages\+:
\begin{DoxyItemize}
\item UVM\+\_\+\+LOW -\/ important messages that occur a small number of times during a simulation.
\begin{DoxyItemize}
\item Instantiation of testbench components.
\item Reset assert/deassert, start/\} of DUT initialization.
\item Start/\} of traffic generation.
\end{DoxyItemize}
\item UVM\+\_\+\+MEDIUM -\/ slightly more detailed messages.
\begin{DoxyItemize}
\item Contents of CSR fields during CSR transactions.
\item Reporting of significant events inside the DUT -\/ fifo full, fifo empty, and so on.
\end{DoxyItemize}
\item UVM\+\_\+\+HIGH -\/ Any information about DUT activity, reference model, and testbench that could be helpful for monitoring stimulation progress.
\begin{DoxyItemize}
\item Parsing/interpretation of fields in requests to the DUT and reference model.
\item Read/write operations to a memory model.
\item Status of transactions over System\+Verilog interfaces.
\item Values of data output by the DUT.
\end{DoxyItemize}
\item UVM\+\_\+\+DEBUG -\/ Extremely specific information used for debugging failures.
\begin{DoxyItemize}
\item Any CSR exclusions.
\item Interface buses used to drive the /$\ast$$\ast$ $\ast$/ .
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md84}{}\doxysubsubsection{DPI and C Connections}\label{group__SVmodule_autotoc_md84}
{\itshape 
\begin{DoxyEnumerate}
\item DPI and native System\+Verilog calls have the same semantics and are thus indistinguishable. To preserve readability, a decorator must be added as such\+:
\begin{DoxyItemize}
\item Functions/tasks exported from SV to C must be prefixed with sv\+\_\+dpi\+\_\+.
\end{DoxyItemize}
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md85}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md85}
{\itshape  }\hypertarget{group__SVmodule_autotoc_md86}{}\doxysubsection{autotoc\+\_\+md86}\label{group__SVmodule_autotoc_md86}
{\itshape 
\begin{DoxyItemize}
\item Functions imported from C to SV must be prefixed with c\+\_\+dpi\+\_\+.
\end{DoxyItemize}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md87}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md87}
{\itshape  int c\+\_\+dpi\+\_\+adder(const int a, const int b); }\hypertarget{group__SVmodule_autotoc_md88}{}\doxysubsection{autotoc\+\_\+md88}\label{group__SVmodule_autotoc_md88}
{\itshape 
\begin{DoxyEnumerate}
\item DPI usage is recommended in the following scenarios\+:
\begin{DoxyItemize}
\item Interfacing with C/\+C++ based reference models.
\item Usage of optimized C/\+C++ libraries.
\item Emulation.
\end{DoxyItemize}
\item DPI usage is not recommended when the functionality can be handled natively in SV.
\item General DPI coding guidelines
\begin{DoxyItemize}
\item Do not cross the language boundary frequently.
\item If a SV-\/$>$C call consumes time and the C routine is not thread safe, protect the call with a semaphore to avoid synchronization issues.
\item In general, pass only basic data types as arguments to DPI calls.
\end{DoxyItemize}
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md89}{}\doxysubsection{System\+Verilog Language Features}\label{group__SVmodule_autotoc_md89}
{\itshape  }\hypertarget{group__SVmodule_autotoc_md90}{}\doxysubsubsection{Function Declarations}\label{group__SVmodule_autotoc_md90}
{\itshape  Functions declared within packages, as well as any other static entities such as modules and interfaces, must be explicitly scoped with either the static or automatic keyword.}

{\itshape }\hypertarget{group__SVmodule_autotoc_md91}{}\doxysubsubsection{Randomization}\label{group__SVmodule_autotoc_md91}
{\itshape  Good constraint coding style is important for faster simulations and better simulation performance.}

{\itshape 
\begin{DoxyEnumerate}
\item Give all constraints a name that matches with what is being constrained, and suffix the constraint name with \+\_\+c.
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md92}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md92}
{\itshape  constraint num\+\_\+packets\+\_\+c() \{ num\+\_\+packets $<$ 8; \} }\hypertarget{group__SVmodule_autotoc_md93}{}\doxysubsection{autotoc\+\_\+md93}\label{group__SVmodule_autotoc_md93}
{\itshape 
\begin{DoxyEnumerate}
\item Avoid using loops in constraints whenever possible. In some cases, foreach can be replaced by inside.

\+:-\/1\+: 
\end{DoxyEnumerate}}\hypertarget{group__SVmodule_autotoc_md94}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md94}
{\itshape  constraint con\+\_\+c() \{ foreach (data\mbox{[}i\mbox{]}) \{ a != data\mbox{[}i\mbox{]}; \} \} }\hypertarget{group__SVmodule_autotoc_md95}{}\doxysubsection{autotoc\+\_\+md95}\label{group__SVmodule_autotoc_md95}
{\itshape  \+:+1\+: }\hypertarget{group__SVmodule_autotoc_md96}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md96}
{\itshape  constraint con\+\_\+c() \{ !(a inside \{data\}); \} }\hypertarget{group__SVmodule_autotoc_md97}{}\doxysubsection{autotoc\+\_\+md97}\label{group__SVmodule_autotoc_md97}
{\itshape 
\begin{DoxyEnumerate}
\item If using loops in constraints is necessary, avoid doing calculations inside the loops.
\item Whenever possible, use bitmasking operations over modulus operations, as bitmasking operations are much faster.
\item If a constraint becomes too complex, it is highly recommended to split the constraint and separately randomize all relevant variables.
\item When randomizing an array of objects, it is generally recommended to not directly randomize the array, but to iterate through it and directly randomize each object to see better simulation performance.
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md98}{}\doxysubsubsection{Enums}\label{group__SVmodule_autotoc_md98}
{\itshape  Enum names should be written in lower\+\_\+snake\+\_\+case, and should include the block name for clarity. The enumerated values should be written in Upper\+Camel\+Case and should include the name of the enum for clarity.}

{\itshape }\hypertarget{group__SVmodule_autotoc_md99}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md99}
{\itshape typedef enum \{ Uart\+Interrupt\+Frame\+Err, Uart\+Interrupt\+Rx\+Buffer\+Full, ... \} uart\+\_\+interrupt\+\_\+e; }\hypertarget{group__SVmodule_autotoc_md100}{}\doxysubsection{autotoc\+\_\+md100}\label{group__SVmodule_autotoc_md100}
{\itshape }

{\itshape }\hypertarget{group__SVmodule_autotoc_md101}{}\doxysubsubsection{Interfaces, Clocking Blocks, Modports}\label{group__SVmodule_autotoc_md101}
{\itshape 
\begin{DoxyEnumerate}
\item Do not use the /$\ast$$\ast$ $\ast$/ (.
\item Clocks and reset must be generated in System\+Verilog modules, interfaces, or in the UVM component hierarchy. Do not do this generation in uvm\+\_\+object derived classes.
\item Use clocking blocks in a System\+Verilog /$\ast$$\ast$ $\ast$/ synchronous DUT interfaces.
\item It is recommended to implement a reusable /$\ast$$\ast$ $\ast$/ testbenches that will be included in integration/system level testbenches.
\end{DoxyEnumerate}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md102}{}\doxysubsubsection{Loop Operators}\label{group__SVmodule_autotoc_md102}
{\itshape  It is highly recommended to use foreach loops as often as possible over any equivalent loop operators, as they are much more concise and less prone to any subtle errors.}

{\itshape }\hypertarget{group__SVmodule_autotoc_md103}{}\doxysubsubsection{Code Within Asserts}\label{group__SVmodule_autotoc_md103}
{\itshape  For any randomization that is required, the macros specified in the \href{\#macro-usage}{\texttt{ Randomization Macros section}} must be used. Do not use assert() to check manual randomization calls, use the provided macros instead. More broadly, do not place any expression with side effects into an assert() statement.}

{\itshape \+:-\/1\+: }\hypertarget{group__SVmodule_autotoc_md104}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md104}
{\itshape // Do not assert the output of randomize() calls // 1. ret = item.\+randomize() with \{$<$constraints$>$\}) \{ assert(ret) \{ // 2. assert(randomize($<$variable$>$) with \{$<$constraints$>$\}); // 3. assert(item.\+randomize() with \{$<$constraints$>$\}); // 4. assert(function\+\_\+that\+\_\+has\+\_\+side\+\_\+effects()); }\hypertarget{group__SVmodule_autotoc_md105}{}\doxysubsection{autotoc\+\_\+md105}\label{group__SVmodule_autotoc_md105}
{\itshape  }\hypertarget{group__SVmodule_autotoc_md106}{}\doxysubsubsection{Wait and Fork}\label{group__SVmodule_autotoc_md106}
{\itshape  Always put wait fork and disable fork constructs inside of an isolation fork...join block to avoid erroneous waiting. It is recommended to use the DV\+\_\+\+SPINWAIT macro whenever possible, \href{\#macro-usage}{\texttt{ as described here}}.}

{\itshape When disabling subprocesses, this may be done by using disable fork to terminate all processes or by disable thread\+\_\+label to disable a specific thread. You may not use disable fork\+\_\+label to disable all threads in a fork statement because there is inconsistent support for this among EDA tools. The use of disable fork\+\_\+label is not compliant to the System\+Verilog-\/2017 standard (see Section 9.\+6.\+2 and 9.\+6.\+3 of the SV2017 LRM). Example code\+:}

{\itshape }\hypertarget{group__SVmodule_autotoc_md107}{}\doxysubsection{autotoc\+\_\+md107}\label{group__SVmodule_autotoc_md107}
{\itshape fork\+: fork\+\_\+label \{ \} ... join\+\_\+any}

{\itshape // INCORRECT. disable fork\+\_\+label; // Valid, but does not respect parent child process relationships. disable thread\+\_\+label; // Kills all threads spawned by the parent thread, including the ones in the // past. disable fork; }\hypertarget{group__SVmodule_autotoc_md108}{}\doxysubsection{autotoc\+\_\+md108}\label{group__SVmodule_autotoc_md108}
{\itshape  }\hypertarget{group__SVmodule_autotoc_md109}{}\doxysubsubsection{Wait And Non-\/\+Forever Loop}\label{group__SVmodule_autotoc_md109}
{\itshape  Always create a watchdog timer along with the wait statement or the non-\/forever loop. Recommend to use the following macros.}

{\itshape }\hypertarget{group__SVmodule_autotoc_md110}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md110}
{\itshape // This does {\ttfamily wait (condition);} with a default watchdog timer. \mbox{\hyperlink{dv__macros_8svh_a743f98785c4ba510e0a0dd2cc7a7b597}{DV\+\_\+\+WAIT(condition)}} }\hypertarget{group__SVmodule_autotoc_md111}{}\doxysubsection{autotoc\+\_\+md111}\label{group__SVmodule_autotoc_md111}
{\itshape  }\hypertarget{group__SVmodule_autotoc_md112}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md112}
{\itshape DV\+\_\+\+SPINWAIT(while (condition) \{ ... \}) }\hypertarget{group__SVmodule_autotoc_md113}{}\doxysubsection{autotoc\+\_\+md113}\label{group__SVmodule_autotoc_md113}
{\itshape  }\hypertarget{group__SVmodule_autotoc_md114}{}\doxysubsubsection{Void Casts}\label{group__SVmodule_autotoc_md114}
{\itshape  Do not void cast any /task calls that have useful return values, EXCEPT the following\+:
\begin{DoxyItemize}
\item system functions.
\item RAL predict() calls.
\item fifo/queue methods.
\end{DoxyItemize}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md115}{}\doxysubsubsection{Associative Arrays}\label{group__SVmodule_autotoc_md115}
{\itshape  Do not use wildcard indexed \mbox{[}$\ast$\mbox{]} associative arrays. Always specify a particular index type.}

{\itshape }\hypertarget{group__SVmodule_autotoc_md116}{}\doxysubsubsection{Bind Statements}\label{group__SVmodule_autotoc_md116}
{\itshape  bind statements are the preferred approach for using assertion-\/based monitors. For these situations, using .$\ast$ is allowed for making implicit port declarations when binding a /$\ast$$\ast$ $\ast$/ .}

{\itshape }\hypertarget{group__SVmodule_autotoc_md117}{}\doxysubsubsection{Simulator-\/specific Code}\label{group__SVmodule_autotoc_md117}
{\itshape  Always wrap simulator-\/specific code inside preprocessor guards. The macro names VCS, INCA, XCELIUM are defined for the VCS, Incisive/\+NCsim/\+Irun, and Xcelium/xrun simulators respectively, these must be used to wrap relevant code, as shown below\+:}

{\itshape }\hypertarget{group__SVmodule_autotoc_md118}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md118}
{\itshape \#ifdef VCS \$stack() \{ \#endif }\hypertarget{group__SVmodule_autotoc_md119}{}\doxysubsection{autotoc\+\_\+md119}\label{group__SVmodule_autotoc_md119}
{\itshape }

{\itshape }\hypertarget{group__SVmodule_autotoc_md120}{}\doxysubsubsection{Forbidden System Tasks and Functions}\label{group__SVmodule_autotoc_md120}
{\itshape  Do not use the following system functions}

{\itshape 
\begin{DoxyItemize}
\item \$psprintf, this is not in the System\+Verilog LRM. Use \$sformatf instead.
\item \$random and \$dist\+\_\+$\ast$, these functions are not part of the System\+Verilog random stability model and can break simulation reproducibility. Use \$urandom or a randomization macro instead.
\item \$srandom, this is not part of the System\+Verilog standard. Use process\+::self().srandom() instead.
\end{DoxyItemize}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md121}{}\doxysubsubsection{Backdoor Force and Probe in Chip-\/level}\label{group__SVmodule_autotoc_md121}
{\itshape  Chip-\/level tests could be run in both RTL and gate sim. Since some signals may not be preserved in the same path after synthesis, we need follow these rules to use backdoor force or probe. This assumes gate-\/level netlist wont be flattened.}

{\itshape 
\begin{DoxyItemize}
\item Reference /$\ast$$\ast$ $\ast$/ / , / preserved in non-\/flattened netlist.
\item Reference logic if possible. If that is not possible, structs are likely converted to a giant vector. We can cast that vector to the struct and thus still access the individual members.
\item Do not reference internal nets, as those will likely not be preserved. If we really need to do so, they should be placed in an anchored buffer, in order to preserve the path.
\item Do not reference to internal clocks/resets, as they may not be preserved, even if the clocks/resets are in the /$\ast$$\ast$ $\ast$/ /. , .
\item CSR hierarchies are likely to be preserved, so CSR backdoor access will still work.
\end{DoxyItemize}}

{\itshape }\hypertarget{group__SVmodule_autotoc_md122}{}\doxysubsection{System\+Verilog Assertions}\label{group__SVmodule_autotoc_md122}
{\itshape  Most, if not all design properties are captured as in-\/line assertions within the RTL itself. The guidance on usage and implementation of assertions can be found in the adjoining \href{https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md\#assertion-macros}{\texttt{ low\+RISC Verilog style guide}}.}

{\itshape In some cases, it may be useful to capture specific design behaviors and their expected outcomes as assertion checks, rather than checks in the scoreboard, or other UVM testbench components. Such properties may reference internal RTL signals at the same or different hierarchies. They may be too complex to embed within the RTL itself. So, they may instead be captured in a separate System\+Verilog assertion (SVA) module.}

{\itshape The following guidelines help maximize the reuse of these SVA modules horizontally (an IP design is enhanced externally, and thus, has an extended testbench that reuses heavily from the original testbench) and vertically (an IP instantiated in a larger design, such as an SoC).}

{\itshape 
\begin{DoxyEnumerate}
\item The SVA /$\ast$$\ast$ $\ast$/ . checkers, they must not drive or force internal signals. Doing so may lead to confusion and increase the debug overhead.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Use the \href{https://github.com/lowRISC/opentitan/blob/master/hw/ip/prim/rtl/prim_assert.sv}{\texttt{ assertion macros}}.

\+:-\/1\+: 
\end{DoxyEnumerate}}\hypertarget{group__SVmodule_autotoc_md123}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md123}
{\itshape  // Manually typing the complete assertion statement is tedious and error-\/ // prone. One\+Hot\+Check\+\_\+A\+: assert property((@posedge clk) disable iff (!rst\+\_\+n) valid $\vert$=$>$ \$onehot(data)) \{ else \$error(...) \{ }\hypertarget{group__SVmodule_autotoc_md124}{}\doxysubsection{autotoc\+\_\+md124}\label{group__SVmodule_autotoc_md124}
{\itshape  \+:+1\+: }\hypertarget{group__SVmodule_autotoc_md125}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md125}
{\itshape  // Assertion macros are concise and hide some extra functionalities // underneath. ASSERT(One\+Hot\+Check\+\_\+A, valid $\vert$=$>$ \$onehot(data)) }\hypertarget{group__SVmodule_autotoc_md126}{}\doxysubsection{autotoc\+\_\+md126}\label{group__SVmodule_autotoc_md126}
{\itshape 
\begin{DoxyEnumerate}
\item Do not instantiate the SVA /$\ast$$\ast$ $\ast$/ . , the RTL /$\ast$$\ast$ $\ast$/ . is bound to the RTL module, an instance of the SVA /$\ast$$\ast$ $\ast$/ underneath all instances of the RTL module.

\+:-\/1\+: 
\end{DoxyEnumerate}}\hypertarget{group__SVmodule_autotoc_md127}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md127}
{\itshape  // Instantiating the SVA module in the testbench forces the user to use // absolute hierarchical paths to signals within the assertion properties // in the SVA module. This hampers reuse, since those paths may not exist // in other testbenches. sva\+\_\+module\+\_\+for\+\_\+aes\+\_\+core u\+\_\+sva\+\_\+module\+\_\+for\+\_\+aes\+\_\+core(.clk(...), ...) \{ }\hypertarget{group__SVmodule_autotoc_md128}{}\doxysubsection{autotoc\+\_\+md128}\label{group__SVmodule_autotoc_md128}
{\itshape  \+:+1\+: }\hypertarget{group__SVmodule_autotoc_md129}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md129}
{\itshape  // Bind the SVA module to the RTL module directly. All instances of // {\ttfamily aes\+\_\+core} in the design will benefit from the SVA checks. The SVA // module can also be reused in other testbenches, which may contain // additional instances of this RTL module elsewhere in the design. bind aes\+\_\+core sva\+\_\+module\+\_\+for\+\_\+aes\+\_\+core u\+\_\+sva\+\_\+module\+\_\+for\+\_\+aes\+\_\+core(.clk(...), ...); }\hypertarget{group__SVmodule_autotoc_md130}{}\doxysubsection{autotoc\+\_\+md130}\label{group__SVmodule_autotoc_md130}
{\itshape 
\begin{DoxyEnumerate}
\item Do not use absolute hierarchical paths to signals in the SVA modules (the previous bullet explains why). The bind enables cross /$\ast$$\ast$ $\ast$/ signals in the RTL /$\ast$$\ast$ $\ast$/ the SVA module.

\+:-\/1\+: 
\end{DoxyEnumerate}}\hypertarget{group__SVmodule_autotoc_md131}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md131}
{\itshape  // Path tb.\+dut.\+u\+\_\+aes.\+u\+\_\+aes\+\_\+core.\+u\+\_\+foo does not exist in other // testbenches. This module is not reusable in other testbenches. ASSERT(Check\+Prop\+\_\+A, valid $\vert$=$>$ \$onehot(tb.\+dut.\+u\+\_\+aes.\+u\+\_\+aes\+\_\+core.\+u\+\_\+bar.\+u\+\_\+baz.\+u\+\_\+quux.\+data\+\_\+q)) ASSERT(Check\+Prop\+\_\+A, tb.\+dut.\+u\+\_\+aes.\+u\+\_\+aes\+\_\+core.\+u\+\_\+foo.\+state\+\_\+q == Idle $\vert$=$>$ AES\+\_\+\+CORE\+\_\+\+BAR\+\_\+\+HIER.\+u\+\_\+baz.\+u\+\_\+quux.\+data\+\_\+q == 0) }\hypertarget{group__SVmodule_autotoc_md132}{}\doxysubsection{autotoc\+\_\+md132}\label{group__SVmodule_autotoc_md132}
{\itshape  \+:+1\+: }\hypertarget{group__SVmodule_autotoc_md133}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md133}
{\itshape  // Binding the SVA module to {\ttfamily aes\+\_\+core} obviates the need to specify the // absolute hierarchical paths to internal signals. Cross module // reference with partial paths is sufficient. This SVA module can now be // reused in the other testbenches. ASSERT(Check\+Prop\+\_\+A, valid $\vert$=$>$ \$onehot(u\+\_\+bar.\+u\+\_\+baz.\+u\+\_\+quux.\+data\+\_\+q)) ASSERT(Check\+Other\+Prop\+\_\+A, u\+\_\+foo.\+state\+\_\+q == Idle $\vert$=$>$ u\+\_\+bar.\+u\+\_\+baz.\+u\+\_\+quux.\+data\+\_\+q == 0) }\hypertarget{group__SVmodule_autotoc_md134}{}\doxysubsection{autotoc\+\_\+md134}\label{group__SVmodule_autotoc_md134}
{\itshape 
\begin{DoxyEnumerate}
\item If the assertions reference signals at different sub-\/hierarchies, then bind the SVA /$\ast$$\ast$ $\ast$/ . examples, that would be the aes\+\_\+core module.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Consolidate all SVA binds in a dedicated bindfile. The bind invocations are placed in a dedicated System\+Verilog module, called the 0bindfile. Bindfiles are treated as entities that are separate from the testbench module. They are passed to the simulator as one of the top level modules for elaboration. The bindfiles themselves, can be reused in other testbenches, by simply passing them as a top level entity to the simulator in those other testbenches as well.

\+:-\/1\+: 
\end{DoxyEnumerate}}\hypertarget{group__SVmodule_autotoc_md135}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md135}
{\itshape  // The testbench module which instantiates the design under test (DUT). /$\ast$$\ast$ $\ast$/ () \{}

{\itshape  // This module is considered \textquotesingle{}unreusable\textquotesingle{}. The {\ttfamily bind} invocations below // must hence be replicated in other testbenches where the SVA module can // be reused. bind aes\+\_\+core sva\+\_\+module\+\_\+for\+\_\+aes\+\_\+core u\+\_\+sva\+\_\+module\+\_\+for\+\_\+aes\+\_\+core(.clk(...), ...);}

{\itshape  \} }\hypertarget{group__SVmodule_autotoc_md136}{}\doxysubsection{autotoc\+\_\+md136}\label{group__SVmodule_autotoc_md136}
{\itshape  \+:+1\+: }\hypertarget{group__SVmodule_autotoc_md137}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md137}
{\itshape  // A dedicated bindfile for all AES assertions. /$\ast$$\ast$ $\ast$/ () \{}

{\itshape  // This module is reusable in other testbenches. The {\ttfamily bind} invocations // need not be replicated in other testbenches. bind aes\+\_\+core sva\+\_\+module\+\_\+for\+\_\+aes\+\_\+core u\+\_\+sva\+\_\+module\+\_\+for\+\_\+aes\+\_\+core(.clk(...), ...);}

{\itshape  \} }\hypertarget{group__SVmodule_autotoc_md138}{}\doxysubsection{autotoc\+\_\+md138}\label{group__SVmodule_autotoc_md138}
{\itshape 
\begin{DoxyEnumerate}
\item Bind SVA modules to RTL modules and not to specific instances of the RTL module. Binding the SVA /$\ast$$\ast$ $\ast$/ , issues -\/ other testbenches may have additional instances of the RTL /$\ast$$\ast$ $\ast$/ elsewhere in the design, which will miss out on the SVA checks. If there is a strong justifiable reason to bind the SVA /$\ast$$\ast$ $\ast$/ , then refrain from specifying the absolute hierarchical path to the instance. Instead, use the bind $<$module\+\_\+name$>$\+: $<$instance\+\_\+name$>$ notation.

\+:-\/1\+: 
\end{DoxyEnumerate}}\hypertarget{group__SVmodule_autotoc_md139}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md139}
{\itshape  // This bindfile is not reusable in other testbenches, because the {\ttfamily bind} // is applied to an instance with absolute hierarchical path, which may // not exist in other testbenches. bind tb.\+dut.\+u\+\_\+aes.\+u\+\_\+aes\+\_\+core sva\+\_\+module\+\_\+for\+\_\+aes\+\_\+core u\+\_\+sva\+\_\+module\+\_\+for\+\_\+aes\+\_\+core(.clk(...), ...) \{ }\hypertarget{group__SVmodule_autotoc_md140}{}\doxysubsection{autotoc\+\_\+md140}\label{group__SVmodule_autotoc_md140}
{\itshape  \+:-\/1\+: }\hypertarget{group__SVmodule_autotoc_md141}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md141}
{\itshape  // SVA module is only bound to {\ttfamily u\+\_\+aes\+\_\+core} instance of {\ttfamily aes\+\_\+core}. This // bindfile is reusable in other testbenches. But note that only the // {\ttfamily aes\+\_\+core} instance named {\ttfamily u\+\_\+aes\+\_\+core} will receive the SVA checks. // Discouraged, but fine reusablility-\/wise. bind aes\+\_\+core\+: u\+\_\+aes\+\_\+core sva\+\_\+module\+\_\+for\+\_\+aes\+\_\+core u\+\_\+sva\+\_\+module\+\_\+for\+\_\+aes\+\_\+core(.clk(...), ...); }\hypertarget{group__SVmodule_autotoc_md142}{}\doxysubsection{autotoc\+\_\+md142}\label{group__SVmodule_autotoc_md142}
{\itshape  \+:+1\+: }\hypertarget{group__SVmodule_autotoc_md143}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md143}
{\itshape  // This bindfile is reusable in other testbenches. bind aes\+\_\+core sva\+\_\+module\+\_\+for\+\_\+aes\+\_\+core u\+\_\+sva\+\_\+module\+\_\+for\+\_\+aes\+\_\+core(.clk(...), ...); }\hypertarget{group__SVmodule_autotoc_md144}{}\doxysubsection{autotoc\+\_\+md144}\label{group__SVmodule_autotoc_md144}
{\itshape  /$\ast$$\ast$ }\hypertarget{md_docs_style_guides_VerilogCodingStyle}{}\doxysubsubsection{low\+RISC Verilog Coding Style Guide}\label{md_docs_style_guides_VerilogCodingStyle}
\hypertarget{group__SVmodule_autotoc_md147}{}\doxysubsection{Basics}\label{group__SVmodule_autotoc_md147}
\hypertarget{group__SVmodule_autotoc_md148}{}\doxysubsubsection{Summary}\label{group__SVmodule_autotoc_md148}
Verilog is the main logic design language for low\+RISC Comportable IP.

Verilog and System\+Verilog (often generically referred to as just \char`\"{}\+Verilog\char`\"{} in this document) can be written in vastly different styles, which can lead to code conflicts and code review latency. This style guide aims to promote Verilog readability across groups. To quote the \href{https://google.github.io/styleguide/cppguide.html}{\texttt{ Google C++ style guide}}\+: \char`\"{}\+Creating common, required idioms and patterns makes code much easier to understand.\char`\"{}

This guide defines the Comportable style for Verilog. The goals are to\+:


\begin{DoxyItemize}
\item promote consistency across hardware development projects
\item promote best practices
\item increase code sharing and re-\/use
\end{DoxyItemize}

This style guide defines style for both Verilog-\/2001 and System\+Verilog compliant code. Additionally, this style guide defines style for both synthesizable and test bench code.

See the \href{\#appendix---condensed-style-guide}{\texttt{ Appendix}} for a condensed tabular representation of this style guide.

{\bfseries{Table of Contents}}


\begin{DoxyItemize}
\item \href{\#lowrisc-verilog-coding-style-guide}{\texttt{ low\+RISC Verilog Coding Style Guide}}
\begin{DoxyItemize}
\item \href{\#basics}{\texttt{ Basics}}
\begin{DoxyItemize}
\item \href{\#summary}{\texttt{ Summary}}
\item \href{\#terminology-conventions}{\texttt{ Terminology Conventions}}
\item \href{\#default-to-c-like-formatting}{\texttt{ Default to C-\/like Formatting}}
\item \href{\#style-guide-exceptions}{\texttt{ Style Guide Exceptions}}
\item \href{\#which-verilog-to-use}{\texttt{ Which Verilog to Use}}
\end{DoxyItemize}
\item \href{\#verilogsystemverilog-conventions}{\texttt{ Verilog/\+System\+Verilog Conventions}}
\begin{DoxyItemize}
\item \href{\#summary-1}{\texttt{ Summary}}
\item \href{\#file-extensions}{\texttt{ File Extensions}}
\item \href{\#general-file-appearance}{\texttt{ General File Appearance}}
\begin{DoxyItemize}
\item \href{\#characters}{\texttt{ Characters}}
\item \href{\#posix-file-endings}{\texttt{ POSIX File Endings}}
\item \href{\#line-length}{\texttt{ Line Length}}
\item \href{\#no-tabs}{\texttt{ No Tabs}}
\item \href{\#no-trailing-spaces}{\texttt{ No Trailing Spaces}}
\end{DoxyItemize}
\item \href{\#{--}}{\texttt{ Begin / End}}
\item \href{\#indentation}{\texttt{ Indentation}}
\begin{DoxyItemize}
\item \href{\#indented-sections}{\texttt{ Indented Sections}}
\item \href{\#line-wrapping}{\texttt{ Line Wrapping}}
\item \href{\#preprocessor-directives}{\texttt{ Preprocessor Directives}}
\end{DoxyItemize}
\item \href{\#spacing}{\texttt{ Spacing}}
\begin{DoxyItemize}
\item \href{\#comma-delimited-lists}{\texttt{ Comma-\/delimited Lists}}
\item \href{\#tabular-alignment}{\texttt{ Tabular Alignment}}
\item \href{\#expressions}{\texttt{ Expressions}}
\item \href{\#array-dimensions-in-declarations}{\texttt{ Array Dimensions in Declarations}}
\item \href{\#parameterized-types}{\texttt{ Parameterized Types}}
\item \href{\#labels}{\texttt{ Labels}}
\item \href{\#case -items}{\texttt{ Case items}} \{
\item \href{\#-and-task-calls}{\texttt{ Function And Task Calls}}
\item \href{\#macro-calls}{\texttt{ Macro Calls}}
\item \href{\#line-continuation}{\texttt{ Line Continuation}}
\item \href{\#space-around-keywords}{\texttt{ Space Around Keywords}}
\end{DoxyItemize}
\item \href{\#parentheses}{\texttt{ Parentheses}}
\begin{DoxyItemize}
\item \href{\#ternary-expressions}{\texttt{ Ternary Expressions}}
\end{DoxyItemize}
\item \href{\#comments}{\texttt{ Comments}}
\item \href{\#declarations}{\texttt{ Declarations}}
\item \href{\#basic-template}{\texttt{ Basic Template}}
\end{DoxyItemize}
\item \href{\#naming}{\texttt{ Naming}}
\begin{DoxyItemize}
\item \href{\#summary-2}{\texttt{ Summary}}
\item \href{\#constants}{\texttt{ Constants}}
\begin{DoxyItemize}
\item \href{\#parameterized-objects-modules-etc}{\texttt{ Parameterized Objects (modules, etc.)}}
\end{DoxyItemize}
\item \href{\#macro-definitions}{\texttt{ Macro Definitions}}
\item \href{\#suffixes}{\texttt{ Suffixes}}
\item \href{\#enumerations}{\texttt{ Enumerations}}
\item \href{\#signal-naming}{\texttt{ Signal Naming}}
\begin{DoxyItemize}
\item \href{\#use-descriptive-names}{\texttt{ Use descriptive names}}
\item \href{\#prefixes}{\texttt{ Prefixes}}
\item \href{\#hierarchical-consistency}{\texttt{ Hierarchical consistency}}
\end{DoxyItemize}
\item \href{\#clocks}{\texttt{ Clocks}}
\item \href{\#resets}{\texttt{ Resets}}
\end{DoxyItemize}
\item \href{\#language-features}{\texttt{ Language Features}}
\begin{DoxyItemize}
\item \href{\#preferred-systemverilog-constructs}{\texttt{ Preferred System\+Verilog Constructs}}
\item \href{\#package-dependencies}{\texttt{ Package Dependencies}}
\item \href{\#module-declaration}{\texttt{ Module Declaration}}
\item \href{\#module-instantiation}{\texttt{ Module Instantiation}}
\item \href{\#constants-1}{\texttt{ Constants}}
\item \href{\#signal-widths}{\texttt{ Signal Widths}}
\begin{DoxyItemize}
\item \href{\#always-be-explicit-about-the-widths-of-number-literals}{\texttt{ Always be explicit about the widths of number literals.}}
\item \href{\#port-connections-on-module-instances-must-always-match-widths-correctly}{\texttt{ Port connections on /$\ast$$\ast$ $\ast$/ .$<$/$>$$>$Do not use multi-\/bit signals in a boolean context.}}
\item \href{\#bit-slicing}{\texttt{ Bit Slicing}}
\item \href{\#handling-width-overflow}{\texttt{ Handling Width Overflow}}
\end{DoxyItemize}
\item \href{\#blocking-and-non-blocking-assignments}{\texttt{ Blocking and Non-\/blocking Assignments}}
\item \href{\#delay-modeling}{\texttt{ Delay Modeling}}
\item \href{\#sequential-logic-latches}{\texttt{ Sequential Logic (Latches)}}
\item \href{\#sequential-logic-registers}{\texttt{ Sequential Logic (Registers)}}
\item \href{\#dont-cares-xs}{\texttt{ Dont Cares (Xs)}}
\begin{DoxyItemize}
\item \href{\#catching-errors-where-invalid-values-are-consumed}{\texttt{ Catching errors where invalid values are consumed}}
\item \href{\#specific-guidance-on-case -statements-and-ternaries}{\texttt{ Specific Guidance on Case Statements and Ternaries}} \{
\item \href{\#dynamic-array-indexing}{\texttt{ Dynamic Array Indexing}}
\end{DoxyItemize}
\item \href{\#combinational-logic}{\texttt{ Combinational Logic}}
\item \href{\#case -statements}{\texttt{ Case Statements}} \{
\begin{DoxyItemize}
\item \href{\#wildcards-in-case-items}{\texttt{ Wildcards in case items}} \{
\end{DoxyItemize}
\item \href{\#generate-constructs}{\texttt{ Generate Constructs}}
\item \href{\#signed-arithmetic}{\texttt{ Signed Arithmetic}}
\item \href{\#number-formatting}{\texttt{ Number Formatting}}
\item \href{\#functions-and-tasks}{\texttt{ Functions and Tasks}}
\item \href{\#problematic-language-features-and-constructs}{\texttt{ Problematic Language Features and Constructs}}
\begin{DoxyItemize}
\item \href{\#floating-begin-end-blocks}{\texttt{ Floating \{-\/\} blocks}}
\item \href{\#hierarchical-references}{\texttt{ Hierarchical references}}
\end{DoxyItemize}
\end{DoxyItemize}
\item \href{\#design-conventions}{\texttt{ Design Conventions}}
\begin{DoxyItemize}
\item \href{\#summary-3}{\texttt{ Summary}}
\item \href{\#declare-all-signals}{\texttt{ Declare all signals}}
\item \href{\#use-logic-for-synthesis}{\texttt{ Use logic for synthesis}}
\item \href{\#logical-vs-bitwise}{\texttt{ Logical vs. Bitwise}}
\item \href{\#packed-ordering}{\texttt{ Packed Ordering}}
\item \href{\#unpacked-ordering}{\texttt{ Unpacked Ordering}}
\item \href{\#finite-state-machines}{\texttt{ Finite State Machines}}
\item \href{\#active-low-signals}{\texttt{ Active-\/\+Low Signals}}
\item \href{\#differential-pairs}{\texttt{ Differential Pairs}}
\item \href{\#delays}{\texttt{ Delays}}
\item \href{\#wildcard-import-of-packages}{\texttt{ Wildcard import of packages}}
\item \href{\#assertion-macros}{\texttt{ Assertion Macros}}
\begin{DoxyItemize}
\item \href{\#a-note-on-security-critical-applications}{\texttt{ A Note on Security Critical Applications}}
\end{DoxyItemize}
\end{DoxyItemize}
\item \href{\#appendix---condensed-style-guide}{\texttt{ Appendix -\/ Condensed Style Guide}}
\begin{DoxyItemize}
\item \href{\#basic-style-elements}{\texttt{ Basic Style Elements}}
\item \href{\#construct-naming}{\texttt{ Construct Naming}}
\item \href{\#suffixes-for-signals-and-types}{\texttt{ Suffixes for signals and types}}
\item \href{\#language-features-1}{\texttt{ Language features}}
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md149}{}\doxysubsubsection{Terminology Conventions}\label{group__SVmodule_autotoc_md149}
Unless otherwise noted, the following terminology conventions apply to this style guide\+:


\begin{DoxyItemize}
\item The word {\itshape {\bfseries{must}}} indicates a mandatory requirement. Similarly, {\itshape {\bfseries{do not}}} indicates a prohibition. Imperative and declarative statements correspond to {\itshape {\bfseries{must}}}.
\item The word {\itshape {\bfseries{recommended}}} indicates that a certain course of action is preferred or is most suitable. Similarly, {\itshape {\bfseries{not recommended}}} indicates that a course of action is unsuitable, but not prohibited. There may be reasons to use other options, but the implications and reasons for doing so must be fully understood.
\item The word {\itshape {\bfseries{may}}} indicates a course of action is permitted and optional.
\item The word {\itshape {\bfseries{can}}} indicates a course of action is possible given material, physical, or causal constraints.
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md150}{}\doxysubsubsection{Default to C-\/like Formatting}\label{group__SVmodule_autotoc_md150}
{\itshape {\bfseries{Where appropriate, format code consistent with \href{https://google.github.io/styleguide/cppguide.html}{\texttt{ https\+://google.\+github.\+io/styleguide/cppguide.\+html}}}}}

Verilog is a C-\/like language, and where appropriate, we default to being consistent with \href{https://google.github.io/styleguide/cppguide.html}{\texttt{ Googles C++ Style Guide}}.

In particular, we inherit these specific formatting guidelines\+:


\begin{DoxyItemize}
\item Generally, \href{\#naming}{\texttt{ names}} should be descriptive and avoid abbreviations.
\item Non-\/\+ASCII characters are forbidden.
\item Indentation uses spaces, no tabs. Indentation is two spaces for nesting, four spaces for line continuation.
\item Place a space between if and the parenthesis in \href{https://google.github.io/styleguide/cppguide.html\#Conditionals}{\texttt{ conditional expressions}}.
\item Use horizontal whitespace around operators, and avoid trailing whitespace at the \} of lines.
\item Maintain consistent and good \href{https://google.github.io/styleguide/cppguide.html\#Punctuation,_Spelling_and_Grammar}{\texttt{ punctuation, spelling, and grammar}} (within comments).
\item Use standard formatting for \href{\#comments}{\texttt{ comments}}, including C-\/like formatting for \href{https://google.github.io/styleguide/cppguide.html\#TODO_Comments}{\texttt{ TODO}} and \href{https://google.github.io/styleguide/cppguide.html\#Deprecation_Comments}{\texttt{ deprecation}}.
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md151}{}\doxysubsubsection{Style Guide Exceptions}\label{group__SVmodule_autotoc_md151}
{\itshape {\bfseries{Justify all exceptions with a comment.}}}

No style guide is perfect. There are times when the best path to a working design, or for working around a tool issue, is to simply cut the Gordian Knot and create code that is at variance with this style guide. It is always okay to deviate from the style guide by necessity, as long as that necessity is clearly justified by a brief comment, as well as a lint waiver pragma where appropriate.\hypertarget{group__SVmodule_autotoc_md152}{}\doxysubsubsection{Which Verilog to Use}\label{group__SVmodule_autotoc_md152}
{\itshape {\bfseries{Prefer System\+Verilog-\/2017.}}}

All RTL and tests should be developed in System\+Verilog, following the \href{https://ieeexplore.ieee.org/document/8299595}{\texttt{ IEEE 1800-\/2017 (System\+Verilog-\/2017) standard}}, except for \href{\#problematic-language-features-and-constructs}{\texttt{ prohibited features}}.

The standards document is available free of cost through \href{https://ieeexplore.ieee.org/browse/standards/get-program/page/series?id=80}{\texttt{ IEEE GET}} (a registration is required).\hypertarget{group__SVmodule_autotoc_md153}{}\doxysubsection{Verilog/\+System\+Verilog Conventions}\label{group__SVmodule_autotoc_md153}
\hypertarget{group__SVmodule_autotoc_md154}{}\doxysubsubsection{Summary}\label{group__SVmodule_autotoc_md154}
This section addresses primarily aesthetic aspects of style\+: line length, indentation, spacing, etc.\hypertarget{group__SVmodule_autotoc_md155}{}\doxysubsubsection{File Extensions}\label{group__SVmodule_autotoc_md155}
{\itshape {\bfseries{Use the .sv extension for System\+Verilog files (or .svh for files that are included via the preprocessor).}}}

File extensions have the following meanings\+:


\begin{DoxyItemize}
\item .sv indicates a System\+Verilog file defining a /$\ast$$\ast$ $\ast$/ .
\item .svh indicates a System\+Verilog header file intended to be included in another file using a preprocessor include directive.
\item .v indicates a Verilog-\/2001 file defining a /$\ast$$\ast$ $\ast$/ .
\item .vh indicates a Verilog-\/2001 header file.
\end{DoxyItemize}

Only .sv and .v files are intended to be compilation units. .svh and .vh files may only be include-\/ed into other files.

With exceptions of netlist files, each .sv or .v file should contain only one module, and the name should be associated. For instance, file foo.\+sv should contain only the /$\ast$$\ast$ $\ast$/ .\hypertarget{group__SVmodule_autotoc_md156}{}\doxysubsubsection{General File Appearance}\label{group__SVmodule_autotoc_md156}
\hypertarget{group__SVmodule_autotoc_md157}{}\doxyparagraph{Characters}\label{group__SVmodule_autotoc_md157}
$\ast$$\ast$$\ast$\+Use only ASCII characters with UNIX-\/style line endings(\char`\"{}\textbackslash{}n\char`\"{}).$\ast$$\ast$$\ast$\hypertarget{group__SVmodule_autotoc_md158}{}\doxyparagraph{POSIX File Endings}\label{group__SVmodule_autotoc_md158}
$\ast$$\ast$$\ast$\+All lines on non-\/empty files must \} with a newline (\char`\"{}\textbackslash{}n\char`\"{}).$\ast$$\ast$$\ast$\hypertarget{group__SVmodule_autotoc_md159}{}\doxyparagraph{Line Length}\label{group__SVmodule_autotoc_md159}
{\itshape {\bfseries{Wrap the code at 100 characters per line.}}}

The maximum line length for style-\/compliant Verilog code is 100 characters per line.

Exceptions\+:


\begin{DoxyItemize}
\item Any place where line wraps are impossible (for example, an include path might extend past 100 characters).
\end{DoxyItemize}

\href{\#line-wrapping}{\texttt{ Line-\/wrapping}} contains additional guidelines on how to wrap long lines.\hypertarget{group__SVmodule_autotoc_md160}{}\doxyparagraph{No Tabs}\label{group__SVmodule_autotoc_md160}
{\itshape {\bfseries{Do not use tabs anywhere.}}}

Use spaces to indent or align text. See \href{\#indentation}{\texttt{ Indentation}} for rules about indentation and wrapping.

To convert tabs to spaces on any file, you can use the \href{http://linux.die.net/man/1/expand}{\texttt{ UNIX expand}} utility.\hypertarget{group__SVmodule_autotoc_md161}{}\doxyparagraph{No Trailing Spaces}\label{group__SVmodule_autotoc_md161}
{\itshape {\bfseries{Delete trailing whitespace at the \} of lines.}}}\hypertarget{group__SVmodule_autotoc_md162}{}\doxysubsubsection{Begin / End}\label{group__SVmodule_autotoc_md162}
{\itshape {\bfseries{Use \{ and \} unless the whole statement fits on a single line.}}}

If a statement wraps at a block boundary, it must use \{ and \}. Only if a whole semicolon-\/terminated statement fits on a single line can \{ and \} be omitted.

\&\#x1f44d() \{ \hypertarget{group__SVmodule_autotoc_md163}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md163}
// Wrapped procedural block requires begin and end. always\+\_\+ff @(posedge clk) \{ q $<$= d() \{ \} \hypertarget{group__SVmodule_autotoc_md164}{}\doxysubsection{autotoc\+\_\+md164}\label{group__SVmodule_autotoc_md164}
\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md165}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md165}
// The exception case, where begin and end may be omitted as the entire // structure fits on a single line. always\+\_\+ff @(posedge clk) q $<$= d; \hypertarget{group__SVmodule_autotoc_md166}{}\doxysubsection{autotoc\+\_\+md166}\label{group__SVmodule_autotoc_md166}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md167}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md167}
// Incorrect because a wrapped statement must have begin and end. always\+\_\+ff @(posedge clk) q $<$= d; \hypertarget{group__SVmodule_autotoc_md168}{}\doxysubsection{autotoc\+\_\+md168}\label{group__SVmodule_autotoc_md168}
\{ must be on the same line as the preceding keyword, and ends the line. \} must start a new line. end else \{ must be together on one line. The only exception is if \} has a label, a following else should be on a new line.

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md169}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md169}
// \char`\"{}end else begin\char`\"{} are on the same line. if (condition) \{ foo = bar; \} else \{ foo = bum; \} \hypertarget{group__SVmodule_autotoc_md170}{}\doxysubsection{autotoc\+\_\+md170}\label{group__SVmodule_autotoc_md170}
\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md171}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md171}
// begin/end are omitted because each semicolon-\/terminated statement fits on // a single line. if (condition) foo = bar; else foo = bum; \hypertarget{group__SVmodule_autotoc_md172}{}\doxysubsection{autotoc\+\_\+md172}\label{group__SVmodule_autotoc_md172}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md173}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md173}
// Incorrect because \char`\"{}else\char`\"{} must be on the same line as \char`\"{}end\char`\"{}. if (condition) \{ foo = bar; \} else \{ foo = bum; \} \hypertarget{group__SVmodule_autotoc_md174}{}\doxysubsection{autotoc\+\_\+md174}\label{group__SVmodule_autotoc_md174}
\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md175}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md175}
// An exception is made for labeled blocks. if (condition) \{ foo = bar; \} else \{ foo = bum; \} \hypertarget{group__SVmodule_autotoc_md176}{}\doxysubsection{autotoc\+\_\+md176}\label{group__SVmodule_autotoc_md176}
The above style also applies to individual case items within a case statement. \{ and \} may be omitted if the entire case item (the case expression and the associated statement) fits on a single line. Otherwise, use the \{ keyword on the same line as the case expression.

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md177}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md177}
// Consistent use of begin and end for each case item is good. unique case (state\+\_\+q) \{ St\+Idle\+: \{ state\+\_\+d = StA; \} StA\+: \{ state\+\_\+d = StB; \} StB\+: \{ state\+\_\+d = St\+Idle; foo = bar; \} default\+: \{ state\+\_\+d = St\+Idle; \} \} \hypertarget{group__SVmodule_autotoc_md178}{}\doxysubsection{autotoc\+\_\+md178}\label{group__SVmodule_autotoc_md178}
\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md179}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md179}
// Case items that fit on a single line may omit begin and end. unique case (state\+\_\+q) \{ St\+Idle\+: state\+\_\+d = StA; StA\+: state\+\_\+d = StB; StB\+: \{ state\+\_\+d = St\+Idle; foo = bar; \} default\+: state\+\_\+d = St\+Idle; \} \hypertarget{group__SVmodule_autotoc_md180}{}\doxysubsection{autotoc\+\_\+md180}\label{group__SVmodule_autotoc_md180}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md181}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md181}
unique case (state\+\_\+q) \{ St\+Idle\+: // These lines are incorrect because we should not wrap state\+\_\+d = StA; // case items at a block boundary without using begin StA\+: // and end. Case items should fit on a single line, or state\+\_\+d = StB; // else the procedural block must have begin and end. StB\+: \{ foo = bar; state\+\_\+d = St\+Idle; \} default\+: \{ state\+\_\+d = St\+Idle; \} \} \hypertarget{group__SVmodule_autotoc_md182}{}\doxysubsection{autotoc\+\_\+md182}\label{group__SVmodule_autotoc_md182}
\hypertarget{group__SVmodule_autotoc_md183}{}\doxysubsubsection{Indentation}\label{group__SVmodule_autotoc_md183}
{\itshape {\bfseries{Indentation is two spaces per level.}}}

Use spaces for indentation. Do not use tabs. You should set your editor to emit spaces when you hit the tab key.\hypertarget{group__SVmodule_autotoc_md184}{}\doxyparagraph{Indented Sections}\label{group__SVmodule_autotoc_md184}
Always add an additional level of indentation to the enclosed sections of all paired keywords. Examples of System\+Verilog keyword pairs\+: \{ / \}, /$\ast$$\ast$ $\ast$/ / \}, / , / \};, / \}.\hypertarget{group__SVmodule_autotoc_md185}{}\doxyparagraph{Line Wrapping}\label{group__SVmodule_autotoc_md185}
When wrapping a long expression, indent the continued part of the expression by four spaces, like this\+:

\&\#x1f44d() \{ \hypertarget{group__SVmodule_autotoc_md186}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md186}
assign zulu = enabled \&\& ( alpha $<$ bravo \&\& charlie $<$ delta ) \{

assign addr = addr\+\_\+gen\+\_\+function\+\_\+with\+\_\+many\+\_\+params( thing, other\+\_\+thing, long\+\_\+parameter\+\_\+name, x, y, extra\+\_\+param1, extra\+\_\+param2 );

assign structure = \{ src\+: src, dest\+: dest, default\+: 0 \}; \hypertarget{group__SVmodule_autotoc_md187}{}\doxysubsection{autotoc\+\_\+md187}\label{group__SVmodule_autotoc_md187}
Or, if it improves readability, align the continued part of the expression with a grouping open parenthesis or brace, like this\+:

\+:+1\+: \hypertarget{group__SVmodule_autotoc_md188}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md188}
assign zulu = enabled \&\& (alpha $<$ bravo \&\& charlie $<$ delta);

assign addr = addr\+\_\+gen\+\_\+function(thing, other\+\_\+thing, long\+\_\+parameter\+\_\+name, x, y);

assign structure = \{src\+: src, dest\+: dest, default\+: 0\}; \hypertarget{group__SVmodule_autotoc_md189}{}\doxysubsection{autotoc\+\_\+md189}\label{group__SVmodule_autotoc_md189}
Operators in a wrapped expression can be placed at either the \} or the beginning of each line, but this must be done consistently within a file.

Open syntax characters such as \{ or ( that \} one line of a multi-\/line expression should be terminated with close characters (\}, )) on their own line. Examples\+:

\+:+1\+: \hypertarget{group__SVmodule_autotoc_md190}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md190}
assign bus\+\_\+concatenation = \{ bus\+\_\+valid, bus\+\_\+parity\mbox{[}8\mbox{]}, bus\+\_\+valid\mbox{[}63\+:0\mbox{]} \};

inst\+\_\+type inst\+\_\+name1 ( .clk\+\_\+i (clk), .data\+\_\+valid\+\_\+i(data\+\_\+valid), .data\+\_\+value\+\_\+i(data\+\_\+value), .data\+\_\+ready\+\_\+o(data\+\_\+ready) ); \hypertarget{group__SVmodule_autotoc_md191}{}\doxysubsection{autotoc\+\_\+md191}\label{group__SVmodule_autotoc_md191}
\hypertarget{group__SVmodule_autotoc_md192}{}\doxyparagraph{Preprocessor Directives}\label{group__SVmodule_autotoc_md192}
{\itshape {\bfseries{Keep branching preprocessor directives left-\/aligned and un-\/indented.}}}

Keep branching preprocessor directives ( ifdef, ifndef, else, \hypertarget{group__SVmodule_autotoc_md193}{}\doxysubsection{elsif\#\#, \#\# \#endif\#\#) aligned to the left, even if they are nested. Indent}\label{group__SVmodule_autotoc_md193}
the conditional branches of text as if the preprocessor directives were absent. Non-\/branching preprocessor directives must follow the same indentation rules as the regular code.

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md194}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md194}
\#ifdef FOO // \#include \char`\"{}foo.\+sv\char`\"{}; // parameter bit A = 1; // normal indentation for the regular code \#ifdef BAR // parameter bit A = 2; \#else parameter bit A = 3; \#endif \#endif\hypertarget{group__SVmodule_autotoc_md195}{}\doxysubsection{autotoc\+\_\+md195}\label{group__SVmodule_autotoc_md195}
Un-\/indented branching preprocessor directives disrupt the flow of reading to emphasize that there is conditional text. Leaving conditional branch text un-\/indented will result in post-\/preprocessed text looking properly indented.\hypertarget{group__SVmodule_autotoc_md196}{}\doxysubsubsection{Spacing}\label{group__SVmodule_autotoc_md196}
\hypertarget{group__SVmodule_autotoc_md197}{}\doxyparagraph{Comma-\/delimited Lists}\label{group__SVmodule_autotoc_md197}
{\itshape {\bfseries{For multiple items on a line, one space must separate the comma and the next character.}}}

Additional whitespace is allowed for readability.

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md198}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md198}
bus = \{addr, parity, data\}; a = myfunc(lorem, ipsum, dolor, sit, amet, consectetur, adipiscing, elit, rhoncus); mymodule mymodule(.a(a), .b(b)); \hypertarget{group__SVmodule_autotoc_md199}{}\doxysubsection{autotoc\+\_\+md199}\label{group__SVmodule_autotoc_md199}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md200}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md200}
\{parity,data\} = bus; a = myfunc(a,b,c); mymodule mymodule(.a(a),.b(b)); \hypertarget{group__SVmodule_autotoc_md201}{}\doxysubsection{autotoc\+\_\+md201}\label{group__SVmodule_autotoc_md201}
\hypertarget{group__SVmodule_autotoc_md202}{}\doxyparagraph{Tabular Alignment}\label{group__SVmodule_autotoc_md202}
Tabular alignment groups two or more similar lines so that the identical parts are directly above one another. This alignment makes it easy to see which characters are the same and which characters are different between lines.

{\itshape {\bfseries{The use of tabular alignment is generally encouraged.}}}

{\itshape {\bfseries{The use of tabular alignment is required for some constructs as detailed in the corresponding subsection of this guide.}}}

Constructs which require tabular alignment\+:


\begin{DoxyItemize}
\item \href{\#module-instantiation}{\texttt{ Port expressions in /$\ast$$\ast$ $\ast$/ $<$/$>$ Each block of code, separated by an empty line, is treated as separate \char`\"{}table\char`\"{}. Use spaces, not tabs. For example\+: \+:+1\+: @section autotoc\+\_\+md203 systemverilog logic $<$7\+:0$>$ my\+\_\+interface\+\_\+data() \{ logic $<$15\+:0$>$ my\+\_\+interface\+\_\+address; logic my\+\_\+interface\+\_\+enable; logic another\+\_\+signal; logic $<$7\+:0$>$ something\+\_\+else; @section autotoc\+\_\+md204 \+:+1\+: @section autotoc\+\_\+md205 systemverilog mod u\+\_\+mod ( .clk\+\_\+i, .rst\+\_\+ni, .sig\+\_\+i (my\+\_\+signal\+\_\+in), .sig2\+\_\+i (my\+\_\+signal\+\_\+out), // comment with no blank line maintains the block .in\+\_\+same\+\_\+block\+\_\+i(my\+\_\+signal\+\_\+in), .sig3\+\_\+i (something),  .in\+\_\+another\+\_\+block\+\_\+i(my\+\_\+signal\+\_\+in), .sig4\+\_\+i (something) ); @section autotoc\+\_\+md206 @subsubsection autotoc\+\_\+md207 Expressions {\itshape {\bfseries{Include whitespace on both sides of all binary operators.}}} Use spaces around binary operators. Add sufficient whitespace to aid readability. For example\+: \&\#x1f44d; @section autotoc\+\_\+md208 systemverilog \{.good\} assign a = ((addr \& mask) == My\+\_\+addr) ? b\mbox{[}1\mbox{]} \+: $\sim$b\mbox{[}0\mbox{]}; // good @section autotoc\+\_\+md209 is better than \&\#x1f44e; @section autotoc\+\_\+md210 systemverilog \{.bad\} assign a=((addr\&mask)==My\+\_\+addr)?b\mbox{[}1\mbox{]}\+:$\sim$b\mbox{[}0\mbox{]}; // bad @section autotoc\+\_\+md211 {\bfseries{Exception\+:}} when declaring a bit vector, it is acceptable to use the compact notation. For example\+: \&\#x1f44d; @section autotoc\+\_\+md212 systemverilog \{.good\} wire $<$WIDTH-\/1\+:0$>$ foo; // this is acceptable wire $<$WIDTH -\/ 1 \+: 0$>$ foo; // fine also, but not necessary @section autotoc\+\_\+md213 When splitting alternation expressions into multiple lines, use a format that is similar to an equivalent if-\/then-\/else line. For example\+: \&\#x1f44d; @section autotoc\+\_\+md214 systemverilog \{.good\} assign a = ((addr \& mask) == MY\+\_\+\+ADDRESS) ? matches\+\_\+value \+: doesnt\+\_\+match\+\_\+value; @section autotoc\+\_\+md215 @subsubsection autotoc\+\_\+md216 Array Dimensions in Declarations Add a space around packed dimensions. Do not add a space\+:space\+: between identifier and unpacked dimensions.. between multiple dimensions. Applies to packed and unpacked arrays as well as dynamic arrays, associative arrays, and queues. \&\#x1f44d; @section autotoc\+\_\+md217 systemverilog \{.good\} logic $<$7\+:0$>$ \mbox{[}4\mbox{]} data\mbox{[}128\mbox{]}\mbox{[}2\mbox{]}; typedef logic $<$31\+:0$>$ word\+\_\+t; bit bit\+\_\+array\mbox{[}512\mbox{]}; data\+\_\+t some\+\_\+array\mbox{[}\mbox{]}; data\+\_\+t some\+\_\+map\mbox{[}addr\+\_\+t\mbox{]}; data\+\_\+t some\+\_\+q\mbox{[}\$\mbox{]}; @section autotoc\+\_\+md218 \&\#x1f44e; @section autotoc\+\_\+md219 systemverilog \{.bad\} // There must not be a space between dimensions. logic $<$7\+:0$>$ \mbox{[}4\mbox{]} data\mbox{[}128\mbox{]} \mbox{[}2\mbox{]}; // There must be a space around packed dimensions. typedef logic $<$31\+:0$>$ word\+\_\+t; // There must not be a space between identifier and unpacked dimension. bit bit\+\_\+array \mbox{[}512\mbox{]}; // Dynamic, associative, and queue \char`\"{}dimensions\char`\"{} are treated the same as unpacked // dimensions. There must not be a space. data\+\_\+t some\+\_\+array \mbox{[}\mbox{]}; data\+\_\+t some\+\_\+map \mbox{[}addr\+\_\+t\mbox{]}; data\+\_\+t some\+\_\+q \mbox{[}\$\mbox{]}; @section autotoc\+\_\+md220 @subsubsection autotoc\+\_\+md221 Parameterized Types {\itshape {\bfseries{Add one space before type parameters, except when the type is part of a qualified name.}}} A qualified name contains at least one scope \+:: operator connecting its segments. A space in a qualified name would break the continuity of a reference to one symbol, so it must not be added. Parameter lists must follow the space-\/after-\/comma}} rule.
\end{DoxyItemize}

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md222}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md222}
my\+\_\+fifo $<$.WIDTH(4), .DEPTH(2)$>$ my\+\_\+fifo\+\_\+nibble ...

class foo \+: public bar $<$32, 8$>$ \{ public\+: // unqualified base class ... \};

foo\+\_\+h = my\+\_\+class $<$.X(1), .Y(0)$>$ \+::type\+\_\+id\+::create(\char`\"{}foo\+\_\+h\char`\"{}); // static method call

my\+\_\+pkg\+::x\+\_\+class $<$8, 1$>$ bar; // package-\/qualified name \hypertarget{group__SVmodule_autotoc_md223}{}\doxysubsection{autotoc\+\_\+md223}\label{group__SVmodule_autotoc_md223}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md224}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md224}
my\+\_\+fifo $<$.WIDTH(4), .DEPTH(2)$>$ my\+\_\+fifo\+\_\+2by4 ...

class foo \+: public bar $<$32, 8$>$ \{ public\+: // unqualified base class ... \};

foo\+\_\+h = my\+\_\+class $<$.X(1), .Y(0)$>$ \+::type\+\_\+id\+::create(\char`\"{}foo\+\_\+h\char`\"{}); // static method call

my\+\_\+pkg\+::x\+\_\+class $<$8, 1$>$ bar; // package-\/qualified name \hypertarget{group__SVmodule_autotoc_md225}{}\doxysubsection{autotoc\+\_\+md225}\label{group__SVmodule_autotoc_md225}
\hypertarget{group__SVmodule_autotoc_md226}{}\doxyparagraph{Labels}\label{group__SVmodule_autotoc_md226}
{\itshape {\bfseries{When labeling code blocks, add one space before and after the colon.}}}

For example\+:

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md227}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md227}
\{ \} \hypertarget{group__SVmodule_autotoc_md228}{}\doxysubsection{autotoc\+\_\+md228}\label{group__SVmodule_autotoc_md228}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md229}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md229}
\} // There must be a space before and after the colon. \} // There must be a space before the colon. \hypertarget{group__SVmodule_autotoc_md230}{}\doxysubsection{autotoc\+\_\+md230}\label{group__SVmodule_autotoc_md230}
\hypertarget{group__SVmodule_autotoc_md231}{}\doxyparagraph{Case items}\label{group__SVmodule_autotoc_md231}
There must be no whitespace before a case items colon; there must be at least one space after the case items colon.

The default case item must include a colon.

For example\+:

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md232}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md232}
unique case (my\+\_\+state) \{ St\+Init\+: \$display(\char`\"{}\+Shall we begin\char`\"{}); St\+Error\+: \$display(\char`\"{}\+Oh boy this is Bad\char`\"{}); default\+: \{ my\+\_\+state = St\+Init; interrupt = 1; \} \} \hypertarget{group__SVmodule_autotoc_md233}{}\doxysubsection{autotoc\+\_\+md233}\label{group__SVmodule_autotoc_md233}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md234}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md234}
unique case (0b1) \{ (my\+\_\+state == St\+Error) \+: interrupt = 1; // Excess whitespace before colon default\+:\{ \} // Missing space after colon \} \hypertarget{group__SVmodule_autotoc_md235}{}\doxysubsection{autotoc\+\_\+md235}\label{group__SVmodule_autotoc_md235}
\hypertarget{group__SVmodule_autotoc_md236}{}\doxyparagraph{Function And Task Calls}\label{group__SVmodule_autotoc_md236}
{\itshape {\bfseries{Function and task calls must not have any spaces between the name or task name and the open parenthesis.}}}

For example\+:

\&\#x1f44d() \{ \hypertarget{group__SVmodule_autotoc_md237}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md237}
process\+\_\+packet(pkt); \hypertarget{group__SVmodule_autotoc_md238}{}\doxysubsection{autotoc\+\_\+md238}\label{group__SVmodule_autotoc_md238}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md239}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md239}
process\+\_\+packet (pkt); // There must not be a space before \char`\"{}(\char`\"{} \hypertarget{group__SVmodule_autotoc_md240}{}\doxysubsection{autotoc\+\_\+md240}\label{group__SVmodule_autotoc_md240}
\hypertarget{group__SVmodule_autotoc_md241}{}\doxyparagraph{Macro Calls}\label{group__SVmodule_autotoc_md241}
{\itshape {\bfseries{Macro calls must not have any spaces between the macro name and the open parenthesis.}}}

For example\+:

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md242}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md242}
uvm\+\_\+error(ID, \char`\"{}you fail\char`\"{}) ASSERT(name, a \& b, clk, rst) \hypertarget{group__SVmodule_autotoc_md243}{}\doxysubsection{autotoc\+\_\+md243}\label{group__SVmodule_autotoc_md243}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md244}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md244}
uvm\+\_\+error (ID, \char`\"{}you fail\char`\"{}) // ASSERT (name, a \& b, clk, rst) \hypertarget{group__SVmodule_autotoc_md245}{}\doxysubsection{autotoc\+\_\+md245}\label{group__SVmodule_autotoc_md245}
\hypertarget{group__SVmodule_autotoc_md246}{}\doxyparagraph{Line Continuation}\label{group__SVmodule_autotoc_md246}
{\itshape {\bfseries{It is mandatory to right-\/align line continuations.}}}

Aligning line continuations (\textbackslash{} character) helps visually mark the \} of a multi-\/line macro. The position of alignment only needs to be beyond the rightmost extent of a multi-\/line macro by at least one space, when a space does not split a token, but should not exceed the maximum line length.\hypertarget{group__SVmodule_autotoc_md247}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md247}
\#define REALLY\+\_\+\+LONG\+\_\+\+MACRO(arg1, arg2, arg3) \textbackslash{} do\+\_\+something(arg1); \textbackslash{} do\+\_\+something\+\_\+else(arg2); \textbackslash{} final\+\_\+action(arg3); \hypertarget{group__SVmodule_autotoc_md248}{}\doxysubsection{autotoc\+\_\+md248}\label{group__SVmodule_autotoc_md248}
\hypertarget{group__SVmodule_autotoc_md249}{}\doxyparagraph{Space Around Keywords}\label{group__SVmodule_autotoc_md249}
{\itshape {\bfseries{Include whitespace before and after System\+Verilog keywords.}}}

Do not include a whitespace\+:


\begin{DoxyItemize}
\item before keywords that immediately follow a group opening, such as an open parenthesis.
\item before a keyword at the beginning of a line.
\item after a keyword at the \} of a line.
\end{DoxyItemize}

For example\+:\hypertarget{group__SVmodule_autotoc_md250}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md250}
// Normal indentation before if. Include a space after if. if (foo) \{ \} // Include a space after always, but not before posedge. always\+\_\+ff @(posedge clk) \{ \} \hypertarget{group__SVmodule_autotoc_md251}{}\doxysubsection{autotoc\+\_\+md251}\label{group__SVmodule_autotoc_md251}
\hypertarget{group__SVmodule_autotoc_md252}{}\doxysubsubsection{Parentheses}\label{group__SVmodule_autotoc_md252}
{\itshape {\bfseries{Use parentheses to make operations unambiguous.}}}

In any instance where a reasonable human would need to expend thought or refer to an operator precedence chart, use parentheses instead to make the order of operations unambiguous.\hypertarget{group__SVmodule_autotoc_md253}{}\doxyparagraph{Ternary Expressions}\label{group__SVmodule_autotoc_md253}
{\itshape {\bfseries{Ternary expressions nested in the true condition of another ternary expression must be enclosed in parentheses.}}}

For example\+:

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md254}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md254}
assign foo = condition\+\_\+a ? (condition\+\_\+a\+\_\+x ? x \+: y) \+: b; \hypertarget{group__SVmodule_autotoc_md255}{}\doxysubsection{autotoc\+\_\+md255}\label{group__SVmodule_autotoc_md255}
While the following nested ternary has only one meaning to the compiler, the meaning can be unclear and error-\/prone to humans\+:

\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md256}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md256}
assign foo = condition\+\_\+a ? condition\+\_\+a\+\_\+x ? x \+: y \+: b; \hypertarget{group__SVmodule_autotoc_md257}{}\doxysubsection{autotoc\+\_\+md257}\label{group__SVmodule_autotoc_md257}
{\itshape {\bfseries{Parentheses may be omitted if the code formatting conveys the same information, for example when describing a priority mux.}}}

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md258}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md258}
assign foo = condition\+\_\+a ? a \+: condition\+\_\+b ? b \+: not\+\_\+a\+\_\+nor\+\_\+b; \hypertarget{group__SVmodule_autotoc_md259}{}\doxysubsection{autotoc\+\_\+md259}\label{group__SVmodule_autotoc_md259}
\hypertarget{group__SVmodule_autotoc_md260}{}\doxysubsubsection{Comments}\label{group__SVmodule_autotoc_md260}
$\ast$$\ast$$\ast$\+C++ style comments (// foo\`{}) are preferred. C style comments (/$\ast$ bar $\ast$/) can also be used.$\ast$$\ast$$\ast$

A comment on its own line describes the code that follows. A comment on a line with code describes that line of code.

For example\+:\hypertarget{group__SVmodule_autotoc_md261}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md261}
// This comment describes the following module. /$\ast$$\ast$ $\ast$/ () \{ ... \}

localparam bit Val\+Baz = 1; // This comment describes the item to the left. \hypertarget{group__SVmodule_autotoc_md262}{}\doxysubsection{autotoc\+\_\+md262}\label{group__SVmodule_autotoc_md262}
It can sometimes be useful to structure the code using header-\/style comments in order to separate different functional parts (like FSMs, the main datapath or registers) within a module. In that case, the preferred style is a single-\/line section name, framed with //\`{} C++ style comments as follows\+:\hypertarget{group__SVmodule_autotoc_md263}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md263}
/$\ast$$\ast$ $\ast$/ () \{

//////////////// // Controller // //////////////// ...

/////////////////////// // Main ALU Datapath // /////////////////////// ...

\} \hypertarget{group__SVmodule_autotoc_md264}{}\doxysubsection{autotoc\+\_\+md264}\label{group__SVmodule_autotoc_md264}
If the designer would like to use comments to mark the beginning/\} of a particular section for better readability (e.\+g. in nested for loop blocks), the preferred way is to use a single-\/line comment with no extra delineators, as shown in the examples below.

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md265}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md265}
// begin\+: iterate over foobar for (...) \{ ... \} // end\+: iterate over foobar \hypertarget{group__SVmodule_autotoc_md266}{}\doxysubsection{autotoc\+\_\+md266}\label{group__SVmodule_autotoc_md266}
\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md267}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md267}
for (...) \{ // iterate over foobar ... \} // iterate over foobar \hypertarget{group__SVmodule_autotoc_md268}{}\doxysubsection{autotoc\+\_\+md268}\label{group__SVmodule_autotoc_md268}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md269}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md269}
//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- iterate over foobar -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- for (...) \{ ... \} //-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- iterate over foobar -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- \hypertarget{group__SVmodule_autotoc_md270}{}\doxysubsection{autotoc\+\_\+md270}\label{group__SVmodule_autotoc_md270}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md271}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md271}
/////////////////////////////// // begin iterate over foobar // /////////////////////////////// for (...) \{ ... \} /////////////////////////////// // end iterate over foobar // /////////////////////////////// \hypertarget{group__SVmodule_autotoc_md272}{}\doxysubsection{autotoc\+\_\+md272}\label{group__SVmodule_autotoc_md272}
\hypertarget{group__SVmodule_autotoc_md273}{}\doxysubsubsection{Declarations}\label{group__SVmodule_autotoc_md273}
{\itshape {\bfseries{Signals must be declared before they are used. This means that implicit net declarations must not be used.}}}

Within modules, it is {\bfseries{recommended}} that signals, types, enums, and localparams be declared close to their first use. This makes it easier for the reader to find the declaration and see the signal type.\hypertarget{group__SVmodule_autotoc_md274}{}\doxysubsubsection{Basic Template}\label{group__SVmodule_autotoc_md274}
{\itshape {\bfseries{A template that demonstrates many of the items is given below.}}}

Template\+:\hypertarget{group__SVmodule_autotoc_md275}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md275}
// Copyright low\+RISC contributors. // Licensed under the Apache License, Version 2.\+0, see LICENSE for details. // SPDX-\/\+License-\/\+Identifier\+: Apache-\/2.\+0 // // One line description of the module

/$\ast$$\ast$ $\ast$/ $<$ parameter Width = 80, parameter Height = 24 \begin{quote}
module my\+\_\+module ( \end{quote}
input clk\+\_\+i, input rst\+\_\+ni, input req\+\_\+valid\+\_\+i, input \mbox{[}Width-\/1\+:0\mbox{]} req\+\_\+data\+\_\+i, output req\+\_\+ready\+\_\+o, ... ) \{

logic $<$Width-\/1\+:0$>$ req\+\_\+data\+\_\+masked;

submodule u\+\_\+submodule ( .clk\+\_\+i, .rst\+\_\+ni, .req\+\_\+valid\+\_\+i, .req\+\_\+data\+\_\+i (req\+\_\+data\+\_\+masked), .req\+\_\+ready\+\_\+o(req\+\_\+ready), ... );

always\+\_\+comb \{ req\+\_\+data\+\_\+masked = req\+\_\+data\+\_\+i; case (fsm\+\_\+state\+\_\+q) \{ ST\+\_\+\+IDLE\+: \{ req\+\_\+data\+\_\+masked = req\+\_\+data\+\_\+i \& MASK\+\_\+\+IDLE; ... \}

...

\} \hypertarget{group__SVmodule_autotoc_md276}{}\doxysubsection{autotoc\+\_\+md276}\label{group__SVmodule_autotoc_md276}
\hypertarget{group__SVmodule_autotoc_md277}{}\doxysubsection{Naming}\label{group__SVmodule_autotoc_md277}
\hypertarget{group__SVmodule_autotoc_md278}{}\doxysubsubsection{Summary}\label{group__SVmodule_autotoc_md278}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Construct   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Style    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Construct   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Style    }\\\cline{1-2}
\endhead
Declarations (module, class, package, interface)   &lower\+\_\+snake\+\_\+case    \\\cline{1-2}
Instance names   &lower\+\_\+snake\+\_\+case    \\\cline{1-2}
Signals (nets and ports)   &lower\+\_\+snake\+\_\+case    \\\cline{1-2}
Variables, functions, tasks   &lower\+\_\+snake\+\_\+case    \\\cline{1-2}
Named code blocks   &lower\+\_\+snake\+\_\+case    \\\cline{1-2}
\textbackslash{}define macros   &ALL\+\_\+\+CAPS    \\\cline{1-2}
Tunable parameters for parameterized modules, classes, and interfaces   &Upper\+Camel\+Case    \\\cline{1-2}
Constants   &ALL\+\_\+\+CAPS or Upper\+Camel\+Case    \\\cline{1-2}
Enumeration types   &lower\+\_\+snake\+\_\+case\+\_\+e    \\\cline{1-2}
Other typedef types   &lower\+\_\+snake\+\_\+case\+\_\+t    \\\cline{1-2}
Enumerated value names   &Upper\+Camel\+Case   \\\cline{1-2}
\end{longtabu}
\hypertarget{group__SVmodule_autotoc_md279}{}\doxysubsubsection{Constants}\label{group__SVmodule_autotoc_md279}
{\itshape {\bfseries{Declare global constants using parameters in the project package file.}}}

In this context, {\bfseries{constants}} are distinct from tuneable parameters for objects such as parameterized modules, classes, etc.

Explicitly declare the type for constants.

When declaring a constant\+:


\begin{DoxyItemize}
\item within a package use parameter.
\item within a /$\ast$$\ast$ $\ast$/ .
\end{DoxyItemize}

The preferred method of defining constants is to declare a package and declare all constants as a parameter within that package. If the constants are to be used in only one file, it is acceptable to keep them defined within that file rather than a separate package.

Define project-\/wide constants in the projects main package.

Other packages may also be declared with their own parameter constants to facilitate the creation of IP that may be re-\/used across many projects.

The preferred naming convention for all immutable constants is to use ALL\+\_\+\+CAPS, but there are times when the use of Upper\+Camel\+Case might be considered more natural.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Constant Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Style Preference   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Conversation    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Constant Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Style Preference   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Conversation    }\\\cline{1-3}
\endhead
\textbackslash{}define   &ALL\+\_\+\+CAPS   &Truly constant    \\\cline{1-3}
/$\ast$$\ast$ $\ast$/   &Upper\+Camel\+Case   &truly modifiable by instantiation, not constant    \\\cline{1-3}
derived localparam   &Upper\+Camel\+Case   &while not modified directly, still tracks /$\ast$$\ast$ $\ast$/    \\\cline{1-3}
tuneable localparam   &Upper\+Camel\+Case   &while not expected to change upon RTL version, is used by designer to explore the design space conveniently    \\\cline{1-3}
true localparam constant   &ALL\+\_\+\+CAPS   &Example localparam OP\+\_\+\+JALR = 0x\+A0() \{   \\\cline{1-3}
\end{longtabu}
$\vert$ enum \{ OP\+\_\+\+JALR = 0x\+A0 \{ public\+: $\vert$ $\vert$ enum \{ ST\+\_\+\+IDLE, ST\+\_\+\+FRAME\+\_\+\+START, ST\+\_\+\+DYN\+\_\+\+INSTR\+\_\+\+READ ..., typedef enum ... \{ St\+Idle, St\+Frame\+Start, St\+Dyn\+Instr\+Read.... A collection of arbitrary values, could be either convention. $\vert$

The units for a constant should be described in the symbol name, unless the constant is unitless or the units are \char`\"{}bits.\char`\"{} For example, Foo\+Length\+Bytes.

Example\+:

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md280}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md280}
// package-\/scope

parameter int unsigned NUM\+\_\+\+CPU\+\_\+\+CORES = 64; // reference elsewhere as my\+\_\+pkg\+::\+NUM\+\_\+\+CPU\+\_\+\+CORES\hypertarget{group__SVmodule_autotoc_md281}{}\doxysubsection{autotoc\+\_\+md281}\label{group__SVmodule_autotoc_md281}
\hypertarget{group__SVmodule_autotoc_md282}{}\doxyparagraph{Parameterized Objects (modules, etc.)}\label{group__SVmodule_autotoc_md282}
{\itshape {\bfseries{Use parameter to parameterize, and localparam to declare module-\/scoped constants. Within a package, use parameter.}}}

You can create parameterized modules, classes, and interfaces to facilitate design re-\/use.

Use the keyword parameter within the /$\ast$$\ast$ $\ast$/ /$\ast$$\ast$ $\ast$/ instantiation. The preferred naming convention for all parameters is Upper\+Camel\+Case. Some projects may choose to use ALL\+\_\+\+CAPS to differentiate tuneable parameters from constants.

Derived parameters within the /$\ast$$\ast$ $\ast$/ . An example is shown below.\hypertarget{group__SVmodule_autotoc_md283}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md283}
/$\ast$$\ast$ $\ast$/ $<$ parameter int Depth = 2048, // 8kB default localparam int Aw = \$clog2(\+Depth) // derived parameter \begin{quote}
module modname ( \end{quote}
... ) \{

\} \hypertarget{group__SVmodule_autotoc_md284}{}\doxysubsection{autotoc\+\_\+md284}\label{group__SVmodule_autotoc_md284}
\hypertarget{group__SVmodule_autotoc_md285}{}\doxysubsection{\#define\#\# and defparam should never be used to parameterize a module.}\label{group__SVmodule_autotoc_md285}
Use \href{\#constants}{\texttt{ package parameters}} to transmit global constants through a hierarchy instead of parameters. To declare a constant whose scope is internal to the particular System\+Verilog module, \href{\#constants}{\texttt{ use localparam instead}}.

Examples of when to use parameterized modules\+:


\begin{DoxyItemize}
\item When multiple instances of a /$\ast$$\ast$ $\ast$/ , differentiated by a parameter.
\item As a means of specializing a /$\ast$$\ast$ $\ast$/ .
\item As a means of documenting which global parameters are permitted to change within the module.
\end{DoxyItemize}

Explicitly declare the type for parameters.

Use the type of the parameter to help constrain the legal range. E.\+g. int unsigned for general non-\/negative integer values, bit for boolean values. Any further restrictions on tuneable parameter values must be documented with assertions.

Tuneable parameter values should always have reasonable defaults.

For additional reading, see \mbox{[}New Verilog-\/2001 Techniques for Creating Parameterized Models\mbox{]}(\href{https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-884-complex-digital-systems-spring-2005/related-resources/parameter_models.pdf}{\texttt{ https\+://ocw.\+mit.\+edu/courses/electrical-\/engineering-\/and-\/computer-\/science/6-\/884-\/complex-\/digital-\/systems-\/spring-\/2005/related-\/resources/parameter\+\_\+models.\+pdf}}).\hypertarget{group__SVmodule_autotoc_md286}{}\doxysubsubsection{Macro Definitions}\label{group__SVmodule_autotoc_md286}
{\itshape {\bfseries{Macros should be ALL\+\_\+\+CAPITALS with underscores.}}}

Macros should be all capitals with underscores.

A {\bfseries{global define}} is a tick-\/defined macro in a header file that is shared by all source files in a project. To reduce namespace collisions, global defines should be prefixed by the name of a group of related macros, followed by a pair of underscores\+:\hypertarget{group__SVmodule_autotoc_md287}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md287}
// The following two constants are in the FOO namespace of the // SN chip. \#define SN\+\_\+\+FOO\+\_\+\+\_\+\+ALPHA\+\_\+\+BETA 5 \#define SN\+\_\+\+FOO\+\_\+\+\_\+\+GAMMA\+\_\+\+OMEGA 6 \hypertarget{group__SVmodule_autotoc_md288}{}\doxysubsection{autotoc\+\_\+md288}\label{group__SVmodule_autotoc_md288}
private\+: A $\ast$$\ast$ define$\ast$$\ast$ is a tick-\/defined macro that should only be used within the scope of a single file. It must be explicitly undefined after use, to avoid polluting the global macro namespace. To indicate that a macro is only meant to be used in the scope, the macro name should be prefixed with a single underscore.

To ensure that defines stay local, be careful not to include other files between the macro definition and undef.

Example\+:\hypertarget{group__SVmodule_autotoc_md289}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md289}
\#define {\itshape MAKE\+\_\+\+THING(\+\_\+x) \textbackslash{} thing i\+\_\+thing}\#\#\+\_\+x (.clk(clk), .i(i\#\#\+\_\+x) .o(o\#\#\+\_\+x)) \{ \+\_\+\+MAKE\+\_\+\+THING(a) \+\_\+\+MAKE\+\_\+\+THING(b) \+\_\+\+MAKE\+\_\+\+THING(c) \#undef \+\_\+\+MAKE\+\_\+\+THING \hypertarget{group__SVmodule_autotoc_md290}{}\doxysubsection{autotoc\+\_\+md290}\label{group__SVmodule_autotoc_md290}
\hypertarget{group__SVmodule_autotoc_md291}{}\doxysubsubsection{Suffixes}\label{group__SVmodule_autotoc_md291}
Suffixes are used in several places to give guidance to intent. The following table lists the suffixes that have special meaning.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Suffix(es)   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Arena   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Intent    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Suffix(es)   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Arena   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Intent    }\\\cline{1-3}
\endhead
\+\_\+e   &\PBS\centering typedef   &Enumerated types    \\\cline{1-3}
\+\_\+t   &\PBS\centering typedef   &Other typedefs, including signal clusters    \\\cline{1-3}
\+\_\+n   &\PBS\centering signal name   &Active low signal    \\\cline{1-3}
\+\_\+n, \+\_\+p   &\PBS\centering signal name   &Differential pair, active low and active high    \\\cline{1-3}
\+\_\+d, \+\_\+q   &\PBS\centering signal name   &Input and output of register    \\\cline{1-3}
\+\_\+q2,\+\_\+q3, etc   &\PBS\centering signal name   &Pipelined versions of signals; \+\_\+q is one cycle of latency, \+\_\+q2 is two cycles, \+\_\+q3 is three, etc    \\\cline{1-3}
\+\_\+i, \+\_\+o, \+\_\+io   &\PBS\centering signal name   &Module inputs, outputs, and bidirectionals   \\\cline{1-3}
\end{longtabu}


When multiple suffixes are necessary use the following guidelines\+:


\begin{DoxyItemize}
\item Guidance suffixes are added together and not separated by additional \+\_\+ characters (\+\_\+ni not \+\_\+n\+\_\+i)
\item If the signal is active low \+\_\+n will be the first suffix
\item If the signal is a /$\ast$$\ast$ $\ast$/ / .
\item It is not mandatory to propagate \+\_\+d and \+\_\+q to /$\ast$$\ast$ $\ast$/ .
\end{DoxyItemize}

Example\+:

\&\#x1f44d() \{ \hypertarget{group__SVmodule_autotoc_md292}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md292}
/$\ast$$\ast$ $\ast$/ ( input clk\+\_\+i, input rst\+\_\+ni, // Active low reset

// writer interface input \mbox{[}15\+:0\mbox{]} data\+\_\+i, input valid\+\_\+i, output ready\+\_\+o,

// bi-\/directional bus inout \mbox{[}8\mbox{]} driver\+\_\+io, // Bi directional signal

// Differential pair output output lvds\+\_\+po, // Positive part of the differential signal output lvds\+\_\+no // Negative part of the differential signal ) \{

logic valid\+\_\+d, valid\+\_\+q, valid\+\_\+q2, valid\+\_\+q3; assign valid\+\_\+d = valid\+\_\+i; // next state assignment

always\+\_\+ff @(posedge clk\+\_\+i or negedge rst\+\_\+ni) \{ if (!rst\+\_\+ni) \{ valid\+\_\+q $<$= 0; valid\+\_\+q2 $<$= 0; valid\+\_\+q3 $<$= 0; \} else \{ valid\+\_\+q $<$= valid\+\_\+d; valid\+\_\+q2 $<$= valid\+\_\+q; valid\+\_\+q3 $<$= valid\+\_\+q2; \} \}

assign ready\+\_\+o = valid\+\_\+q3; // three clock cycles delay

\} // simple \hypertarget{group__SVmodule_autotoc_md293}{}\doxysubsection{autotoc\+\_\+md293}\label{group__SVmodule_autotoc_md293}
\hypertarget{group__SVmodule_autotoc_md294}{}\doxysubsubsection{Enumerations}\label{group__SVmodule_autotoc_md294}
{\itshape {\bfseries{Name enumeration types snake\+\_\+case\+\_\+e. Name enumeration values ALL\+\_\+\+CAPS or Upper\+Camel\+Case.}}}

Always name enum types using typedef. The storage type of any enumerated type must be specified. For synthesizable enums, the storage type must be a 4-\/state data type (logic rather than bit).

Anonymous enum types are not allowed as they make it harder to use the type in other places throughout the project and across projects.

Enumeration type names should contain only lower-\/case alphanumeric characters and underscores. You must suffix enumeration type names with \+\_\+e.

Enumeration value names (constants) should typically be ALL\+\_\+\+CAPS, for example, READY\+\_\+\+TO\+\_\+\+SEND, to reflect their constant nature, especially for truly unchangeable values like defined opcode assignments. There are times when Upper\+Camel\+Case might be preferred, when the enumerated types assigned value is effectively a dont care to the designer, like state machine values. See the conversation on \href{\#constants}{\texttt{ constants}} for a discussion on how to think of this recommendation.

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md295}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md295}
typedef enum \{ // 8-\/bit opcodes OP\+\_\+\+JALR = 0x\+A0, OP\+\_\+\+ADDI = 0x47, OP\+\_\+\+LDW = 0x0B \} opcode\+\_\+e; opcode\+\_\+e op\+\_\+val; \hypertarget{group__SVmodule_autotoc_md296}{}\doxysubsection{autotoc\+\_\+md296}\label{group__SVmodule_autotoc_md296}
\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md297}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md297}
typedef enum \{ // A 2-\/bit enumerated type ACC\+\_\+\+WRITE, ACC\+\_\+\+READ, ACC\+\_\+\+PAUSE \} access\+\_\+e; // new named type is created access\+\_\+e req\+\_\+access, resp\+\_\+access; \hypertarget{group__SVmodule_autotoc_md298}{}\doxysubsection{autotoc\+\_\+md298}\label{group__SVmodule_autotoc_md298}
\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md299}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md299}
typedef enum \{ // A 2-\/bit enumerated type Acc\+Write, Acc\+Read, Acc\+Pause \} access\+\_\+e; // new named type is created access\+\_\+e req\+\_\+access, resp\+\_\+access; \hypertarget{group__SVmodule_autotoc_md300}{}\doxysubsection{autotoc\+\_\+md300}\label{group__SVmodule_autotoc_md300}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md301}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md301}
enum \{ // Typedef is missing, storage type is missing. Write, Read \} req\+\_\+access, resp\+\_\+access; // anonymous enum type \hypertarget{group__SVmodule_autotoc_md302}{}\doxysubsection{autotoc\+\_\+md302}\label{group__SVmodule_autotoc_md302}
\hypertarget{group__SVmodule_autotoc_md303}{}\doxysubsubsection{Signal Naming}\label{group__SVmodule_autotoc_md303}
{\itshape {\bfseries{Use lower\+\_\+snake\+\_\+case when naming signals.}}}

In this context, a {\bfseries{signal}} is meant to mean a net, variable, or port within a System\+Verilog design.

Signal names may contain lowercase alphanumeric characters and underscores.

Signal names should never \} with an underscore followed by a number (for example, foo\+\_\+1, foo\+\_\+2, etc.). Many synthesis tools map buses into nets using that naming convention, so similarly named nets can lead to confusion when examining a synthesized netlist.

Reserved \href{http://www.xilinx.com/support/documentation/sw_manuals/xilinx13_1/ite_r_verilog_reserved_words.htm}{\texttt{ Verilog}} or System\+Verilog keywords may never be used as names.

When interoperating with different languages, be mindful not to use keywords from other languages.\hypertarget{group__SVmodule_autotoc_md304}{}\doxyparagraph{Use descriptive names}\label{group__SVmodule_autotoc_md304}
{\itshape {\bfseries{Names should describe what a signals purpose is.}}}

Use whole words. Avoid abbreviations and contractions except in the most common places. Favor descriptive signal names over brevity.\hypertarget{group__SVmodule_autotoc_md305}{}\doxyparagraph{Prefixes}\label{group__SVmodule_autotoc_md305}
Use common prefixes to identify groups of signals that operate together. For example, all elements of an AXI-\/S /$\ast$$\ast$ $\ast$/ \+: , foo\+\_\+ready, and foo\+\_\+data.

Additionally, prefixes should be used to clearly label which signal is in which clock group for any /$\ast$$\ast$ $\ast$/ . $<$ =\char`\"{}\#\char`\"{} $>$clock domains for more details.

Examples\+:


\begin{DoxyItemize}
\item Signals associated with controlling a blockram might share a bram\+\_\+ prefix.
\item Signals that are synchronous with clk\+\_\+dram rather than clk should share a dram\+\_\+ prefix.
\end{DoxyItemize}

Code example\+:

\&\#x1f44d() \{ \hypertarget{group__SVmodule_autotoc_md306}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md306}
/$\ast$$\ast$ $\ast$/ ( input clk\+\_\+i, input rst\+\_\+ni,

// writer interface input \mbox{[}15\+:0\mbox{]} wr\+\_\+data\+\_\+i, input wr\+\_\+valid\+\_\+i, output wr\+\_\+ready\+\_\+o,

// reader interface output \mbox{[}15\+:0\mbox{]} rd\+\_\+data\+\_\+o, output rd\+\_\+valid\+\_\+o, output \mbox{[}8\mbox{]} rd\+\_\+fullness\+\_\+o, input rd\+\_\+ack\+\_\+i,

// memory interface\+: output \mbox{[}8\mbox{]} mem\+\_\+addr\+\_\+o, output \mbox{[}15\+:0\mbox{]} mem\+\_\+wdata\+\_\+o, output mem\+\_\+we\+\_\+o, input \mbox{[}15\+:0\mbox{]} mem\+\_\+rdata\+\_\+i ) \{ \hypertarget{group__SVmodule_autotoc_md307}{}\doxysubsection{autotoc\+\_\+md307}\label{group__SVmodule_autotoc_md307}
This naming convention makes it easier to map port names onto similar signal names using simple and consistent rules. See the section on \href{\#hierarchical-consistency}{\texttt{ Hierarchical Consistency}} for more information.\hypertarget{group__SVmodule_autotoc_md308}{}\doxyparagraph{Hierarchical consistency}\label{group__SVmodule_autotoc_md308}
{\itshape {\bfseries{The same signal should have the same name at any level of the hierarchy.}}}

A signal that connects to a port of an instance should have the same name as that port. By proceeding in this manner, signals that are directly connected should maintain the same name at any level of hierarchy.

Exceptions to this convention are expected, such as\+:


\begin{DoxyItemize}
\item When connecting a port to an element of an array of signals.
\item When mapping a generic port name to something more specific to the design. For example, two generic blocks, one with a host\+\_\+bus port and one with a device\+\_\+bus port might be connected by a foo\+\_\+bar\+\_\+bus signal.
\end{DoxyItemize}

In each exceptional case, care should be taken to make the mapping of port names to signal names as unambiguous and consistent as possible.\hypertarget{group__SVmodule_autotoc_md309}{}\doxysubsubsection{Clocks}\label{group__SVmodule_autotoc_md309}
{\itshape {\bfseries{All clock signals must \{ with clk.}}}

The main system clock for a design must be named clk. It is acceptable to use clk to refer to the default clock that the majority of the logic in a /$\ast$$\ast$ $\ast$/ is synchronous with.

If a /$\ast$$\ast$ $\ast$/ , should be named with a unique identifier, preceded by the clk\+\_\+ prefix. For example\+: clk\+\_\+dram, clk\+\_\+axi, etc. Note that this prefix will be used to identify other signals in that clock domain.\hypertarget{group__SVmodule_autotoc_md310}{}\doxysubsubsection{Resets}\label{group__SVmodule_autotoc_md310}
{\itshape {\bfseries{Resets are active-\/low and asynchronous. The default name is rst\+\_\+n.}}}

Chip wide all resets are defined as active low and asynchronous. Thus they are defined as tied to the asynchronous reset input of the associated standard cell registers.

The default name is rst\+\_\+n. If they must be distinguished by their clock, the clock name should be included in the reset name like rst\+\_\+domain\+\_\+n.

System\+Verilog allows either of the following syntax styles, but the style guide prefers the former.\hypertarget{group__SVmodule_autotoc_md311}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md311}
// preferred always\+\_\+ff @(posedge clk or negedge rst\+\_\+n) \{ if (!rst\+\_\+n) \{ q $<$= 0b0() \{ \} else \{ q $<$= d; \} \}

// legal but not preferred always\+\_\+ff @(posedge clk, negedge rst\+\_\+n) \{ if (!rst\+\_\+n) \{ q $<$= 0b0; \} else \{ q $<$= d; \} \} \hypertarget{group__SVmodule_autotoc_md312}{}\doxysubsection{autotoc\+\_\+md312}\label{group__SVmodule_autotoc_md312}
\hypertarget{group__SVmodule_autotoc_md313}{}\doxysubsection{Language Features}\label{group__SVmodule_autotoc_md313}
\hypertarget{group__SVmodule_autotoc_md314}{}\doxysubsubsection{Preferred System\+Verilog Constructs}\label{group__SVmodule_autotoc_md314}
Use these System\+Verilog constructs instead of their Verilog-\/2001 equivalents\+:


\begin{DoxyItemize}
\item always\+\_\+comb is required over always @$\ast$.
\item logic is preferred over reg and wire.
\item Top-\/level parameter declarations are preferred over define globals.
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md315}{}\doxysubsubsection{Package Dependencies}\label{group__SVmodule_autotoc_md315}
{\itshape {\bfseries{Packages must not have cyclic dependencies.}}}

Package files may depend on constants and types in other package files, but there must not be any cyclic dependencies. That is\+: if package A depends on a constant from package B, package B must not depend on anything from package A. While cyclic dependencies are permitted by the System\+Verilog language specification, their use can break some tools.

For example\+:\hypertarget{group__SVmodule_autotoc_md316}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md316}
// Package \char`\"{}bar\char`\"{} must not depend on anything in \char`\"{}foo\char`\"{}\+: parameter int unsigned Page\+Size\+Bytes = 16 $\ast$ bar\+::\+Kibi;\hypertarget{group__SVmodule_autotoc_md317}{}\doxysubsection{autotoc\+\_\+md317}\label{group__SVmodule_autotoc_md317}
\hypertarget{group__SVmodule_autotoc_md318}{}\doxysubsubsection{Module Declaration}\label{group__SVmodule_autotoc_md318}
{\itshape {\bfseries{Use the Verilog-\/2001 full port declaration style, and use the format below.}}}

Use the Verilog-\/2001 combined port and I/O declaration style. Do not use the Verilog-\/95 list style. The port declaration in the /$\ast$$\ast$ $\ast$/ declare the port name, type, and direction.

The opening parenthesis should be on the same line as the /$\ast$$\ast$ $\ast$/ , and the first port should be declared on the following line.

The closing parenthesis should be on its own line, in column zero.

Indentation for /$\ast$$\ast$ $\ast$/ rule of two space indentation.

The clock port(s) must be declared first in the port list, followed by any and all reset inputs.

Example without parameters\+:

\&\#x1f44d() \{ \hypertarget{group__SVmodule_autotoc_md319}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md319}
/$\ast$$\ast$ $\ast$/ ( input clk\+\_\+i, input rst\+\_\+ni, input \mbox{[}8\mbox{]} d\+\_\+i, output logic $<$7\+:0$>$ q\+\_\+o ) \{ \hypertarget{group__SVmodule_autotoc_md320}{}\doxysubsection{autotoc\+\_\+md320}\label{group__SVmodule_autotoc_md320}
Example with parameters\+:

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md321}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md321}
/$\ast$$\ast$ $\ast$/ $<$ parameter int unsigned Width = 8, \begin{quote}
module foo ( \end{quote}
input clk\+\_\+i, input rst\+\_\+ni, input \mbox{[}Width-\/1\+:0\mbox{]} d\+\_\+i, output logic $<$Width-\/1\+:0$>$ q\+\_\+o ) \{ \hypertarget{group__SVmodule_autotoc_md322}{}\doxysubsection{autotoc\+\_\+md322}\label{group__SVmodule_autotoc_md322}
Do not use Verilog-\/95 style\+:

\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md323}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md323}
// WRONG\+: /$\ast$$\ast$ $\ast$/ (, , ) \{ input wire $<$2\+:0$>$ a; output logic b; ... \hypertarget{group__SVmodule_autotoc_md324}{}\doxysubsection{autotoc\+\_\+md324}\label{group__SVmodule_autotoc_md324}
\hypertarget{group__SVmodule_autotoc_md325}{}\doxysubsubsection{Module Instantiation}\label{group__SVmodule_autotoc_md325}
{\itshape {\bfseries{Use named ports to fully specify all instantiations.}}}

When connecting signals to ports for an instantiation, use the named port style, like this\+:\hypertarget{group__SVmodule_autotoc_md326}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md326}
my\+\_\+module i\+\_\+my\+\_\+instance ( .clk\+\_\+i (clk\+\_\+i), .rst\+\_\+ni(rst\+\_\+ni), .d\+\_\+i (from\+\_\+here), .q\+\_\+o (to\+\_\+there) ); \hypertarget{group__SVmodule_autotoc_md327}{}\doxysubsection{autotoc\+\_\+md327}\label{group__SVmodule_autotoc_md327}
If the port and the connecting signal have the same name, you can use the .port syntax (without parentheses) to indicate connectivity. For example\+:\hypertarget{group__SVmodule_autotoc_md328}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md328}
my\+\_\+module i\+\_\+my\+\_\+instance ( .clk\+\_\+i, .rst\+\_\+ni, .d\+\_\+i (from\+\_\+here), .q\+\_\+o (to\+\_\+there) ); \hypertarget{group__SVmodule_autotoc_md329}{}\doxysubsection{autotoc\+\_\+md329}\label{group__SVmodule_autotoc_md329}
All declared ports must be present in the instantiation blocks. Unconnected outputs must be explicitly written as no-\/connects (for example\+: .output\+\_\+port()), and unused inputs must be explicitly tied to ground (for example\+: .unused\+\_\+input\+\_\+port(0d0))

.$\ast$ is not permitted.

Do not use positional arguments to connect signals to ports.

Instantiate ports in the same order as they are defined in the module.

Align port expressions in \href{\#tabular-alignment}{\texttt{ tabular style}}. Do not include whitespace before the opening parenthesis of the longest port name. Do not include whitespace after the opening parenthesis, or before the closing parenthesis enclosing the port expression.

\+:-\/1\+: \hypertarget{group__SVmodule_autotoc_md330}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md330}
mod u\+\_\+mod( .clk\+\_\+i, .rst\+\_\+ni,

// Not allowed\+: avoid leading/trailing whitespace in expressions. .sig\+\_\+1\+\_\+i( sig\+\_\+1 ), .sig\+\_\+2\+\_\+i( sig\+\_\+2 ) );

mod u\+\_\+mod( .clk\+\_\+i, .rst\+\_\+ni,

.short\+\_\+sig\+\_\+i (sig\+\_\+1), // Not allowed\+: avoid whitespace between the longest signal name and the opening parenthesis. .a\+\_\+very\+\_\+long\+\_\+signal\+\_\+name\+\_\+indeed\+\_\+i (sig\+\_\+2) ); \hypertarget{group__SVmodule_autotoc_md331}{}\doxysubsection{autotoc\+\_\+md331}\label{group__SVmodule_autotoc_md331}
{\itshape {\bfseries{Use named parameters for all instantiations.}}}

When parameterizing an instance, specify the parameter using the named parameter style. An exception is if there is only one parameter that is obvious such as register width, then the instantiation can be implicit.

Indentation for /$\ast$$\ast$ $\ast$/ rule of two space indentation.\hypertarget{group__SVmodule_autotoc_md332}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md332}
my\+\_\+module $<$ .Height(5), .Width(10) \begin{quote}
my\+\_\+module ( \end{quote}
// ... ) \{

my\+\_\+reg $<$16$>$ my\+\_\+reg0 ( .clk\+\_\+i, .rst\+\_\+ni, .d\+\_\+i (data\+\_\+in), .q\+\_\+o (data\+\_\+out) ); \hypertarget{group__SVmodule_autotoc_md333}{}\doxysubsection{autotoc\+\_\+md333}\label{group__SVmodule_autotoc_md333}
Do not specify parameters positionally, unless there is only one parameter and the intent of that parameter is obvious, such as the width for a register instance.

Do not use defparam.

{\itshape {\bfseries{Do not instantiate recursively.}}}

Modules may not instantiate themselves recursively.\hypertarget{group__SVmodule_autotoc_md334}{}\doxysubsubsection{Constants}\label{group__SVmodule_autotoc_md334}
{\itshape {\bfseries{It is recommended to use symbolicly named constants instead of raw numbers.}}}

Try to give commonly used constants symbolic names rather than repeatedly typing raw numbers.

Local constants should always be declared using localparam.

Global constants should always be declared in a separate .vh or .svh include file.

For System\+Verilog code, global constants should always be declared as package parameters. For Verilog-\/2001 compatible code, top-\/level parameters are not supported and define macros must be used instead.

Include the units for a constant as a suffix in the constants symbolic name. The exceptions to this rule are for constants that are inherently unitless, or if the constant is describing the default unit type, \char`\"{}bits.\char`\"{}

Example\+:\hypertarget{group__SVmodule_autotoc_md335}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md335}
localparam int unsigned INTERFACE\+\_\+\+WIDTH = 64; // Bits localparam int unsigned INTERFACE\+\_\+\+WIDTH\+\_\+\+BYTES = (INTERFACE\+\_\+\+WIDTH + 7) / 8; localparam int unsigned INTERFACE\+\_\+\+WIDTH\+\_\+64\+B\+\_\+\+WORDS = (INTERFACE\+\_\+\+WIDTH + 63) / 64; localparam int unsigned IMAGE\+\_\+\+WIDTH\+\_\+\+PIXELS = 640; localparam int unsigned MEGA = 1000 $\ast$ 1000; // Unitless localparam int unsigned MEBI = 1024 $\ast$ 1024; // Unitless localparam int unsigned SYSTEM\+\_\+\+CLOCK\+\_\+\+HZ = 200 $\ast$ MEGA; \hypertarget{group__SVmodule_autotoc_md336}{}\doxysubsection{autotoc\+\_\+md336}\label{group__SVmodule_autotoc_md336}
\hypertarget{group__SVmodule_autotoc_md337}{}\doxysubsubsection{Signal Widths}\label{group__SVmodule_autotoc_md337}
{\itshape {\bfseries{Be careful about signal widths.}}}\hypertarget{group__SVmodule_autotoc_md338}{}\doxyparagraph{Always be explicit about the widths of number literals.}\label{group__SVmodule_autotoc_md338}
Examples\+:

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md339}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md339}
localparam logic $<$3\+:0$>$ bar = 0d4;

assign foo = 0d2; \hypertarget{group__SVmodule_autotoc_md340}{}\doxysubsection{autotoc\+\_\+md340}\label{group__SVmodule_autotoc_md340}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md341}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md341}
localparam logic $<$3\+:0$>$ bar = 4;

assign foo = 2; \hypertarget{group__SVmodule_autotoc_md342}{}\doxysubsection{autotoc\+\_\+md342}\label{group__SVmodule_autotoc_md342}
Exceptions\+:


\begin{DoxyItemize}
\item When using parameterized widths, it is acceptable to simply use 0b1 (e.\+g. when incrementing) rather than contrivances such as \{\{(Bus\+\_\+width-\/1)\{0b0\}\}, 10b1\}. Alternately it could be written as Bus\+\_\+width(1).
\item It is acceptable to use the 0 construct to create an automatic correctly sized zero.
\item Literals assigned to integer variants (e.\+g. byte, shortint, int, integer, and longint) do not need an explicit width.
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md343}{}\doxyparagraph{Port connections on /$\ast$$\ast$ @ingroup SVmodule $\ast$/module instances must always match widths correctly.}\label{group__SVmodule_autotoc_md343}
It is recommended to use explicit widths, rather than relying on Verilogs implicit zero-\/extension and truncation operations, whenever practical.

Examples\+:

\&\#x1f44d() \{ \hypertarget{group__SVmodule_autotoc_md344}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md344}
my\+\_\+module i\+\_\+module ( .thirty\+\_\+two\+\_\+bit\+\_\+input(\{0d0, sixteen\+\_\+bit\+\_\+word\}) ); \hypertarget{group__SVmodule_autotoc_md345}{}\doxysubsection{autotoc\+\_\+md345}\label{group__SVmodule_autotoc_md345}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md346}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md346}
my\+\_\+module i\+\_\+module ( // Incorrectly implicitly extends from 16 bit to 32 bit .thirty\+\_\+two\+\_\+bit\+\_\+input(sixteen\+\_\+bit\+\_\+word) ); \hypertarget{group__SVmodule_autotoc_md347}{}\doxysubsection{autotoc\+\_\+md347}\label{group__SVmodule_autotoc_md347}
\hypertarget{group__SVmodule_autotoc_md348}{}\doxyparagraph{Do not use multi-\/bit signals in a boolean context.}\label{group__SVmodule_autotoc_md348}
Rather than letting boolean operations and if expressions reduce a multi-\/bit signal to a single bit, explicitly compare the multi-\/bit signal to 0. The implicit conversion can hide subtle logic bugs.

Examples;

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md349}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md349}
logic $<$3\+:0$>$ a, b; logic out;

assign out = (a != 0) \&\& (b == 0);

always\+\_\+comb \{ if (a != 0) ... else ... \} \hypertarget{group__SVmodule_autotoc_md350}{}\doxysubsection{autotoc\+\_\+md350}\label{group__SVmodule_autotoc_md350}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md351}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md351}
logic $<$3\+:0$>$ a, b; logic out;

// Incorrect because it implicitly converts 4-\/bit signals to 1-\/bit before AND. // Also, !b is different from $\sim$b and can be hard to catch. assign out = a \&\& !b;

// Incorrect use of a multi-\/bit signal in an if expression always\+\_\+comb \{ if (a) ... else ... \} \hypertarget{group__SVmodule_autotoc_md352}{}\doxysubsection{autotoc\+\_\+md352}\label{group__SVmodule_autotoc_md352}
\hypertarget{group__SVmodule_autotoc_md353}{}\doxyparagraph{Bit Slicing}\label{group__SVmodule_autotoc_md353}
Only use the bit slicing operator when the intent is to refer to a portion of a bit vector.

Examples\+:

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md354}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md354}
logic $<$7\+:0$>$ a, b; logic $<$6\+:0$>$ c;

assign a = 0d7; // good

assign a\mbox{[}7\mbox{]} = 0d5; // good -\/ it\textquotesingle{}s partial assignment. assign a = b; // good -\/ the parser would warn on width mismatch. \hypertarget{group__SVmodule_autotoc_md355}{}\doxysubsection{autotoc\+\_\+md355}\label{group__SVmodule_autotoc_md355}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md356}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md356}
logic $<$7\+:0$>$ a, b;

assign a\mbox{[}8\mbox{]} = 0d7; // BAD -\/ redundant and can mask linter warnings. assign a = b\mbox{[}8\mbox{]}; // BAD -\/ redundant and masks linter warnings. \hypertarget{group__SVmodule_autotoc_md357}{}\doxysubsection{autotoc\+\_\+md357}\label{group__SVmodule_autotoc_md357}
\hypertarget{group__SVmodule_autotoc_md358}{}\doxyparagraph{Handling Width Overflow}\label{group__SVmodule_autotoc_md358}
Beware of shift operations, which can produce a result wider than the operand. Bit-\/selection and concatenation may be clearer than shifting by a constant amount.

Addition and negation operations produce a result one bit wider than the operands, due to carry. An allowable exception to the rule about matching widths is to silently drop the carry on assignment.

Example\+:\hypertarget{group__SVmodule_autotoc_md359}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md359}
logic $<$3\+:0$>$ cnt\+\_\+d, cnt\+\_\+q; assign cnt\+\_\+d = cnt\+\_\+q + 0x1; \hypertarget{group__SVmodule_autotoc_md360}{}\doxysubsection{autotoc\+\_\+md360}\label{group__SVmodule_autotoc_md360}
Or you may explicitly express dropping the carry by using size casting.\hypertarget{group__SVmodule_autotoc_md361}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md361}
assign cnt\+\_\+d = 4(cnt\+\_\+q + 0x1); \hypertarget{group__SVmodule_autotoc_md362}{}\doxysubsection{autotoc\+\_\+md362}\label{group__SVmodule_autotoc_md362}
\hypertarget{group__SVmodule_autotoc_md363}{}\doxysubsubsection{Blocking and Non-\/blocking Assignments}\label{group__SVmodule_autotoc_md363}
{\itshape {\bfseries{Sequential logic must use non-\/blocking assignments. Combinational blocks must use blocking assignments.}}}

Never mix assignment types within a block declaration.

A sequential block (a block that latches state on a clock edge) must exclusively use non-\/block assignments, as defined in the Sequential Logic section below.

Purely combinational blocks must exclusively use blocking assignments.

This is one of Cliff Cummings \href{http://www.ece.cmu.edu/~ece447/s13/lib/exe/fetch.php?media=synth-verilog-cummins.pdf}{\texttt{ Golden Rules of Verilog}}.\hypertarget{group__SVmodule_autotoc_md364}{}\doxysubsubsection{Delay Modeling}\label{group__SVmodule_autotoc_md364}
{\itshape {\bfseries{Do not use \#delay in synthesizable design modules.}}}

Synthesizable design modules must be designed around a zero-\/delay simulation methodology. All forms of \#delay, including \#0, are not permitted.

See Cliff Cummings \href{http://www.sunburst-design.com/papers/CummingsSNUG2002Boston_NBAwithDelays.pdf}{\texttt{ Verilog Nonblocking Assignments With Delays, Myths \& Mysteries}} for details.\hypertarget{group__SVmodule_autotoc_md365}{}\doxysubsubsection{Sequential Logic (\+Latches)}\label{group__SVmodule_autotoc_md365}
{\itshape {\bfseries{The use of latches is discouraged -\/ use flip-\/flops when possible.}}}

Unless absolutely necessary, use flops/registers instead of latches.

If you must use a latch, use always\+\_\+latch over always, and use non-\/blocking assignments ($<$=). Never use blocking assignments (=).\hypertarget{group__SVmodule_autotoc_md366}{}\doxysubsubsection{Sequential Logic (\+Registers)}\label{group__SVmodule_autotoc_md366}
{\itshape {\bfseries{Use the standard format for declaring sequential blocks.}}}

In a sequential always block, only use non-\/blocking assignments ($<$=). Never use blocking assignments (=).

Designs that mix blocking and non-\/blocking assignments for registers simulate incorrectly because some simulators process some of the blocking assignments in an always block as occurring in a separate simulation event as the non-\/blocking assignment. This process makes some signals jump registers, potentially leading to total protonic reversal. Thats bad.

Sequential statements for state assignments should only contain reset values and a next-\/state to state assignment, use a separate combinational-\/only block to generate that next-\/state value.

A correctly implemented 8-\/bit register with an value of \char`\"{}0x\+AB\char`\"{} would be implemented\+:

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md367}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md367}
logic foo\+\_\+en; logic $<$7\+:0$>$ foo\+\_\+q, foo\+\_\+d;

always\+\_\+ff @(posedge clk or negedge rst\+\_\+ni) \{ if (!rst\+\_\+ni) \{ foo\+\_\+q $<$= 0xab; \} else if (foo\+\_\+en) \{ foo\+\_\+q $<$= foo\+\_\+d; \} \} \hypertarget{group__SVmodule_autotoc_md368}{}\doxysubsection{autotoc\+\_\+md368}\label{group__SVmodule_autotoc_md368}
Do not allow multiple non-\/blocking assignments to the same bit.

Example\+:

\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md369}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md369}
if (cond1) \{ abc $<$= 0x1; \}

if (cond2) \{ abc $<$= 0x2; \} \hypertarget{group__SVmodule_autotoc_md370}{}\doxysubsection{autotoc\+\_\+md370}\label{group__SVmodule_autotoc_md370}
If both cond1 and cond2 are true, the Verilog standard says that the second assignment will take effect, but this is a style violation.

Even if cond1 and cond2 are mutually exclusive, make the second if into an \#else if.

Exception\+: It is fine to set default values first, then specific values. However, it is preferred to do this work in a separate combinational block with explicit blocking assignments.

Example\+:\hypertarget{group__SVmodule_autotoc_md371}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md371}
always\+\_\+ff @(posedge clk or negedge rst\+\_\+ni) \{ if (!rst\+\_\+ni) \{ state\+\_\+q $<$= St\+Idle; \} else \{ state\+\_\+q $<$= state\+\_\+d; \} \}

always\+\_\+comb \{ state\+\_\+d = state\+\_\+q; // default assignment next state is present state unique case (state\+\_\+q) \{ St\+Idle\+: state\+\_\+d = St\+Init; // Idle State move to Init St\+Init\+: \{ // Initialize calculation if (conditional) \{ state\+\_\+d = St\+Idle; \} else \{ state\+\_\+d = St\+Calc; \} \} St\+Calc\+: \{ // Perform calculation if (conditional) \{ state\+\_\+d = St\+Result; \} \} St\+Result\+: state\+\_\+d = Idle; default\+: ; \} \} \hypertarget{group__SVmodule_autotoc_md372}{}\doxysubsection{autotoc\+\_\+md372}\label{group__SVmodule_autotoc_md372}
Keep work in sequential blocks simple. If a sequential block becomes sufficiently complicated, consider splitting the combinational logic into a separate combinational (always\+\_\+comb) block. Ideally, sequential blocks should contain only a register instantiation, with perhaps a load enable or an increment.\hypertarget{group__SVmodule_autotoc_md373}{}\doxysubsubsection{Dont Cares (\+Xs)}\label{group__SVmodule_autotoc_md373}
{\itshape {\bfseries{The use of X literals in RTL code is strongly discouraged. RTL must not assert X to indicate \char`\"{}don\textquotesingle{}t care\char`\"{} to synthesis in any case. In order to flag and detect invalid conditions, rather than assign and propagate X values, designs should fully define all signal values and make extensive use of SVAs to indicate the invalid conditions.}}}

If not strictly controlled, the use of X assignments in RTL to flag invalid or dont care conditions can lead to simulation/synthesis mismatches.

Instead of assigning and propagating X in order to flag and detect invalid conditions, it is encouraged to make {\bfseries{extensive use of SVAs}}. The added benefits of this design practice are that\+:


\begin{DoxyItemize}
\item No special code style is required to properly propagate X conditions,
\item The chance of accidentally introducing simulation/synthesis mismatches is systematically reduced,
\item Simulation fails quickly and less signal backtracking is needed to root-\/cause bugs,
\item In several cases, formal property verification (FPV) can be used to prove whether these SVAs can always be fulfilled,
\item In a security context, deterministic/defined behavior is desired, even for illegal/invalid/unreachable input combinations (sometimes stated more tersely as \char`\"{}for security-\/critical designs, there are no don\textquotesingle{}t-\/cares\char`\"{}).
\end{DoxyItemize}

The solution presented here has similarities with the approaches presented in \href{http://www.lcdm-eng.com/papers/snug04_assertiveX.pdf}{\texttt{ \char`\"{}\+Being Assertive With Your X\char`\"{}}} by Don Mills.

Note that although dont cares can be used to indicate possible optimization opportunities to the synthesis tool, it is debatable whether the gains in logic reduction are significant enough to outweigh the possible simulation/synthesis mismatch issues that the use of X literals may entail (especially with the gate-\/counts available in todays technologies).\hypertarget{group__SVmodule_autotoc_md374}{}\doxyparagraph{Catching errors where invalid values are consumed}\label{group__SVmodule_autotoc_md374}
For an internally-\/generated signal that could be invalid (but not driven to X) and is used to trigger some action (such as a register write-\/enable), it is recommened to add an assert to check that when the enable is true, the signal is valid. This triggers a simple to diagnose failure when an invalid value has been accidentally used.\hypertarget{group__SVmodule_autotoc_md375}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md375}
logic reg\+\_\+addr; logic reg\+\_\+wr\+\_\+en;

// internal logic which generates reg\+\_\+addr/reg\+\_\+wr\+\_\+en reg\+\_\+en\+\_\+addr will never // be X but must be ignored if reg\+\_\+wr\+\_\+en == 0 assign reg\+\_\+addr = ... assign reg\+\_\+wr\+\_\+en = ...

...

// trigger some specific action when a certain register is written logic special\+\_\+reg\+\_\+en;

assign special\+\_\+reg\+\_\+en = (reg\+\_\+addr == SPECIAL\+\_\+\+REG\+\_\+\+ADDR) \& reg\+\_\+wr\+\_\+en;

// Aim to keep RHS of implication as broad as possible ASSERT(No\+Special\+Reg\+En\+Without\+Reg\+En, special\+\_\+reg\+\_\+en $\vert$-\/$>$ reg\+\_\+wr\+\_\+en); \hypertarget{group__SVmodule_autotoc_md376}{}\doxysubsection{autotoc\+\_\+md376}\label{group__SVmodule_autotoc_md376}
Where the value and its validity signal are generated by a DV environment which will drive X on invalid signals an ASSERT\+\_\+\+KNOWN suffices.\hypertarget{group__SVmodule_autotoc_md377}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md377}
/$\ast$$\ast$ $\ast$/ ( input \mbox{[}8\mbox{]} external\+\_\+addr\+\_\+i, input external\+\_\+wr\+\_\+en\+\_\+i ) \{

logic special\+\_\+action\+\_\+en;

assign special\+\_\+action\+\_\+en = (external\+\_\+addr\+\_\+i == SPECIAL\+\_\+\+ADDR) \& external\+\_\+wr\+\_\+en\+\_\+i;

ASSERT\+\_\+\+KNOWN(special\+\_\+action\+\_\+en)

\} \hypertarget{group__SVmodule_autotoc_md378}{}\doxysubsection{autotoc\+\_\+md378}\label{group__SVmodule_autotoc_md378}
\hypertarget{group__SVmodule_autotoc_md379}{}\doxyparagraph{Specific Guidance on Case Statements and Ternaries}\label{group__SVmodule_autotoc_md379}
To comply with this style, RTL must place ASSERT\+\_\+\+KNOWN assertions on all /$\ast$$\ast$ $\ast$/ , beginning of the simulation, such as FIFO, SRAM or register file outputs.\hypertarget{group__SVmodule_autotoc_md380}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md380}
/$\ast$$\ast$ $\ast$/ ( input ina\+\_\+i, input inb\+\_\+i, output logic out\+\_\+o ) \{ assign out\+\_\+o = ina\+\_\+i $^\wedge$ inb\+\_\+i; ASSERT\+\_\+\+KNOWN(Out\+Known\+\_\+A, out\+\_\+o, clk\+\_\+i, !rst\+\_\+ni) \} \hypertarget{group__SVmodule_autotoc_md381}{}\doxysubsection{autotoc\+\_\+md381}\label{group__SVmodule_autotoc_md381}
Further, it is encouraged to add assertions to the signals forming conditions of case statements, ternaries or if/else statements. The assertion style is at the designers discretion, and can range from simple ASSERT\+\_\+\+KNOWN to fully functional assertions, as shown in the following examples\+:\hypertarget{group__SVmodule_autotoc_md382}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md382}
typedef enum \{mode0, mode1, mode2\} state\+\_\+e; state\+\_\+e sel;

// encouraged ASSERT\+\_\+\+KNOWN(\+Sel\+Known\+\_\+\+A, sel) always\+\_\+comb \{ out0 = 0; out1 = 0; unique case (sel) \{ mode1\+: out0 = foo; mode2\+: out1 = bar; default\+: ; \} \}

// optional, but more explicit // not always applicable ASSERT(Main\+Fsm\+Case\+\_\+A, sel inside \{mode0, mode1, mode2\}, clk\+\_\+i, !rst\+\_\+ni) always\+\_\+comb \{ out0 = 0; out1 = 0; unique case (sel) \{ mode1\+: out0 = foo; mode2\+: out1 = bar; default\+: ; \} \} \hypertarget{group__SVmodule_autotoc_md383}{}\doxysubsection{autotoc\+\_\+md383}\label{group__SVmodule_autotoc_md383}
In the context of ternary statements, the following are encouraged examples\+:\hypertarget{group__SVmodule_autotoc_md384}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md384}
// encouraged ASSERT\+\_\+\+KNOWN(Mode\+Known\+\_\+A, mode\+\_\+i, clk\+\_\+i, !rst\+\_\+ni) ASSERT\+\_\+\+KNOWN(Len\+Known\+\_\+A, len\+\_\+i, clk\+\_\+i, !rst\+\_\+ni) // assign \textquotesingle{}0 for all other combinations assign val = (mode\+\_\+i == ENC) ? 0x01 \+: (mode\+\_\+i == DEC \&\& len\+\_\+i == LEN128) ? 0x36 \+: (mode\+\_\+i == DEC \&\& len\+\_\+i == LEN192) ? 0x80 \+: (mode\+\_\+i == DEC \&\& len\+\_\+i == LEN256) ? 0x40 \+: 80x00;

// optional, but more explicit ASSERT(Val\+Sel\+Valid\+\_\+A, mode\+\_\+i == ENC $\vert$$\vert$ mode\+\_\+i == DEC \&\& len\+\_\+i inside \{LEN128, LEN192, LEN256\}, clk\+\_\+i, !rst\+\_\+ni) // using one of the valid outputs for other combinations (saves logic) assign val = (mode\+\_\+i == ENC) ? 0x01 \+: (mode\+\_\+i == DEC \&\& len\+\_\+i == LEN128) ? 0x36 \+: (mode\+\_\+i == DEC \&\& len\+\_\+i == LEN192) ? 0x80 \+: (mode\+\_\+i == DEC \&\& len\+\_\+i == LEN256) ? 0x40 \+: 80x01; \hypertarget{group__SVmodule_autotoc_md385}{}\doxysubsection{autotoc\+\_\+md385}\label{group__SVmodule_autotoc_md385}
Note that there are cases where the input into a case or ternary could be X but only under circumstances where it doesnt matter as the output will be ignored as some valid signal that qualifies the input is not set. For example the input may be fed directly from a memory or from a top-\/level input that a DV environment drives to X. A plain ASSERT\+\_\+\+KNOWN will not work under these circumstances and it is appropriate to use an assert with some qualifying valid instead\+:\hypertarget{group__SVmodule_autotoc_md386}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md386}
ASSERT(Addr\+Known\+If\+Valid, addr\+\_\+valid $\vert$-\/$>$ !\$isunknown(addr)) always\+\_\+comb \{ out = 0 unique case (addr\mbox{[}2\mbox{]}) \{ Const\+Addr1\+: out = foo; Const\+Addr2\+: out = bar; default\+: out = baz; \} \} \hypertarget{group__SVmodule_autotoc_md387}{}\doxysubsection{autotoc\+\_\+md387}\label{group__SVmodule_autotoc_md387}
The aim should be to make the qualifying valid signal as wide reaching as possible rather than narrowing down the X check more than is required\+:

\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md388}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md388}
ASSERT(Addr\+Known\+If\+Valid, addr\+\_\+valid \& internal\+\_\+condition\+\_\+1 \& internal\+\_\+condition\+\_\+2 $\vert$-\/$>$ !\$isunknown(addr)) \hypertarget{group__SVmodule_autotoc_md389}{}\doxysubsection{autotoc\+\_\+md389}\label{group__SVmodule_autotoc_md389}
\hypertarget{group__SVmodule_autotoc_md390}{}\doxyparagraph{Dynamic Array Indexing}\label{group__SVmodule_autotoc_md390}
It should be noted that dynamic array indexing operations can implicitly lead to X. This should be avoided if possible by either aligning indexed arrays to powers of 2 or by adding guarding if statements around the indexing operation. These solutions are illustrated in the following examples.

\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md391}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md391}
logic selected; logic $<$3\+:0$>$ idx; logic $<$11\+:0$>$ foo; // problematic

assign foo = \{0b1010\+\_\+1111\+\_\+0000\}; assign selected = foo\mbox{[}idx\mbox{]}; \hypertarget{group__SVmodule_autotoc_md392}{}\doxysubsection{autotoc\+\_\+md392}\label{group__SVmodule_autotoc_md392}
\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md393}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md393}
logic selected; logic $<$3\+:0$>$ idx; logic $<$15\+:0$>$ foo; // aligned to powers of two

assign foo = \{0b0000, 120b1010\+\_\+1111\+\_\+0000\}; assign selected = foo\mbox{[}idx\mbox{]}; \hypertarget{group__SVmodule_autotoc_md394}{}\doxysubsection{autotoc\+\_\+md394}\label{group__SVmodule_autotoc_md394}
\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md395}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md395}
logic selected; logic $<$3\+:0$>$ idx; logic $<$11\+:0$>$ foo;

assign foo = \{0b1010\+\_\+1111\+\_\+0000\};

// guarding if statement assign selected = (idx $<$ \$bits(foo)) ? foo\mbox{[}idx\mbox{]} \+: 0b0; \hypertarget{group__SVmodule_autotoc_md396}{}\doxysubsection{autotoc\+\_\+md396}\label{group__SVmodule_autotoc_md396}
\hypertarget{group__SVmodule_autotoc_md397}{}\doxysubsubsection{Combinational Logic}\label{group__SVmodule_autotoc_md397}
{\itshape {\bfseries{Avoid sensitivity lists, and use a consistent assignment type.}}}

Use always\+\_\+comb for System\+Verilog combinational blocks. Use always @$\ast$ if only Verilog-\/2001 is supported. Never explicitly declare sensitivity lists for combinational logic.

Prefer assign statements wherever practical.

Example\+:\hypertarget{group__SVmodule_autotoc_md398}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md398}
assign final\+\_\+value = xyz ? value\+\_\+a \+: value\+\_\+b; \hypertarget{group__SVmodule_autotoc_md399}{}\doxysubsection{autotoc\+\_\+md399}\label{group__SVmodule_autotoc_md399}
Where a case statement is needed, enclose it in its own always\+\_\+comb block.

Synthesizable combinational logic blocks should only use blocking assignments.

Do not use three-\/state logic (Z state) to accomplish on-\/chip logic such as muxing.

Do not infer a latch inside a , as this may cause a simulation/synthesis mismatch.\hypertarget{group__SVmodule_autotoc_md400}{}\doxysubsubsection{Case Statements}\label{group__SVmodule_autotoc_md400}
{\itshape {\bfseries{Avoid case-\/modifying pragmas. unique case is the best practice. Always define a default case.}}}

Never use either the full\+\_\+case or parallel\+\_\+case pragmas. These pragmas can easily cause simulation/synthesis mismatches.

Here is an example of a style-\/compliant full case statement\+:\hypertarget{group__SVmodule_autotoc_md401}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md401}
always\+\_\+comb \{ unique case (select) \{ 0b000\+: operand = accum0 $>$$>$ 0() \{ 0b001\+: operand = accum0 $>$$>$ 1; 0b010\+: operand = accum1 $>$$>$ 0; 0b011\+: operand = accum1 $>$$>$ 1; 0b1??\+: operand = regfile\mbox{[}select\mbox{[}2\mbox{]}\mbox{]}; default\+: operand = 0; // assign a default \} \} \hypertarget{group__SVmodule_autotoc_md402}{}\doxysubsection{autotoc\+\_\+md402}\label{group__SVmodule_autotoc_md402}
The unique prefix is recommended before all case statements, as it creates simulation assertions that can catch certain mistakes. In some cases, priority may be used instead of unique, though in such cases, cascaded ternary structures should be the preferred way of representing priority encoders as they are a more readable representation for priority encoders.

Be sure to use unique case correctly. In particular, make sure that\+:


\begin{DoxyItemize}
\item a default\+: statement is {\bfseries{always}} included in order to avoid accidental inference of latches, even if all cases are covered. In simulation, a case expression that evaluates to X will not match any case and will behave as a latch, leading to different behavior than synthesis if no default is specified.
\item if no default assignments are given before the case statement as shown in the example above, any variables assigned in one case item must be assigned in all case items, including the default\+:. Failing to do this can lead to a simulation/synthesis mismatch as described in \href{http://www.lcdm-eng.com/papers/snug12_Paper_final.pdf}{\texttt{ Don Mills paper}}.
\end{DoxyItemize}

The following is a different example showing a style-\/compliant case statement variant that is frequently used for describing the next-\/state logic of a finite state machine. What is different from the previous example is that the default assignments are put before the unique case block, thus making it possible to omit common assignments in the individual cases further below. If it werent for the common default assignments before the case statement, all variables would have to be assigned a value in all cases and in the default\+: in order to prevent simulation/synthesis mismatches.\hypertarget{group__SVmodule_autotoc_md403}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md403}
always\+\_\+comb \{ // common default assignments state\+\_\+d = state\+\_\+q; outa = 0b0; outb = 0b0; outc = 0b0;

unique case (state\+\_\+q) \{ Idle\+: \{ state\+\_\+d = Work; outa = in0; \} Work\+: \{ state\+\_\+d = Wait; outb = in1; \} Wait\+: \{ state\+\_\+d = Idle; outc = in2; \} // always include a default case // empty default permissible due to defaults before case block default\+: ; \} \} \hypertarget{group__SVmodule_autotoc_md404}{}\doxysubsection{autotoc\+\_\+md404}\label{group__SVmodule_autotoc_md404}
\hypertarget{group__SVmodule_autotoc_md405}{}\doxyparagraph{Wildcards in case items}\label{group__SVmodule_autotoc_md405}
Use case if wildcard operator behavior is not needed. Use case inside if wildcard operator behavior is needed. Use case if wildcard operator behavior is needed and Verilog-\/2001 compatibility is required.

When expressing a wildcard in a case item, use the ? character since it more clearly expresses the intent.

case should not be used. casex implements a symmetric wildcard operator such that an X in the case expression may match one or more case items. case only treats high-\/impedance states (Z or ?) \{ as a wildcard, and performs exact matches for undriven X inputs. While this does not completely fix the problems with symmetric wildcard matching, it is harder to accidentally produce a Z input than an X input, so this form is preferred. case inside does not treat either X or Z in the case expression as a wildcard, so this form is preferred over case.

References\+:


\begin{DoxyItemize}
\item Don Mills, \href{http://www.lcdm-eng.com/papers/snug12_Paper_final.pdf}{\texttt{ Yet Another Latch and Gotchas Paper}}
\item Clifford Cummings, \href{http://www.sunburst-design.com/papers/CummingsSNUG1999Boston_FullParallelCase_rev1_1.pdf}{\texttt{ full\+\_\+case parallel\+\_\+case, the Evil Twins of Verilog Synthesis}}
\item Clifford Cummings, \href{http://www.sunburst-design.com/papers/CummingsSNUG2005Israel_SystemVerilog_UniquePriority.pdf}{\texttt{ System\+Verilogs priority \& unique}}
\item Sutherland, Mills, and Spear, \href{http://www.lcdm-eng.com/papers/snug07_Verilog\%20Gotchas\%20Part2.pdf}{\texttt{ Gotcha Again\+: More Subtleties in the Verilog and System\+Verilog Standards That Every Engineer Should Know}}
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md406}{}\doxysubsubsection{Generate Constructs}\label{group__SVmodule_autotoc_md406}
{\itshape {\bfseries{Always name your generated blocks.}}}

When using a generate construct, always explicitly name each block of generated code. Name each possible outcome of the generating if statement, and name the iterated block of a generating for statement.

This ensures that generated hierarchical signal names are consistent across different tools.

Generate and all named code blocks should use lower\+\_\+snake\+\_\+case. A space should be placed between \{ and the code block name.

Example of a conditional generate construct\+:

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md407}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md407}
if (Type\+Is\+Posedge) \{ always\+\_\+ff @(posedge clk) foo $<$= bar; \} else \{ always\+\_\+ff @(negedge clk) foo $<$= bar; \} \hypertarget{group__SVmodule_autotoc_md408}{}\doxysubsection{autotoc\+\_\+md408}\label{group__SVmodule_autotoc_md408}
Example of a loop generate construct\+:

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md409}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md409}
for (genvar ii = 0; ii $<$ Number\+Of\+Buses; ii++) \{ my\+\_\+bus $<$.index(ii)$>$ i\+\_\+my\+\_\+bus (.foo(foo), .bar(bar\mbox{[}ii\mbox{]})); \} \hypertarget{group__SVmodule_autotoc_md410}{}\doxysubsection{autotoc\+\_\+md410}\label{group__SVmodule_autotoc_md410}
Do not wrap a generate construct with an additional \{ block.

Do not use generate regions \{generate, endgenerate\}.\hypertarget{group__SVmodule_autotoc_md411}{}\doxysubsubsection{Signed Arithmetic}\label{group__SVmodule_autotoc_md411}
{\itshape {\bfseries{Use the available signed arithmetic constructs wherever signed arithmetic is used.}}}

When its necessary to convert from unsigned to signed, use the signed cast operator (\$signed in Verilog-\/2001).

If any operand in a calculation is unsigned, Verilog implicitly casts all operands to unsigned and generates a warning. There should not be any signed-\/to-\/unsigned warnings from either the simulation or synthesis tools if all unsigned variables are properly casted.

Example of implicit signed-\/to-\/unsigned casting\+:\hypertarget{group__SVmodule_autotoc_md412}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md412}
logic signed \mbox{[}8\mbox{]} a; logic incr; logic signed \mbox{[}15\+:0\mbox{]} sum1, sum2, sum3; \{ a = 8sh80; // a = -\/128 incr = 0b1; sum1 = a + incr; // bad\+: sum1 = 16\textquotesingle{}h0081 ( 129) sum2 = a + signed(\{0b0, incr\}); // good\+: sum2 = 16\textquotesingle{}h\+FF81 (-\/127) sum3 = a + 8sh01; // good\+: sum3 = sum2 (more straightforward) \} \hypertarget{group__SVmodule_autotoc_md413}{}\doxysubsection{autotoc\+\_\+md413}\label{group__SVmodule_autotoc_md413}
In the above example, the fact that incr is unsigned causes a to be evaluated as unsigned as well. The sum1 evaluation is surprising and is flagged by a warning that should not be ignored.\hypertarget{group__SVmodule_autotoc_md414}{}\doxysubsubsection{Number Formatting}\label{group__SVmodule_autotoc_md414}
{\itshape {\bfseries{Prefix printed binary numbers with 0b. Prefix printed hexadecimal numbers with 0x. Do not use prefixes for decimal numbers.}}}

When formatting text representations of numbers for log files, make it clear what data you are including.

Make the base of a printed number clear. Only print decimal numbers without modifiers. Use a 0x prefix for hexadecimal and 0b prefix for binary.

Decode individual fields of large structures individually, instead of expecting the user to manually decode raw values.

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md415}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md415}
\$display(\char`\"{}0x\%0x\char`\"{}, some\+\_\+hex\+\_\+value); \$display(\char`\"{}0b\%0b\char`\"{}, some\+\_\+binary\+\_\+value); \$display(\char`\"{}\%0d\char`\"{}, some\+\_\+decimal\+\_\+value); \hypertarget{group__SVmodule_autotoc_md416}{}\doxysubsection{autotoc\+\_\+md416}\label{group__SVmodule_autotoc_md416}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md417}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md417}
\$display(\char`\"{}\%0x\char`\"{}, some\+\_\+hex\+\_\+value); \$display(\char`\"{}\%0b\char`\"{}, some\+\_\+binary\+\_\+value); \$display(\char`\"{}0d\%0d\char`\"{}, some\+\_\+decimal\+\_\+value); \hypertarget{group__SVmodule_autotoc_md418}{}\doxysubsection{autotoc\+\_\+md418}\label{group__SVmodule_autotoc_md418}
When assigning constant values, it is preferred to use underscore notation for hex or binary bit strengths of length beyond 8 for better readability. Zero prepending is not required unless it improves readability. Declare constants in the format (binary, hex, decimal) they are typically displayed in.

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md419}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md419}
logic $<$15\+:0$>$ val0, val1, val2; logic $<$39\+:0$>$ addr0, addr1;

always\+\_\+comb \{ val0 = 0x0; if (condition1) \{ val1 = 0b0010\+\_\+0011\+\_\+0000\+\_\+1101; val2 = 0b0010\+\_\+1100\+\_\+0000\+\_\+0000; addr1 = 0x00\+\_\+1fc0\+\_\+0000; addr2 = 0x00\+\_\+efc0\+\_\+0000; \} else \{ val0 = 0xffff; val1 = 0b1010\+\_\+0011\+\_\+0110\+\_\+1001; val2 = 0b1110\+\_\+1100\+\_\+1111\+\_\+0110; addr1 = 0x40\+\_\+8000\+\_\+0000; addr2 = 0x41\+\_\+c000\+\_\+0000; \} \} \hypertarget{group__SVmodule_autotoc_md420}{}\doxysubsection{autotoc\+\_\+md420}\label{group__SVmodule_autotoc_md420}
\hypertarget{group__SVmodule_autotoc_md421}{}\doxysubsubsection{Functions and Tasks}\label{group__SVmodule_autotoc_md421}
The following section applies to synthesizable RTL only. See the \mbox{\hyperlink{group__SVmodule}{Coding Style}}Guide for Design Verification"{} for DV usage.

{\itshape {\bfseries{In synthesizable RTL the use of functions is allowed, provided they are declared automatic. Tasks should not be used.}}}

Functions must be declared in either a package or inside a module. A package is appropriate where the relates to other definitions in the package and could be useful to multiple modules (even if its currently only used by one). A /$\ast$$\ast$ $\ast$/ of that module.

Functions should aim to conceptually represent a reusable block of combinational logic.

Storage types must be explicitly declared for all arguments and the return value. All types must be 4-\/state data types, either logic or types derived from logic (such as appropriate struct, enum or typedef types).

Do not use output, inout, or ref on arguments. All functions should only consume inputs and produce one output. input is the default and is not required on the arguments.

\&\#x1f44e() \{ \hypertarget{group__SVmodule_autotoc_md422}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md422}
// -\/ Doesn\textquotesingle{}t have explicit storage type on {\ttfamily a} or {\ttfamily b} or return type // -\/ {\ttfamily b} being used as {\ttfamily output} argument // -\/ {\ttfamily input} not required on {\ttfamily a} automatic \mbox{[}3\mbox{]} foo(input \mbox{[}2\+:0\mbox{]} a, \mbox{[}2\+:0\mbox{]} b) \{ b = b + 1; return a + b; \} \hypertarget{group__SVmodule_autotoc_md423}{}\doxysubsection{autotoc\+\_\+md423}\label{group__SVmodule_autotoc_md423}
public\+: \&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md424}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md424}
// -\/ Doesn\textquotesingle{}t have explicit storage type on {\ttfamily a}, {\ttfamily b} or {\ttfamily c} // -\/ Uses {\ttfamily output} on {\ttfamily c} // -\/ {\ttfamily input} not required on {\ttfamily a} and {\ttfamily b} automatic logic $<$2\+:0$>$ foo(input \mbox{[}3\mbox{]} a, input \mbox{[}2\+:0\mbox{]} b, output \mbox{[}2\+:0\mbox{]} c) \{ c = a -\/ b; return a + b; \} \hypertarget{group__SVmodule_autotoc_md425}{}\doxysubsection{autotoc\+\_\+md425}\label{group__SVmodule_autotoc_md425}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md426}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md426}
// -\/ Uses 2-\/state data type {\ttfamily int} for {\ttfamily a} automatic logic $<$2\+:0$>$ foo(int a, logic $<$2\+:0$>$  b) \{ return a + b; \} \hypertarget{group__SVmodule_autotoc_md427}{}\doxysubsection{autotoc\+\_\+md427}\label{group__SVmodule_autotoc_md427}
\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md428}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md428}
automatic logic $<$2\+:0$>$ foo(logic $<$2\+:0$>$  a, logic $<$2\+:0$>$  b) \{ return a $^\wedge$ b; \} \hypertarget{group__SVmodule_autotoc_md429}{}\doxysubsection{autotoc\+\_\+md429}\label{group__SVmodule_autotoc_md429}
\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md430}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md430}
typedef logic $<$2\+:0$>$ bar\+\_\+t;

typedef struct packed \{ logic $<$2\+:0$>$ field; \} baz\+\_\+t;

automatic logic $<$2\+:0$>$ foo(bar\+\_\+t a, baz\+\_\+t b) \{ return a + b.\+field; \} \hypertarget{group__SVmodule_autotoc_md431}{}\doxysubsection{autotoc\+\_\+md431}\label{group__SVmodule_autotoc_md431}
Data should be returned from a using an explicit return result style. Do not use a function\+\_\+name = result style.

\&\#x1f44e() \{ \hypertarget{group__SVmodule_autotoc_md432}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md432}
automatic logic $<$2\+:0$>$ foo(logic $<$2\+:0$>$  a, logic $<$2\+:0$>$  b) \{ if (a == 0d2) \{ foo = b; \} else \{ foo = a $^\wedge$ b; \} \} \hypertarget{group__SVmodule_autotoc_md433}{}\doxysubsection{autotoc\+\_\+md433}\label{group__SVmodule_autotoc_md433}
\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md434}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md434}
automatic logic $<$2\+:0$>$ foo(logic $<$2\+:0$>$  a, logic $<$2\+:0$>$  b) \{ logic $<$2\+:0$>$ result;

if (a == 0d2) \{ result = b; \} else \{ result = a $^\wedge$ b; \}

return result; \} \hypertarget{group__SVmodule_autotoc_md435}{}\doxysubsection{autotoc\+\_\+md435}\label{group__SVmodule_autotoc_md435}
private\+: All variables must be assigned in all code paths, either through an public\+: assignment or through the use of else and default\+: for if and case statements.

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md436}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md436}
automatic logic $<$2\+:0$>$ foo(logic $<$2\+:0$>$  a, logic $<$2\+:0$>$  b) \{ logic $<$2\+:0$>$ local\+\_\+var\+\_\+1; logic $<$2\+:0$>$ local\+\_\+var\+\_\+2;

local\+\_\+var\+\_\+1 = 0d0;

if (a == 0) \{ local\+\_\+var\+\_\+1 = 0d2; \}

unique case (b) \{ 0d0\+: local\+\_\+var\+\_\+2 = 30d1; 0d1\+: local\+\_\+var\+\_\+2 = 30d3; default\+: local\+\_\+var\+\_\+2 = 0d0; \}

return local\+\_\+var\+\_\+1 + local\+\_\+var\+\_\+2; \} \hypertarget{group__SVmodule_autotoc_md437}{}\doxysubsection{autotoc\+\_\+md437}\label{group__SVmodule_autotoc_md437}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md438}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md438}
automatic logic $<$2\+:0$>$ foo(logic $<$2\+:0$>$  a, logic $<$2\+:0$>$  b) \{ logic $<$2\+:0$>$ local\+\_\+var\+\_\+1; logic $<$2\+:0$>$ local\+\_\+var\+\_\+2;

if (a == 0) \{ local\+\_\+var\+\_\+1 = 0d2; \}

unique case (b) \{ 0d0\+: local\+\_\+var\+\_\+2 = 30d1; 0d1\+: local\+\_\+var\+\_\+2 = 30d3; \}

return local\+\_\+var\+\_\+1 + local\+\_\+var\+\_\+2; \} \hypertarget{group__SVmodule_autotoc_md439}{}\doxysubsection{autotoc\+\_\+md439}\label{group__SVmodule_autotoc_md439}
private\+: Functions should not reference any non-\/ signals or variables outside their scope. Avoiding non-\/ references improves readability and helps reduce simulation/synthesis mismatches. Accessing non-\/ parameters and constants public\+: is allowed.

\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md440}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md440}
// -\/ Incorrect because {\ttfamily mem} is not local to get\+\_\+mem() // -\/ Incorrect because {\ttfamily in\+\_\+i} is not local to get\+\_\+mem() /$\ast$$\ast$ $\ast$/ ( input logic $<$7\+:0$>$ in\+\_\+i, output logic $<$7\+:0$>$ out\+\_\+o ) \{

logic $<$7\+:0$>$ mem\mbox{[}256\mbox{]};

automatic logic $<$7\+:0$>$ get\+\_\+mem() \{ return mem\mbox{[}in\+\_\+i\mbox{]}; \}

assign out\+\_\+o = get\+\_\+mem();

\} \hypertarget{group__SVmodule_autotoc_md441}{}\doxysubsection{autotoc\+\_\+md441}\label{group__SVmodule_autotoc_md441}
\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md442}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md442}
// -\/ Correct because {\ttfamily Magic\+Value} is a parameter // -\/ Correct because {\ttfamily my\+\_\+pkg\+::\+Other\+Magic\+Value} is a parameter // -\/ Correct because {\ttfamily in\+\_\+i} passed as an argument /$\ast$$\ast$ $\ast$/ ( input logic $<$7\+:0$>$ in\+\_\+i, output logic $<$7\+:0$>$ out\+\_\+o ) \{

localparam \mbox{[}8\mbox{]} Magic\+Value = 1;

automatic logic is\+\_\+magic(logic $<$7\+:0$>$  v) \{ return (v == Magic\+Value) $\vert$$\vert$ (v == my\+\_\+pkg\+::\+Other\+Magic\+Value); \}

assign out\+\_\+o = is\+\_\+magic(in\+\_\+i);

\} \hypertarget{group__SVmodule_autotoc_md443}{}\doxysubsection{autotoc\+\_\+md443}\label{group__SVmodule_autotoc_md443}
\hypertarget{group__SVmodule_autotoc_md444}{}\doxysubsubsection{Problematic Language Features and Constructs}\label{group__SVmodule_autotoc_md444}
These language features are considered problematic and their use is discouraged unless otherwise noted\+:


\begin{DoxyItemize}
\item Interfaces.
\item The alias statement.
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md445}{}\doxyparagraph{Floating \{-\/\} blocks}\label{group__SVmodule_autotoc_md445}
The use of generate blocks other than for loop, if, or case generate constructs is not LRM compliant. While such usage might be accepted by some tools, this guide prohibits such \char`\"{}bare\char`\"{} generate blocks. Note that the similar \char`\"{}sequential block\char`\"{} construct is LRM compliant and allowed.

\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md446}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md446}
/$\ast$$\ast$ $\ast$/ ( input bar, output foo ) \{ \{ // illegal generate block assign foo = bar; \} \} \hypertarget{group__SVmodule_autotoc_md447}{}\doxysubsection{autotoc\+\_\+md447}\label{group__SVmodule_autotoc_md447}
\hypertarget{group__SVmodule_autotoc_md448}{}\doxyparagraph{Hierarchical references}\label{group__SVmodule_autotoc_md448}
The use of hierarchical references in synthesizable RTL code is prohibited. Certain synthesis tools indeed support hierarchical references, while some tools error out and others may silently ignore them potentially leading to simulation/synthesis mismatches.

An exemption to this is the case where the hierarchical references are guarded by macros to remove them for synthesis, e.\+g., as part of System\+Verilog assertions (SVAs).

\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md449}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md449}
/$\ast$$\ast$ $\ast$/ ( input in0\+\_\+i, input in1\+\_\+i, input in2\+\_\+i, output logic out\+\_\+o ) \{

logic int; assign int = in0\+\_\+i \& in1\+\_\+i; assign out\+\_\+o = in2\+\_\+i $\vert$ int;

\}

/$\ast$$\ast$ $\ast$/ ( ... ) \{

mymod\+\_\+int u\+\_\+mymod\+\_\+int ( .in0\+\_\+i, .in1\+\_\+i, .in2\+\_\+i, .out\+\_\+o );

// Hierarchical references are prohibited in synthesizable RTL code. assign int\+\_\+o = u\+\_\+mymod\+\_\+int.\+int;

\} \hypertarget{group__SVmodule_autotoc_md450}{}\doxysubsection{autotoc\+\_\+md450}\label{group__SVmodule_autotoc_md450}
\hypertarget{group__SVmodule_autotoc_md451}{}\doxysubsection{Design Conventions}\label{group__SVmodule_autotoc_md451}
\hypertarget{group__SVmodule_autotoc_md452}{}\doxysubsubsection{Summary}\label{group__SVmodule_autotoc_md452}
The key ideas in this section include\+:


\begin{DoxyItemize}
\item Declare all signals and use logic\+: logic foo;
\item Packed arrays are little-\/endian\+: logic $<$7\+:0$>$ byte;
\item Unpacked arrays are big-\/endian\+: byte\+\_\+t arr\mbox{[}0\+:N-\/1\mbox{]};
\item Prefer to register /$\ast$$\ast$ $\ast$/ .
\item Declare FSMs consistently.
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md453}{}\doxysubsubsection{Declare all signals}\label{group__SVmodule_autotoc_md453}
{\itshape {\bfseries{Do not rely on inferred nets.}}}

All signals {\bfseries{must}} be explicitly declared before use. All declared signals must specify a data type. A correct design contains no inferred nets.\hypertarget{group__SVmodule_autotoc_md454}{}\doxysubsubsection{Use logic for synthesis}\label{group__SVmodule_autotoc_md454}
{\itshape {\bfseries{Use logic for synthesis. wire is allowed when necessary.}}}

All signals in synthesizable RTL must be implemented in terms of 4-\/state data types. This means that all signals must ultimately be constructed of nets with the storage type of logic. While System\+Verilog does provide other data primitives with 4-\/state storage (ie. integer), those primitives are prone to misunderstandings and misuse.

For example\+:

\&\#x1f44d() \{ \hypertarget{group__SVmodule_autotoc_md455}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md455}
logic signed \mbox{[}31\+:0\mbox{]} x\+\_\+velocity; // say what you mean\+: a signed 32-\/bit integer. typedef logic $<$7\+:0$>$ byte\+\_\+t; \hypertarget{group__SVmodule_autotoc_md456}{}\doxysubsection{autotoc\+\_\+md456}\label{group__SVmodule_autotoc_md456}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md457}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md457}
bit signed \mbox{[}63\+:0\mbox{]} stars\+\_\+in\+\_\+the\+\_\+sky; // 2-\/state logic doesn\textquotesingle{}t belong in RTL int grains\+\_\+of\+\_\+sand; // Or wait, did I mean integer? Easy to confuse! \hypertarget{group__SVmodule_autotoc_md458}{}\doxysubsection{autotoc\+\_\+md458}\label{group__SVmodule_autotoc_md458}
It is permissible to use wire as a short-\/hand to both declare a net and perform continuous assignment. Take care not to confuse continuous assignment with initialization. For example\+:

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md459}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md459}
wire $<$7\+:0$>$ sum = a + b; // Continuous assignment \hypertarget{group__SVmodule_autotoc_md460}{}\doxysubsection{autotoc\+\_\+md460}\label{group__SVmodule_autotoc_md460}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md461}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md461}
logic $<$7\+:0$>$ sum = a + b; // Initialization (not synthesizable) \hypertarget{group__SVmodule_autotoc_md462}{}\doxysubsection{autotoc\+\_\+md462}\label{group__SVmodule_autotoc_md462}
sum is initialized to sum of values of a and b.

\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md463}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md463}
logic $<$7\+:0$>$ acc = 0; // Initialization (synthesizable on some FPGA tools) \hypertarget{group__SVmodule_autotoc_md464}{}\doxysubsection{autotoc\+\_\+md464}\label{group__SVmodule_autotoc_md464}
There are exceptions for places where logic is inappropriate. For example, nets that connect to bidirectional (inout) ports must be declared with wire. These exceptions should be justified with a short comment.

It is permissible for DV (Design Verification) to make use of 2-\/state logic, but all interfaces between 4-\/state and 2-\/state signals must assert a check for X on the 4-\/state net before resolving to a 2-\/state variable.\hypertarget{group__SVmodule_autotoc_md465}{}\doxysubsubsection{Logical vs. Bitwise}\label{group__SVmodule_autotoc_md465}
{\itshape {\bfseries{Prefer logical constructs for logical comparisons, bit-\/wise for data.}}}

Logical operators (!, $\vert$$\vert$, \&\&, ==, !=) should be used for all constructs that are evaluating logic (true or false) values, such as if clauses and ternary assignments. Prefer bit-\/wise operators ($\sim$, $\vert$, \&, $^\wedge$) for all data constructs, even if scalar. Exceptions can be made where it is clear that the evaluated expression is to be used in a logical context.

\+:+1\+: \hypertarget{group__SVmodule_autotoc_md466}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md466}
always\+\_\+ff @(posedge clk\+\_\+i or negedge rst\+\_\+ni) \{ if (!rst\+\_\+ni) \{ reg\+\_\+q $<$= 0; \} else \{ reg\+\_\+q $<$= reg\+\_\+d; \} \}

always\+\_\+comb \{ if (bool\+\_\+a $\vert$$\vert$ (bool\+\_\+b \&\& !bool\+\_\+c) \{ x = 0b1; \} else \{ x = 0b0; \}

assign z = ((bool\+\_\+a != bool\+\_\+b) $\vert$$\vert$ bool\+\_\+c) ? a \+: b; assign y = (a \& $\sim$b) $\vert$ c; \hypertarget{group__SVmodule_autotoc_md467}{}\doxysubsection{autotoc\+\_\+md467}\label{group__SVmodule_autotoc_md467}
\+:-\/1\+: \hypertarget{group__SVmodule_autotoc_md468}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md468}
always\+\_\+ff @(posedge clk\+\_\+i or negedge rst\+\_\+ni) \{ if ($\sim$rst\+\_\+ni) \{ reg\+\_\+q $<$= 0; \} else \{ reg\+\_\+q $<$= reg\+\_\+d; \} \}

always\+\_\+comb \{ if (bool\+\_\+a $\vert$ (bool\+\_\+b \& $\sim$bool\+\_\+c) \{ x = 0b1; \} else \{ x = 0b0; \}

assign z = ((bool\+\_\+a $^\wedge$ bool\+\_\+b) $\vert$ bool\+\_\+c) ? a \+: b; assign y = (a \&\& !b) $\vert$$\vert$ c; \hypertarget{group__SVmodule_autotoc_md469}{}\doxysubsection{autotoc\+\_\+md469}\label{group__SVmodule_autotoc_md469}
\+:+1\+: \hypertarget{group__SVmodule_autotoc_md470}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md470}
// allowed logical assignment for boolean test assign request\+\_\+valid = !fifo\+\_\+empty \&\& data\+\_\+available;

always\+\_\+comb \{ if (request\+\_\+valid) \{ output\+\_\+valid = 0b1; \} else \{ output\+\_\+valid = 0b0; \} \} \hypertarget{group__SVmodule_autotoc_md471}{}\doxysubsection{autotoc\+\_\+md471}\label{group__SVmodule_autotoc_md471}
\hypertarget{group__SVmodule_autotoc_md472}{}\doxysubsubsection{Packed Ordering}\label{group__SVmodule_autotoc_md472}
{\itshape {\bfseries{Bit vectors and packed arrays must be little-\/endian.}}}

When declaring bit vectors and packed arrays, the index of the most-\/significant bound (left of the colon) must be greater than or equal to the least-\/significant bound (right of the colon).

This style of bit vector declaration keeps packed variables little-\/endian.

For example\+:\hypertarget{group__SVmodule_autotoc_md473}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md473}
typedef logic $<$7\+:0$>$ u8\+\_\+t; logic $<$31\+:0$>$ u32\+\_\+word; u8\+\_\+t \mbox{[}2\mbox{]} u16\+\_\+word; u8\+\_\+t byte3, byte2, byte1, byte0; assign u16\+\_\+word = \{byte1, byte0\}; assign u32\+\_\+word = \{byte3, byte2, u16\+\_\+word\}; \hypertarget{group__SVmodule_autotoc_md474}{}\doxysubsection{autotoc\+\_\+md474}\label{group__SVmodule_autotoc_md474}
\hypertarget{group__SVmodule_autotoc_md475}{}\doxysubsubsection{Unpacked Ordering}\label{group__SVmodule_autotoc_md475}
{\itshape {\bfseries{Unpacked arrays must be big-\/endian.}}}

Declare unpacked arrays in big-\/endian fashion (for instance, \mbox{[}n\+:m\mbox{]} where n $<$= m). Never declare an unpacked array in little-\/endian order, such as \mbox{[}size-\/1\+:0\mbox{]}.

Declare zero-\/based unpacked arrays using the shorter notation \mbox{[}size\mbox{]}. It is understood that \mbox{[}size\mbox{]} is equivalent to the big-\/endian declaration \mbox{[}0\+:size-\/1\mbox{]}.\hypertarget{group__SVmodule_autotoc_md476}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md476}
logic $<$15\+:0$>$ word\+\_\+array\mbox{[}3\mbox{]} = (word0, word1, word2); \hypertarget{group__SVmodule_autotoc_md477}{}\doxysubsection{autotoc\+\_\+md477}\label{group__SVmodule_autotoc_md477}
\hypertarget{group__SVmodule_autotoc_md478}{}\doxysubsubsection{Finite State Machines}\label{group__SVmodule_autotoc_md478}
{\itshape {\bfseries{State machines use an enum to define states, and be implemented with two process blocks\+: a combinational block and a clocked block.}}}

Every state machine description has three parts\+:


\begin{DoxyEnumerate}
\item An enum that declares and describes the states.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item A combinational process block that decodes state to produce next state and other combinational outputs.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item A clocked process block that updates state from next state.
\end{DoxyEnumerate}

{\itshape Enumerating States}

The enum statement for the state machine should list each state in the state machine. Comments describing the states should be deferred to case statement in the combinational process block, below.

States should be named in Upper\+Camel\+Case, like other \href{\#enumerations}{\texttt{ enumeration constants}}.

Barring special circumstances, the idle state of the state machines will be named Idle or St\+Idle. (Alternate names are acceptable if they improve clarity.)

Ideally, each /$\ast$$\ast$ $\ast$/ . more than one state machine, you will need to add a unique prefix (or suffix) to the states of each state machine, to distinguish which state is associated with which state machine. For example, a /$\ast$$\ast$ $\ast$/ \char`\"{}\char`\"{} \char`\"{}writer\char`\"{} machine might have a St\+Rd\+Idle state and a St\+Wr\+Idle state.

{\itshape Combinational Decode of State}

The combinational process block should contain\+:


\begin{DoxyItemize}
\item A case statement that decodes state to produce next state and combinational outputs. For clarity, only cases where the output value deviates from the default should be coded.
\item Before the case statement should be a block of code that defines default values for every combinational output, including \char`\"{}next state.\char`\"{}
\item The default value for the \char`\"{}next state\char`\"{} variable should be the current state. The case statement that decodes state will then only assign to \char`\"{}next state\char`\"{} when transitioning between states.
\item Within the case statement, each state alternative should be preceded with a comment that describes the of that state within the state machine.
\end{DoxyItemize}

{\itshape The State Register}

No logic except for reset should be performed in this process. The state variable should latch the value of the \char`\"{}next state\char`\"{} variable.

{\itshape Other Guidelines}

When possible, try to choose state names that differ near the beginning of their name, to make them more readable when viewing waveform traces.

{\itshape Example}

\&\#x1f44d() \{ \hypertarget{group__SVmodule_autotoc_md479}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md479}
// Define the states typedef enum \{ St\+Idle, St\+Frame\+Start, St\+Dyn\+Instr\+Read, St\+Band\+Corr, St\+Acc\+Store\+Write, St\+Band\+End \} alcor\+\_\+state\+\_\+e() \{

alcor\+\_\+state\+\_\+e alcor\+\_\+state\+\_\+d, alcor\+\_\+state\+\_\+q;

// Combinational decode of the state always\+\_\+comb \{ alcor\+\_\+state\+\_\+d = alcor\+\_\+state\+\_\+q; foo = 0b0; bar = 0b0; bum = 0b0; unique case (alcor\+\_\+state\+\_\+q) \{ // St\+Idle\+: waiting for frame\+\_\+start St\+Idle\+: if (frame\+\_\+start) \{ foo = 0b1; alcor\+\_\+state\+\_\+d = St\+Frame\+Start; \} // St\+Frame\+Start\+: Reset accumulators St\+Frame\+Start\+: \{ // ... etc ... \} // may be empty or used to catch parasitic states default\+: alcor\+\_\+state\+\_\+d = St\+Idle; \} \}

// Register the state always\+\_\+ff @(posedge clk or negedge rst\+\_\+n) \{ if (!rst\+\_\+n) \{ alcor\+\_\+state\+\_\+q $<$= St\+Idle; \} else \{ alcor\+\_\+state\+\_\+q $<$= alcor\+\_\+state\+\_\+d; \} \} \hypertarget{group__SVmodule_autotoc_md480}{}\doxysubsection{autotoc\+\_\+md480}\label{group__SVmodule_autotoc_md480}
\hypertarget{group__SVmodule_autotoc_md481}{}\doxysubsubsection{Active-\/\+Low Signals}\label{group__SVmodule_autotoc_md481}
{\itshape {\bfseries{The \+\_\+n suffix indicates an active-\/low signal.}}}

If active-\/low signals are used, they must have the \+\_\+n suffix in their name. Otherwise, all signals are assumed to be active-\/high.\hypertarget{group__SVmodule_autotoc_md482}{}\doxysubsubsection{Differential Pairs}\label{group__SVmodule_autotoc_md482}
{\itshape {\bfseries{Use the \+\_\+p and \+\_\+n suffixes to indicate a differential pair.}}}

For example, in\+\_\+p and in\+\_\+n comprise a differential pair set.\hypertarget{group__SVmodule_autotoc_md483}{}\doxysubsubsection{Delays}\label{group__SVmodule_autotoc_md483}
{\itshape {\bfseries{Signals delayed by a single clock cycle should \} in a \+\_\+q suffix.}}}

If one signal is only a delayed version of another signal, the \+\_\+q suffix should be used to indicate this relationship.

If another signal is then delayed by another clock cycle, the next signal should be identifed with the \+\_\+q2 suffix, and then \+\_\+q3 and so on.

Example\+:\hypertarget{group__SVmodule_autotoc_md484}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md484}
always\+\_\+ff @(posedge clk) \{ data\+\_\+valid\+\_\+q $<$= data\+\_\+valid\+\_\+d; data\+\_\+valid\+\_\+q2 $<$= data\+\_\+valid\+\_\+q; data\+\_\+valid\+\_\+q3 $<$= data\+\_\+valid\+\_\+q2; \} \hypertarget{group__SVmodule_autotoc_md485}{}\doxysubsection{autotoc\+\_\+md485}\label{group__SVmodule_autotoc_md485}
\hypertarget{group__SVmodule_autotoc_md486}{}\doxysubsubsection{Wildcard import of packages}\label{group__SVmodule_autotoc_md486}
The wildcard import syntax, e.\+g. is only allowed where the package is part of the same IP as the /$\ast$$\ast$ $\ast$/ . import statement must be placed in the /$\ast$$\ast$ $\ast$/ .

\&\#x1f44d() \{ \hypertarget{group__SVmodule_autotoc_md487}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md487}
// mod\+\_\+a\+\_\+pkg.\+sv and mod\+\_\+a.\+sv are in the same IP. // Packages can be imported in the module declaration if access to // unqualified types is needed in the port list.

// mod\+\_\+a\+\_\+pkg.\+sv

typedef struct packed \{ ... \} a\+\_\+req\+\_\+t;

// mod\+\_\+a.\+sv /$\ast$$\ast$ $\ast$/ import mod\+\_\+a\+\_\+pkg\+:\+:$\ast$() \{ ( ... a\+\_\+req\+\_\+t a\+\_\+req, ... );

\} \hypertarget{group__SVmodule_autotoc_md488}{}\doxysubsection{autotoc\+\_\+md488}\label{group__SVmodule_autotoc_md488}
\&\#x1f44d; \hypertarget{group__SVmodule_autotoc_md489}{}\doxysubsection{systemverilog \{.\+good\}}\label{group__SVmodule_autotoc_md489}
// mod\+\_\+a /$\ast$$\ast$ $\ast$/ () \{

// mod\+\_\+a\+\_\+pkg.\+sv and mod\+\_\+a.\+sv are in the same IP.

...

a\+\_\+req\+\_\+t a\+\_\+req;

\} \hypertarget{group__SVmodule_autotoc_md490}{}\doxysubsection{autotoc\+\_\+md490}\label{group__SVmodule_autotoc_md490}
Other than the cases above, wildcard imports are not allowed. For instance, the example below may create a name collision in the /$\ast$$\ast$ $\ast$/ in the source list.

\&\#x1f44e() \{ \hypertarget{group__SVmodule_autotoc_md491}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md491}
// mod\+\_\+a.\+sv // not allowed\+: imported to \$root scope.

/$\ast$$\ast$ $\ast$/ () \{

\} \hypertarget{group__SVmodule_autotoc_md492}{}\doxysubsection{autotoc\+\_\+md492}\label{group__SVmodule_autotoc_md492}
Other bad examples\+:

\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md493}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md493}
// wildcard import for other packages outside of the IP /$\ast$$\ast$ $\ast$/ () \{ \hypertarget{group__SVmodule_autotoc_md494}{}\doxysubsection{autotoc\+\_\+md494}\label{group__SVmodule_autotoc_md494}
\&\#x1f44e; \hypertarget{group__SVmodule_autotoc_md495}{}\doxysubsection{systemverilog \{.\+bad\}}\label{group__SVmodule_autotoc_md495}
/$\ast$$\ast$ $\ast$/ () \{

// not allowed\+: wildcard import of a package from a different IP

\} \hypertarget{group__SVmodule_autotoc_md496}{}\doxysubsection{autotoc\+\_\+md496}\label{group__SVmodule_autotoc_md496}
\hypertarget{group__SVmodule_autotoc_md497}{}\doxysubsubsection{Assertion Macros}\label{group__SVmodule_autotoc_md497}
It is encouraged to use System\+Verilog assertions (SVAs) throughout the design to check functional correctness and flag invalid conditions. In order to increase productivity and keep the assertions short and concise, the following assertion macros can be used\+:\hypertarget{group__SVmodule_autotoc_md498}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md498}
// immediate assertion, to be placed within a process. ASSERT\+\_\+\+I($<$name$>$, $<$property$>$) // immediate assertion wrapped within an initial block. can be used for things // like parameter checking. ASSERT\+\_\+\+INIT($<$name$>$, $<$property$>$) // concurrent assertion to be used for functional assertions. ASSERT($<$name$>$, $<$property$>$, $<$clk$>$, $<$reset condition$>$) // concurrent assertion that checks that a signal has a known value after reset // (i.\+e. that the signal is not {\ttfamily X}). ASSERT\+\_\+\+KNOWN($<$name$>$, $<$signal$>$, $<$clk$>$, $<$reset condition$>$) \hypertarget{group__SVmodule_autotoc_md499}{}\doxysubsection{autotoc\+\_\+md499}\label{group__SVmodule_autotoc_md499}
An implementation of these macros (including other useful variations thereof) can be found here\+: \href{https://github.com/lowRISC/opentitan/blob/master/hw/ip/prim/rtl/prim_assert.sv}{\texttt{ https\+://github.\+com/low\+RISC/opentitan/blob/master/hw/ip/prim/rtl/prim\+\_\+assert.\+sv}}\hypertarget{group__SVmodule_autotoc_md500}{}\doxyparagraph{A Note on Security Critical Applications}\label{group__SVmodule_autotoc_md500}
For security critical applications, the names of the assertion macros involved in guarding case statements and ternaries shall be postfixed with \+\_\+\+SEC. This enables security-\/specific post-\/processing of these statements at a later stage in the design process. In terms of functionality these macros should be identical to the original assertions, i.\+e.,\hypertarget{group__SVmodule_autotoc_md501}{}\doxysubsection{systemverilog}\label{group__SVmodule_autotoc_md501}
\#define ASSERT\+\_\+\+SEC ASSERT \#define ASSERT\+\_\+\+I\+\_\+\+SEC ASSERT\+\_\+I \#define ASSERT\+\_\+\+KNOWN\+\_\+\+SEC ASSERT\+\_\+\+KNOWN \hypertarget{group__SVmodule_autotoc_md502}{}\doxysubsection{autotoc\+\_\+md502}\label{group__SVmodule_autotoc_md502}
More security assertion and coding style guidance will be given in a separate document, soon.\hypertarget{group__SVmodule_autotoc_md503}{}\doxysubsection{Appendix -\/ Condensed Style Guide}\label{group__SVmodule_autotoc_md503}
This is a short summary of the Comportable style guide. Refer to the main text body for explanations examples, and exceptions.\hypertarget{group__SVmodule_autotoc_md504}{}\doxysubsubsection{Basic Style Elements}\label{group__SVmodule_autotoc_md504}

\begin{DoxyItemize}
\item Use System\+Verilog-\/2012 conventions, files named as module.\+sv, one file per /$\ast$$\ast$ $\ast$/
\item Only ASCII, {\bfseries{100}} chars per line, {\bfseries{no}} tabs, {\bfseries{two}} spaces per indent for all paired keywords.
\item C++ style comments //\`{}
\item For multiple items on a line, {\bfseries{one}} space must separate the comma and the next character
\item Include {\bfseries{whitespace}} around keywords and binary operators
\item {\bfseries{No}} space between case item and colon, /task/macro call and open parenthesis
\item Line wraps should indent by {\bfseries{four}} spaces
\item \{ must be on the same line as the preceding keyword and \} the line
\item \} must start a new line
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md505}{}\doxysubsubsection{Construct Naming}\label{group__SVmodule_autotoc_md505}

\begin{DoxyItemize}
\item Use {\bfseries{lower\+\_\+snake\+\_\+case}} for instance names, signals, declarations, variables, types
\item Use {\bfseries{Upper\+Camel\+Case}} for tunable parameters, enumerated value names
\item Use {\bfseries{ALL\+\_\+\+CAPS}} for constants and define macros
\item Main clock signal is named clk. All clock signals must start with clk\+\_\+
\item Reset signals are {\bfseries{active-\/low}} and {\bfseries{asynchronous}}, default name is rst\+\_\+n
\item Signal names should be descriptive and be consistent throughout the hierarchy
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md506}{}\doxysubsubsection{Suffixes for signals and types}\label{group__SVmodule_autotoc_md506}

\begin{DoxyItemize}
\item Add \+\_\+i to /$\ast$$\ast$ $\ast$/ , bi-\/directional /$\ast$$\ast$ $\ast$/
\item The input (next state) of a registered signal should have \+\_\+d and the output \+\_\+q as suffix
\item Pipelined versions of signals should be named \+\_\+q2, \+\_\+q3, etc. to reflect their latency
\item Active low signals should use \+\_\+n. When using differential signals use \+\_\+p for active high
\item Enumerated types should be suffixed with \+\_\+e
\item Multiple suffixes will not be separated with \+\_\+. n should come first i, o, or io last
\end{DoxyItemize}\hypertarget{group__SVmodule_autotoc_md507}{}\doxysubsubsection{Language features}\label{group__SVmodule_autotoc_md507}

\begin{DoxyItemize}
\item Use {\bfseries{full port declaration style}} for modules, any clock and reset declared first
\item Use {\bfseries{named parameters}} for instantiation, all declared ports must be present, no .$\ast$
\item Top-\/level parameters is preferred over define globals
\item Use {\bfseries{symbolically named constants}} instead of raw numbers
\item Local constants should be declared localparam, globals in a separate $\ast$$\ast$.svh$\ast$$\ast$ file.
\item logic is preferred over reg and wire, declare all signals explicitly
\item always\+\_\+comb, always\+\_\+ff and always\+\_\+latch are preferred over always
\item Interfaces are discouraged
\item Sequential logic must use {\bfseries{non-\/blocking}} assignments
\item Combinational blocks must use {\bfseries{blocking}} assignments
\item Use of latches is discouraged, use flip-\/flops when possible
\item The use of X assignments in RTL is strongly discouraged, make use of SVAs to check invalid behavior instead.
\item Prefer assign statements wherever practical.
\item Use unique case and always define a default case
\item Use available signed arithmetic constructs wherever signed arithmetic is used
\item When printing use 0b and 0x as a prefix for binary and hex. Use \+\_\+ for clarity
\item Use logical constructs (i.\+e $\vert$$\vert$) for logical comparison, bit-\/wise (i.\+e $\vert$) for data comparison
\item Bit vectors and packed arrays must be little-\/endian, unpacked arrays must be big-\/endian
\item FSMs\+: {\bfseries{no logic}} except for reset should be performed in the process for the state register
\item A combinational process should first define {\bfseries{default value}} of all outputs in the process
\item Default value for next state variable should be the current state /$\ast$$\ast$ 
\end{DoxyItemize}